{"posts":[{"title":"","text":"链表 Note注意判断链表为空的情况 while 和if 一样满足条件进入循环 链表操作链表的移除特定数值有两种方法： 方法1：直接使用原来的链表来进行删除操作。需要通过while保证头节点不是移除节点。 12345678910111213141516171819202122public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) { head = head.next; } // 已经为null，提前退出 if (head == null) { return head; } // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return head;} 方法2：使用虚拟节点。这样头结点和其他节点的移除方式完全一致，少了判断头节点是不是目标节点和头节点为空的情况 123456789101112131415161718public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummy.next;} 707.设计链表https://leetcode.cn/problems/design-linked-list/description/ 思路是：创建一个虚拟头保证一致，设计链表最大的问题就是你不确定什么时候是while（temp.next！=null）还是while（temp！=null）这个逻辑就是判断里边需不需要temp.next.val如果不需要那么就可以temp，这样的话就会多迭代一次迭代一次最后的null。所有的尾端插入都一样，头部插入引入虚拟头之后一样，中间插入要记录上一个节点，删除也要记录上一个节点， 24. 两两交换链表中的节点解题思路就是画图，并且你要保证改变指针之后不影响后续的操作。然后虚拟节点的作用也是一样，不用单独考虑头节点的情况。步骤之间的顺序你一定要理清楚，如果中间改变了cur-next那原有的链接就会消失。所以最好的做法就是提前保存这些变量。你如果要调换步骤23那么temp= cur-&gt;next-&gt;next。 1234567891011121314151617181920class Solution { public ListNode swapPairs(ListNode head) { ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点 dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode cur = dumyhead; ListNode temp; // 临时节点，保存两个节点后面的节点 ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点 ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点 while (cur.next != null &amp;&amp; cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } return dumyhead.next; }} 还有一个递归的解法比较难以理解，递归的思想就是从后往前倒退。这里我直接画一个迭代的图，每一次递归的都是两个数之后即next-&gt;next，所以两次head是1，3。再一次递归会出现null并给3的递归new Node 返回null， 1234567891011121314class Solution { public ListNode swapPairs(ListNode head) { // base case 退出提交 if(head == null || head.next == null) return head; // 获取当前节点的下一个节点 ListNode next = head.next; // 进行递归 ListNode newNode = swapPairs(next.next); // 这里进行交换 next.next = head; head.next = newNode; return next; }} 链表相交面试题 02.07. 链表相交 这个暴力通过两个while循环来做很简单，但是提供一种新思路先确定长度，在根据长度，然后计算两个的差，给长的那个的current加上这个差保证统一长度，这样在一对一的比较就可以很快的找到想找的相交点了。 环形链表 https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html 找到相交点可以通过快慢指针决定。证明如下，找到成环点就是x=z所以再创建另一个节点从起点出发就行了与slow的相交点就是入还点。 总结","link":"/2024/01/25/PartII_LInked_list/"},{"title":"","text":"数组定义：数组是存放在连续内存空间上的相同类型数据的集合。 知识 C++：int类型4字节float类型在32位中是4字节 在64位中是8字节 Java的一维数组是连续的，二维数组在内存中不是连续地址空间 右移一维相当于除以2 k–是最后减去k=1 i=k–；之后i=1，k=0 题目二分法前提是数组为有序数组，同时题目还强调数组中无重复元素，解决思路：两个边界，让左边界小于等于右边界通过比较mid与目标的值，来修改两个边界，直到找到目标值。 https://leetcode.cn/problems/binary-search/ Q：二分的边界应该如何判断？优势1：因为取mid值时已经对比了和目标值的是否匹配，所以在之后确定边界时可以加一减一操作 1234567if (guess == target) { return midOfIndex;} else if (guess &lt; target) { minOfIndex = midOfIndex + 1;} else { maxOfIndex = midOfIndex - 1;} 优势2：在while循环中设置一个小于等于，就可以在最后一次判断是否等于边界 例如{0,1,2,3,4}找4 right_index：0 left_index：4 right_index：3 left_index：4 right_index：4 left_index：4 Q：奇数和偶数数组有没有必要考虑？一个数的数组有没有必要考虑其他方法需要，上述代码不用 双指针法特点是通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。，主要问题就是两个指针的作用，一个用于寻找想要的值，一个用与确定目前索引 有两种实现一种是从两边开始，while保证left&lt;=right；从一边开始 index&lt;length 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) https://leetcode.cn/problems/remove-element/description/ https://leetcode.cn/problems/squares-of-a-sorted-array/ 1234567891011121314public class Solution2 { public int removeElement(int[] nums, int val) { int fast_Index = 0; int slow_Index = 0; while(fast_Index &lt; nums.length){ if(nums[fast_Index] != val){ nums[slow_Index] = nums[fast_Index]; slow_Index++; } fast_Index++; } return slow_Index; }} 滑动窗口滑动窗口的思想就是两个指针前边指针用于确定窗口大小，后边指针用于缩小窗口以此为一个循环。循环到底是前指针指到最后。 也可以用于解决失败超时问题 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 模拟遵循循环不变量原则，这样就可以保证，每个边循环次数固定，比如如图所示每个边循环都是2 这样写起来就很简答。","link":"/2024/01/23/PartI_Array/"},{"title":"myFirst Blog","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More infoGGGGGGG: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/21/hello-world/"}],"tags":[],"categories":[],"pages":[]}
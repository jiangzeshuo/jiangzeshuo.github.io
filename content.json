{"posts":[{"title":"","text":"Hash表一般哈希表都是用来快速判断一个元素是否出现集合里。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。Hash法的优势就是牺牲了空间去换了时间，在工业场景中也很适用。 实现理论哈希函数打比方：就是将学生姓名映射为哈希表上的索引，通过特定编码方式生成hashCode。如果hashCode超过哈希表大小（tableSize），会进行取模操作以确保映射在表内。但如果学生数量大于表大小，可能导致多个学生映射到同一索引位置。 发生冲突的解决办法： 拉链法 注意点：拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法 注意点：一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 Hash数组——242.有效的字母异位词力扣题目链接 方法理论很简单，直接定义一个数组critic全为0；判断两个数组中的元素，A数组中存在元素就++，B数组中存在的元素就–；最后判断critic数组是否全为0。为0就代表是移位词。要求只有小写字母，那么就给我们浓浓的暗示，用数组！然后这里涉及到一个要采用哪种hash的实现方法的问题一般有 数组 set （集合） 数组局限性 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。 map(映射) 数组和set来做哈希法的局限 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 每个部分还是有不同底层实现。 所以我们要根据不同的问题来选择实现的方式。然后从速度上分析如果可以用数组解决就用数组解决，因为其他hash方式需要进行hash函数的加密。 Hashset——349. 两个数组的交集力扣题目链接 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。这个思路就是建议用Set来解决问题，因为set可以不用申请连续的空间，而相比之下map是键值对的形式，可以用key存储查找的值，用value存储次数。可以方便的使用set1.contains来检测是在集合中。 123for (int i:nums2){ if (set1.contains(i)) set2.add(i);} ​ Hashmap——454.四数相加II力扣题目链接 这个题目是有四个数组并没不用考虑有重复的四个元素所以可以很直接的想到用hash map来解决。这道题目中并不需要key有序，选择std::unordered_map 效率更高！然后还需要思考map应该怎么用。第一步计算两个数相加的和，用和做键值， value 做重复的次数，然后在用两个数相加来找有多少个为0的情况。 map用来做什么 map中key和value分别表示什么 1234567891011121314151617181920class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { int sum = i + j; map.put(sum, map.getOrDefault(sum, 0) + 1); } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { res += map.getOrDefault(0 - i - j, 0); } } return res; }} 难点还是想到要用hash来解决问题 伪Hash——第15题. 三数之和力扣题目链接 这个题就，如果用hash的解决方法就不行，因为他要求不重复比如 -1，1，0和 1，-1，0就算重复，所以要直接通过两层for循环来判断的话，可能会出现重复的情况。所以现有的解发就是双指针排序，设置左右节点，最外层for循坏迭代，，right和left寻找能与之组队的数判断的原则就是看三数之和大于0还是小于0。其中的List的声明也可以学习一下， 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.length; i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] &gt; 0) { return result; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { // 去重a continue; } int left = i + 1; int right = nums.length - 1; while (right &gt; left) { int sum = nums[i] + nums[left] + nums[right]; if (sum &gt; 0) { right--; } else if (sum &lt; 0) { left++; } else { result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return result; }} Hash常用库函数ArrayListArrayList 是 Java 中常用的动态数组实现，它提供了一系列常用的方法来操作列表。以下是一些常见的 ArrayList 方法： 添加元素： add(E element): 将元素添加到列表的末尾。 add(int index, E element): 在指定位置插入元素。 1234ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;One&quot;);list.add(&quot;Two&quot;);list.add(1, &quot;Three&quot;); // 在索引1处插入元素 &quot;Three&quot; 获取元素： get(int index): 获取指定位置的元素。 1String element = list.get(1); // 获取索引1处的元素 更新元素： set(int index, E element): 替换指定位置的元素。 1list.set(1, &quot;NewElement&quot;); // 将索引1处的元素替换为 &quot;NewElement&quot; 删除元素： remove(int index): 移除指定位置的元素。 remove(Object obj): 移除指定元素。 clear(): 清空列表中的所有元素。 123list.remove(1); // 移除索引1处的元素list.remove(&quot;Two&quot;); // 移除元素 &quot;Two&quot;list.clear(); // 清空列表 查询元素： contains(Object obj): 判断列表是否包含指定元素。 indexOf(Object obj): 返回指定元素的第一个出现位置的索引。 12boolean contains = list.contains(&quot;One&quot;); // 判断列表是否包含 &quot;One&quot;int index = list.indexOf(&quot;Two&quot;); // 获取元素 &quot;Two&quot; 的索引 列表大小和判空： size(): 返回列表中的元素个数。 isEmpty(): 判断列表是否为空。 12int size = list.size(); // 获取列表大小boolean isEmpty = list.isEmpty(); // 判断列表是否为空 HashSetHashSet 是 Java 中的一个集合类，它实现了 Set 接口，底层基于哈希表实现。以下是 HashSet 常用的一些方法： 添加元素： boolean add(E e): 将指定的元素添加到集合中，如果元素已经存在，则不会重复添加，返回 true 表示添加成功，false 表示元素已存在。 123HashSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;); 移除元素： boolean remove(Object o): 从集合中移除指定的元素，如果元素存在并成功移除，则返回 true。 1set.remove(&quot;banana&quot;); 清空集合： void clear(): 移除集合中的所有元素。 1set.clear(); 判断集合是否为空： boolean isEmpty(): 判断集合是否为空。 123if (set.isEmpty()) { System.out.println(&quot;集合为空&quot;);} 获取集合大小： int size(): 获取集合中元素的数量。 1int size = set.size(); 判断元素是否存在： boolean contains(Object o): 判断集合中是否包含指定的元素。 123if (set.contains(&quot;apple&quot;)) { System.out.println(&quot;集合包含苹果&quot;);} 遍历集合： 使用迭代器或增强 for 循环来遍历集合中的元素。 123for (String element : set) { System.out.println(element);} HashMapHashMap 是 Java 中常用的集合类，它实现了 Map 接口，提供了键值对的存储和检索功能。以下是 HashMap 常用的一些方法： put(K key, V value)： 将指定的键值对存储在 HashMap 中。如果键已经存在，则替换对应的值，并返回旧值。 123HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;One&quot;, 1);map.put(&quot;Two&quot;, 2); get(Object key)： 返回指定键所映射的值，如果该键不存在，则返回 null。 1Integer value = map.get(&quot;One&quot;); containsKey(Object key)： 判断 HashMap 中是否包含指定键。 1boolean containsKey = map.containsKey(&quot;Three&quot;); containsValue(Object value)： 判断 HashMap 中是否包含指定值。 1boolean containsValue = map.containsValue(2); remove(Object key)： 从 HashMap 中移除指定键及其对应的值。 1map.remove(&quot;One&quot;); size()： 返回 HashMap 中键值对的数量。 1int size = map.size(); keySet()： 返回包含 HashMap 中所有键的集合。 1Set&lt;String&gt; keys = map.keySet(); values()： 返回包含 HashMap 中所有值的集合。 1Collection&lt;Integer&gt; values = map.values();","link":"/2024/01/25/PartIII_Hash/"},{"title":"","text":"链表 Note注意判断链表为空的情况 while 和if 一样满足条件进入循环 链表操作链表的移除特定数值有两种方法： 方法1：直接使用原来的链表来进行删除操作。需要通过while保证头节点不是移除节点。 12345678910111213141516171819202122public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) { head = head.next; } // 已经为null，提前退出 if (head == null) { return head; } // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return head;} 方法2：使用虚拟节点。这样头结点和其他节点的移除方式完全一致，少了判断头节点是不是目标节点和头节点为空的情况 123456789101112131415161718public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummy.next;} 707.设计链表https://leetcode.cn/problems/design-linked-list/description/ 思路是：创建一个虚拟头保证一致，设计链表最大的问题就是你不确定什么时候是while（temp.next！=null）还是while（temp！=null）这个逻辑就是判断里边需不需要temp.next.val如果不需要那么就可以temp，这样的话就会多迭代一次迭代一次最后的null。所有的尾端插入都一样，头部插入引入虚拟头之后一样，中间插入要记录上一个节点，删除也要记录上一个节点， 24. 两两交换链表中的节点解题思路就是画图，并且你要保证改变指针之后不影响后续的操作。然后虚拟节点的作用也是一样，不用单独考虑头节点的情况。步骤之间的顺序你一定要理清楚，如果中间改变了cur-next那原有的链接就会消失。所以最好的做法就是提前保存这些变量。你如果要调换步骤23那么temp= cur-&gt;next-&gt;next。 1234567891011121314151617181920class Solution { public ListNode swapPairs(ListNode head) { ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点 dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode cur = dumyhead; ListNode temp; // 临时节点，保存两个节点后面的节点 ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点 ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点 while (cur.next != null &amp;&amp; cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } return dumyhead.next; }} 还有一个递归的解法比较难以理解，递归的思想就是从后往前倒退。这里我直接画一个迭代的图，每一次递归的都是两个数之后即next-&gt;next，所以两次head是1，3。再一次递归会出现null并给3的递归new Node 返回null， 1234567891011121314class Solution { public ListNode swapPairs(ListNode head) { // base case 退出提交 if(head == null || head.next == null) return head; // 获取当前节点的下一个节点 ListNode next = head.next; // 进行递归 ListNode newNode = swapPairs(next.next); // 这里进行交换 next.next = head; head.next = newNode; return next; }} 链表相交面试题 02.07. 链表相交 这个暴力通过两个while循环来做很简单，但是提供一种新思路先确定长度，在根据长度，然后计算两个的差，给长的那个的current加上这个差保证统一长度，这样在一对一的比较就可以很快的找到想找的相交点了。 环形链表 https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html 找到相交点可以通过快慢指针决定。证明如下，找到成环点就是x=z所以再创建另一个节点从起点出发就行了与slow的相交点就是入还点。 总结","link":"/2024/01/25/PartII_LInked_list/"},{"title":"","text":"数组定义：数组是存放在连续内存空间上的相同类型数据的集合。 知识 C++：int类型4字节float类型在32位中是4字节 在64位中是8字节 Java的一维数组是连续的，二维数组在内存中不是连续地址空间 右移一维相当于除以2 k–是最后减去k=1 i=k–；之后i=1，k=0 题目二分法前提是数组为有序数组，同时题目还强调数组中无重复元素，解决思路：两个边界，让左边界小于等于右边界通过比较mid与目标的值，来修改两个边界，直到找到目标值。 https://leetcode.cn/problems/binary-search/ Q：二分的边界应该如何判断？优势1：因为取mid值时已经对比了和目标值的是否匹配，所以在之后确定边界时可以加一减一操作 1234567if (guess == target) { return midOfIndex;} else if (guess &lt; target) { minOfIndex = midOfIndex + 1;} else { maxOfIndex = midOfIndex - 1;} 优势2：在while循环中设置一个小于等于，就可以在最后一次判断是否等于边界 例如{0,1,2,3,4}找4 right_index：0 left_index：4 right_index：3 left_index：4 right_index：4 left_index：4 Q：奇数和偶数数组有没有必要考虑？一个数的数组有没有必要考虑其他方法需要，上述代码不用 双指针法特点是通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。，主要问题就是两个指针的作用，一个用于寻找想要的值，一个用与确定目前索引 有两种实现一种是从两边开始，while保证left&lt;=right；从一边开始 index&lt;length 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) https://leetcode.cn/problems/remove-element/description/ https://leetcode.cn/problems/squares-of-a-sorted-array/ 1234567891011121314public class Solution2 { public int removeElement(int[] nums, int val) { int fast_Index = 0; int slow_Index = 0; while(fast_Index &lt; nums.length){ if(nums[fast_Index] != val){ nums[slow_Index] = nums[fast_Index]; slow_Index++; } fast_Index++; } return slow_Index; }} 滑动窗口滑动窗口的思想就是两个指针前边指针用于确定窗口大小，后边指针用于缩小窗口以此为一个循环。循环到底是前指针指到最后。 也可以用于解决失败超时问题 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 模拟遵循循环不变量原则，这样就可以保证，每个边循环次数固定，比如如图所示每个边循环都是2 这样写起来就很简答。","link":"/2024/01/23/PartI_Array/"},{"title":"","text":"字符串 字符串也就相当于一种字符数组，它在java中有许多的库函数比如： charAt(int index): Returns the character at the specified index in the string. 12String str = &quot;Hello&quot;;char character = str.charAt(0); // Returns 'H' length(): Returns the length of the string. 12String str = &quot;Hello&quot;;int length = str.length(); // Returns 5 substring(int beginIndex, int endIndex): Returns a substring of the string starting from beginIndex up to, but not including, endIndex. 12String str = &quot;Hello&quot;;String subStr = str.substring(0, 3); // Returns &quot;Hel&quot; indexOf(String str): Returns the index of the first occurrence of the specified substring. 12String str = &quot;Hello&quot;;int index = str.indexOf(&quot;lo&quot;); // Returns 3 concat(String str): Concatenates the specified string to the end of the original string. 12String str = &quot;Hello&quot;;String newStr = str.concat(&quot; World&quot;); // Returns &quot;Hello World&quot; toLowerCase() / toUpperCase(): Converts the string to lowercase or uppercase. 123String str = &quot;Hello&quot;;String lowerStr = str.toLowerCase(); // Returns &quot;hello&quot;String upperStr = str.toUpperCase(); // Returns &quot;HELLO&quot; trim(): Removes leading and trailing whitespaces. 12String str = &quot; Hello &quot;;String trimmedStr = str.trim(); // Returns &quot;Hello&quot; replace(char oldChar, char newChar): Replaces all occurrences of oldChar with newChar. 12String str = &quot;Hello&quot;;String replacedStr = str.replace('l', 'w'); // Returns &quot;Hewwo&quot; startsWith(String prefix) / endsWith(String suffix): Checks if the string starts or ends with the specified prefix or suffix. 123String str = &quot;Hello&quot;;boolean startsWith = str.startsWith(&quot;He&quot;); // Returns trueboolean endsWith = str.endsWith(&quot;lo&quot;); // Returns true 声明和转换 1234String str = &quot;Hello&quot;;char[] charArray = str.toCharArray();char[] charArray = {'H', 'e', 'l', 'l', 'o'};String str = new String(charArray); StringBuilder 12345StringBuilder sb = new StringBuilder(); // Default initial capacity (16)StringBuilder sbWithCapacity = new StringBuilder(30); // Initial capacity set to 30StringBuilder sbWithString = new StringBuilder(&quot;Hello&quot;); // Initialize with a stringsb.append(&quot; World&quot;); // Append a stringsb.insert(5, &quot; World&quot;); // Insert a string at index 5 java中的字符串不能进行更改，所以有两种方法一种是转换为char数组，另一种是创建stringbuild对象。 解决字符串的匹配问题最暴力的方法肯定是双层for循环来判断如果没有时间限制，一般可以实现。我们采用这些方法的目的是让我可以在时间和空间上有所提升。从n2到n 反转字符串力扣题目链接 需要头尾调换整个字符串，相当于我们实现一个reverse库函数。这里我们可以使用头尾双指针很方便的实现。 123456789101112public void reverseString(char[] s) { int left = 0; int right = s.length-1; char temp = 0; for (int i=0;i&lt;s.length/2;i++){ temp = s[left]; s[left] = s[right]; s[right]=temp; left++; right--; }} 反转字符串II力扣题目链接 这个题目有自己的反转规则，所以需要根据规则进行反转，所以需要想到的是i += 2 * k，而不是ch.length/2k，因为这样做会更加方便一点，然后还有就是题目的理解了，题目要求只要有k个就翻转k个，没有k个就翻转剩下的，所以最后一步可以直接判断是不是最后所有采用最小值进行替换。 1234567891011121314151617181920class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0;i &lt; ch.length;i += 2 * k){ int start = i; // 判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1,start + k - 1); while(start &lt; end){ char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; } } return new String(ch); }} for循环的执行顺序 for(int i = 0;i &lt; ch.length;i += 2 * k){ } ①int i = 0 ②i &lt; ch.length ③i += 2 * k ④循环体 执行过程是①-&gt;②-&gt;④-&gt;③再返回到2 151.翻转字符串里的单词力扣题目链接 这个主打一个熟悉很多的解决方法可以使用 使用StringBuilder 移除多余空格，将整个字符串反转，将每个单词反转。其中if 的意义是如果单词不是空格就插入，如果单词是空格就要保证上一次不是空格。 123456789101112int start = 0;int end = s.length() - 1;while (s.charAt(start) == ' ') start++;while (s.charAt(end) == ' ') end--;StringBuilder sb = new StringBuilder();while (start &lt;= end) { char c = s.charAt(start); if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } start++;} 创建新的字符串数组，对整体数组从后往前遍历，然后设置一个指针记录右侧位置如果是不是空格就添加。两个while循环确定一个单词的左右边界==‘ ’是用来删除空格的 1234while(i&gt;=0 &amp;&amp; initialArr[i] == ' '){i--;} //跳过空格//此时i位置是边界或!=空格，先记录当前索引，之后的while用来确定单词的首字母的位置int right = i;while(i&gt;=0 &amp;&amp; initialArr[i] != ' '){i--;} 使用char数组主要体现在移除空格上，操作原理同删除数组中的元素，通过双指针实现。这里是空格的if循环放哪里，更体会到了while遍历整个单词的作用。 123456789101112int slow = 0; for (int fast = 0; fast &lt; chars.length; fast++) { //先用 fast 移除所有空格 if (chars[fast] != ' ') { //在用 slow 加空格。 除第一个单词外，单词末尾要加空格 if (slow != 0) chars[slow++] = ' '; //fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了 while (fast &lt; chars.length &amp;&amp; chars[fast] != ' ') chars[slow++] = chars[fast++]; } } 28. 实现 strStr()-KMP力扣题目链接 这个大小子串必然是可以使用暴力解决两层for循环，但是另一种很重要的技术就是KMP实现字符串匹配， KMP理论知识当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。简单的来说就是匹配串自身存在一定的关联关系，如果它前缀上了，就可以通过最长相等前后缀串切换位置。 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。前缀表体现了不匹配时的之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和后缀关系，也就是如何移动将前缀匹配串转移到后缀匹配串上。 前缀表如何计算，比如你要计算aa的前缀表就把aa的所有前缀和后缀列出看看最大能匹配上的数目 这里我以aabaa举例 aabaa的前缀子串是a,aa,aab,aaba; 后缀子串是a,aa,baa,abaa; 所以可以很明显的看出最长匹配得前后缀串是aa所以是2，这时候如果f不匹配那么整个串就可以直接从2开始匹配因为前缀aa和后缀aa完全一致。 前缀表和Next数组的关系 很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？ next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。减一并右移之后就可以和index对应上了。 以下我们以前缀表统一减一之后的next数组来做演示。 有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。 注意next数组是新前缀表（旧前缀表统一减一了）。 仅此而已 KMP的时间复杂度是O(n+m)暴力的复杂度是O(n × m)，所以KMP在字符串匹配中极大地提高了搜索的效率。 KMP具体实现关键点不是反推出上述模式，而是如何根据上述理论推出代码。 123456789101112131415161718192021222324252627282930313233343536373839// 方法一class Solution { public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i &lt; s.length(); i++){ while(j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i &lt; haystack.length(); i++){ while(j&gt;=0 &amp;&amp; haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }} 1234567891011121314151617181920212223242526272829303132class Solution { //前缀表（不减一）Java实现 public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i &lt; haystack.length(); i++) { while (j &gt; 0 &amp;&amp; needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i &lt; s.length(); i++) { while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } }} 然后大小子串直接做就可以了。 459.重复的子字符串力扣题目链接 判断一个串是不是由其子串构成，这时就体现了两个思路 1.将这个串两个连接，然后如果能在其内部找到完整的子串证明其存在船夫的子串。 2.kmp的next 数组记录的是最长公共子前缀那么 证明： 假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。 因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理） 所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。 next 数组记录的就是最长相同前后缀这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。 最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1， 数组长度为：len。 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法","link":"/2024/01/29/PartVI_String/"},{"title":"myFirst Blog","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More infoGGGGGGG: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/21/hello-world/"}],"tags":[],"categories":[],"pages":[]}
{"posts":[{"title":"","text":"二叉树二叉树注意点确定那种遍历方法（BFS，DFS）如果是深度优先遍历，确定是前序后序还是中序。确定遍历方法的哪种实现（递归，迭代） 二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。 完全二叉树完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。 所有满二叉树都是完全二叉树，但并非所有完全二叉树都是满二叉树。 二叉搜索树前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 下面这两棵树都是搜索树 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 链式存储方式就用指针， 顺序存储的方式就是用数组。 链式存储如图： 数组实现如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树的遍历方式 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法）——中左右 中序遍历（递归法，迭代法）——左中右 后序遍历（递归法，迭代法）——左右中 广度优先遍历 层次遍历（迭代法） 二叉树的定义 12345678910111213public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} java底层对象的实现方式： ArrayList： 基于动态数组实现。内部使用数组来存储元素，当数组容量不足时，会自动进行扩容。 LinkedList： 基于双向链表实现。每个节点包含数据和指向前后节点的引用，支持快速的插入和删除操作。 HashSet： 基于哈希表实现。元素存储在哈希表的桶中，通过哈希码确定元素在桶中的位置。 TreeSet： 基于红黑树实现。红黑树是一种自平衡的二叉查找树，用于保持元素的有序性。 HashMap： 基于哈希表实现。使用键的哈希码来确定键值对在哈希表中的位置。 TreeMap： 基于红黑树实现。与TreeSet类似，使用红黑树来保持键的有序性。 深度优先遍历（DFS）-递归遍历前边我们已经知道了前序遍历中序遍历已经后序遍历的顺序每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，因为递归是动态变化的，所以参数值应是随着递归会变化的参数值。并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 1public void preorder(TreeNode root, List&lt;Integer&gt; result) 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 123if (root == null) { return;} 确定单层递归的逻辑： 确定每一层递归需要处理的信息。单层需要做哪些处理，递归的位置在哪。 123result.add(root.val);preorder(root.left, result);preorder(root.right, result); 完整的递归遍历二叉树的方法 12345678910111213141516class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); }} 深度优先遍历（DFS）-迭代遍历可以看到递归遍历二叉树很简单，但是迭代遍历可能有些不同，并且这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！所以前序遍历代码还不同于中序遍历 前序遍历设置一个栈每次弹出他们的父亲节点然后添加左右孩子节点。这样看起来也是实现递归，因为同理递归的实现也是依靠栈。 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ TreeNode node = stack.pop(); result.add(node.val); if (node.right != null){ stack.push(node.right); } if (node.left != null){ stack.push(node.left); } } return result; }} 中序遍历中序遍历不同于前序主要原因是遍历节点不是处理的节点，需要创建一个cur的指针，中序遍历是左中右，所以一路向左到叶子节点。最左的叶子节点先弹出，并加入结果，然后遍历叶子的右同样为null的话证明他的节点遍历完了，此时cur==叶子节点的负节点把他加入结果遍历右节点。 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; }} 后续遍历翻转前序遍历即可 1Collections.reverse(result); 统一迭代如何让迭代风代统一呢那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。 如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { //前序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 //中序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） //后序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; }} 广度优先搜索（BFS）层序遍历递归用数组实现，传递参数时传递深度，由此可以找到，迭代是每次循环都添加新的一层到队列，秉承先进先出可以保证顺序一致。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { //checkFun01(root,0); checkFun02(root); return resList; } //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) { if (node == null) return; deep++; if (resList.size() &lt; deep) { //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); } resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); } //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } }} 226.翻转二叉树力扣题目链接 把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，所以这个就属于一个遍历的应用主要看在遍历过程中交换的位置在哪里。 DFS123456789101112131415161718192021class Solution { /** * 前后序遍历都可以 * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换） */ public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } invertTree(root.left); invertTree(root.right); swapChildren(root); return root; } private void swapChildren(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} BFS1234567891011121314151617181920212223class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) {return null;} ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;(); deque.offer(root); while (!deque.isEmpty()) { int size = deque.size(); while (size-- &gt; 0) { TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right); } } return root; } public void swap(TreeNode root) { TreeNode temp = root.left; root.left = root.right; root.right = temp; }} 101. 对称二叉树力扣题目链接 要比较的并不是左右节点而是两个子树的里侧和外侧的元素是否相等 确定终止条件 要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。 节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点） 左节点为空，右节点不为空，不对称，return false 左不为空，右为空，不对称 return false 左右都为空，对称，返回true 此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空： 左右都不为空，比较节点数值，不相同就return false 迭代法 123456789101112131415161718192021222324252627public boolean isSymmetric3(TreeNode root) { Queue&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) { TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null &amp;&amp; rightNode == null) { continue; } if (leftNode == null &amp;&amp; rightNode != null) { return false; } if (leftNode != null &amp;&amp; rightNode == null) { return false; } if (leftNode.val != rightNode.val) { return false; } // 这里顺序与使用Deque不同 deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left); } return true;} 104.二叉树的最大深度力扣题目链接 就是看看二叉树有多少层 本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）就是根向下数 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）就是从叶子向上数。 递归法递归法就是再求从叶子节点开始以贪心的方式找最大深度 12345678910111213class solution { /** * 递归法 */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; }} 迭代法迭代法是层序遍历的模板 123456789101112131415161718192021222324252627class solution { /** * 迭代法，使用层序遍历 */ public int maxDepth(TreeNode root) { if(root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode node = deque.poll(); if (node.left != null) { deque.offer(node.left); } if (node.right != null) { deque.offer(node.right); } } } return depth; }} 111.二叉树的最小深度力扣题目链接 不能直接的使用最大深度取一个最小值的情况，因为还有没有节点的情况，最小深度是指从根到叶子，并不是如果没有节点就是最小比如下图。叶子节点的特征是左右子树都为空。所以第一次判断右子树为空左子树不为空应该返回的是左子树+1的深度。 递归法123456789101112131415161718192021class Solution { /** * 递归法，相比求MaxDepth要复杂点 * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量 */ public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) { return rightDepth + 1; } if (root.right == null) { return leftDepth + 1; } // 左右结点都不为null return Math.min(leftDepth, rightDepth) + 1; }} 迭代法12345678910111213141516171819202122232425262728293031class Solution { /** * 迭代法，层序遍历 */ public int minDepth(TreeNode root) { if (root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode poll = deque.poll(); if (poll.left == null &amp;&amp; poll.right == null) { // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值 return depth; } if (poll.left != null) { deque.offer(poll.left); } if (poll.right != null) { deque.offer(poll.right); } } } return depth; }} 222.完全二叉树的节点个数力扣题目链接 通用解决方法123456789101112class Solution { // 通用递归解法 public int countNodes(TreeNode root) { if(root == null) { return 0; } int leftNum = getNodesNum(root.left); // 左 int rightNum = getNodesNum(root.right); // 右 int treeNum = leftNum + rightNum + 1; // 中 return treeNum; }} 12345678910111213141516171819class Solution { // 迭代法 public int countNodes(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int result = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size -- &gt; 0) { TreeNode cur = queue.poll(); result++; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 完全二叉树解决方法但是完全二叉树是否有更简单的求法呢，当然，就是判断他的左右子树的深度是否完全一样如果完全一样就是一个满二叉树就可以用满二叉树的计算公式 2^树深度 - 1 因为完全二叉树要求如果有节点不满那么一定在左边，所以如果深度不一样则说明不是满二叉树。 12345678910111213141516171819202122232425class Solution { /** * 针对完全二叉树的解法 * * 满二叉树的结点数为：2^depth - 1 */ public int countNodes(TreeNode root) { if (root == null) return 0; TreeNode left = root.left; TreeNode right = root.right; int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便 while (left != null) { // 求左子树深度 left = left.left; leftDepth++; } while (right != null) { // 求右子树深度 right = right.right; rightDepth++; } if (leftDepth == rightDepth) { return (2 &lt;&lt; leftDepth) - 1; // 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0 } return countNodes(root.left) + countNodes(root.right) + 1; }}","link":"/2024/02/19/Part6.1%20_Tree/"},{"title":"","text":"112. 路径总和力扣题目链接 递归可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树 确定递归函数的参数和返回类型 参数：二叉树的根节点，sum：来计算加上二叉树的一条边之和是否等于是目标和。 再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点： 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii） 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍） 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况） 106.从中序与后序遍历序列构造二叉树力扣题目链接 前序和中序，中序和后序都可以构成二叉树。 来看一下一共分几步： 第一步：如果数组大小为零的话，说明是空节点了。 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组） 第五步：切割后序数组，切成后序左数组和后序右数组 第六步：递归处理左区间和右区间 inorder前序，postorder中序 12345678910111213141516171819202122232425class Solution { Map&lt;Integer, Integer&gt; map; // 方便根据数值查找位置 public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) { // 用map保存中序序列的数值对应位置 map.put(inorder[i], i); } return findNode(inorder, 0, inorder.length, postorder,0, postorder.length); // 前闭后开 } public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) { // 参数里的范围都是前闭后开 if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) { // 不满足左闭右开，说明没有元素，返回空树 return null; } int rootIndex = map.get(postorder[postEnd - 1]); // 找到后序遍历的最后一个元素在中序遍历中的位置 TreeNode root = new TreeNode(inorder[rootIndex]); // 构造结点 int lenOfLeft = rootIndex - inBegin; // 保存中序左子树个数，用来确定后序数列的个数 root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft); root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1); return root; }} 654.最大二叉树力扣题目地址 构造树一般采用的是前序遍历 递归法的三个步骤“确定传入参数和返回类型、确定终止条件、确定单次的内部结构。 123456789101112131415161718192021222324252627class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return constructMaximumBinaryTree1(nums, 0, nums.length); } public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) { if (rightIndex - leftIndex &lt; 1) {// 没有元素了 return null; } if (rightIndex - leftIndex == 1) {// 只有一个元素 return new TreeNode(nums[leftIndex]); } int maxIndex = leftIndex;// 最大值所在位置 int maxVal = nums[maxIndex];// 最大值 for (int i = leftIndex + 1; i &lt; rightIndex; i++) { if (nums[i] &gt; maxVal){ maxVal = nums[i]; maxIndex = i; } } TreeNode root = new TreeNode(maxVal); // 根据maxIndex划分左右子树 root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex); root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex); return root; }} 617.合并二叉树力扣题目链接 因为不涉及 中节点的处理只有遍历，所以用哪种深度优先的方法都是可以的 123456789101112class Solution { // 递归 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }} 栈迭代 123456789101112131415161718192021222324252627282930313233343536class Solution { // 使用栈迭代 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) { return root2; } if (root2 == null) { return root1; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root2); stack.push(root1); while (!stack.isEmpty()) { TreeNode node1 = stack.pop(); TreeNode node2 = stack.pop(); node1.val += node2.val; if (node2.right != null &amp;&amp; node1.right != null) { stack.push(node2.right); stack.push(node1.right); } else { if (node1.right == null) { node1.right = node2.right; } } if (node2.left != null &amp;&amp; node1.left != null) { stack.push(node2.left); stack.push(node1.left); } else { if (node1.left == null) { node1.left = node2.left; } } } return root1; }} 队列迭代 1234567891011121314151617181920212223242526272829303132333435class Solution { // 使用队列迭代 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 ==null) return root1; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root1); queue.offer(root2); while (!queue.isEmpty()) { TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); // 此时两个节点一定不为空，val相加 node1.val = node1.val + node2.val; // 如果两棵树左节点都不为空，加入队列 if (node1.left != null &amp;&amp; node2.left != null) { queue.offer(node1.left); queue.offer(node2.left); } // 如果两棵树右节点都不为空，加入队列 if (node1.right != null &amp;&amp; node2.right != null) { queue.offer(node1.right); queue.offer(node2.right); } // 若node1的左节点为空，直接赋值 if (node1.left == null &amp;&amp; node2.left != null) { node1.left = node2.left; } // 若node1的右节点为空，直接赋值 if (node1.right == null &amp;&amp; node2.right != null) { node1.right = node2.right; } } return root1; }} 700.二叉搜索树中的搜索力扣题目地址 递归很简单不给出代码 迭代 1234567891011class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { while (root != NULL) { if (root-&gt;val &gt; val) root = root-&gt;left; else if (root-&gt;val &lt; val) root = root-&gt;right; else return root; } return NULL; }}; 530.二叉搜索树的最小绝对差力扣题目链接 计算的是任意两节点的最小值 最简单的方法是二叉搜索树的中序遍历是有序的我们可以计算出数组数组相邻的最小绝对差，当然也可以采用一个双指针，pre记录上一个访问的节点 123456789101112131415161718192021class Solution { TreeNode pre;// 记录上一个遍历的结点 int result = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(root==null)return 0; traversal(root); return result; } public void traversal(TreeNode root){ if(root==null)return; //左 traversal(root.left); //中 if(pre!=null){ result = Math.min(result,root.val-pre.val); } pre = root; //右 traversal(root.right); }} 这里给出迭代方法层序遍历的迭代方法和深度遍历的迭代方法不同的是，深度遍历每次while只出一个节点，层序遍历每次最外层的while都是获取len然后再次计算循环完一层 1234567891011121314151617181920212223242526272829class Solution { public int getMinimumDifference(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; int result = Integer.MAX_VALUE; if(root != null) stack.add(root); while(!stack.isEmpty()){ TreeNode curr = stack.peek(); if(curr != null){ stack.pop(); if(curr.right != null) stack.add(curr.right); stack.add(curr); stack.add(null); if(curr.left != null) stack.add(curr.left); }else{ stack.pop(); TreeNode temp = stack.pop(); if(pre != null) result = Math.min(result, temp.val - pre.val); pre = temp; } } return result; }} 501.二叉搜索树中的众数力扣题目链接 这个题目要找到出现频率最高的元素 如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。 12345678910111213141516171819202122232425262728293031323334public class Solution2 { Map&lt;Integer,Integer&gt; res = new HashMap&lt;&gt;(); public int[] findMode(TreeNode root) { int maxFrequency = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list.stream().mapToInt(Integer::intValue).toArray(); travleNode(root); for (Map.Entry&lt;Integer, Integer&gt; entry : res.entrySet()) { int number = entry.getKey(); int frequency = entry.getValue(); if (frequency &gt; maxFrequency) { // 如果找到了更大的频率，重置列表，并添加当前数字 maxFrequency = frequency; list.clear(); list.add(number); } else if (frequency == maxFrequency) { // 如果频率相同，添加当前数字到列表 list.add(number); } } int[] result = list.stream().mapToInt(Integer::intValue).toArray(); return result; } public void travleNode(TreeNode treeNode){ if(treeNode==null)return; if (treeNode.right!=null) travleNode(treeNode.right); res.put(treeNode.val, res.getOrDefault(treeNode.val, 0) + 1); if (treeNode.left!=null) travleNode(treeNode.left); }} 其次一个关键就是利用搜索二叉树的特性中序遍历是一个有序的，所以再次使用一下之前的pre和cur指针就可以判断有多少个相同了 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { ArrayList&lt;Integer&gt; resList; int maxCount; int count; TreeNode pre; public int[] findMode(TreeNode root) { resList = new ArrayList&lt;&gt;(); maxCount = 0; count = 0; pre = null; findMode1(root); int[] res = new int[resList.size()]; for (int i = 0; i &lt; resList.size(); i++) { res[i] = resList.get(i); } return res; } public void findMode1(TreeNode root) { if (root == null) { return; } findMode1(root.left); int rootValue = root.val; // 计数 if (pre == null || rootValue != pre.val) { count = 1; } else { count++; } // 更新结果以及maxCount if (count &gt; maxCount) { resList.clear(); resList.add(rootValue); maxCount = count; } else if (count == maxCount) { resList.add(rootValue); } pre = root; findMode1(root.right); }} 统一迭代法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int[] findMode(TreeNode root) { int count = 0; int maxCount = 0; TreeNode pre = null; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root != null) stack.add(root); while(!stack.isEmpty()){ TreeNode curr = stack.peek(); if(curr != null){ stack.pop(); if(curr.right != null) stack.add(curr.right); stack.add(curr); stack.add(null); if(curr.left != null) stack.add(curr.left); }else{ stack.pop(); TreeNode temp = stack.pop(); if(pre == null) count = 1; else if(pre != null &amp;&amp; pre.val == temp.val) count++; else count = 1; pre = temp; if(count == maxCount) res.add(temp.val); if(count &gt; maxCount){ maxCount = count; res.clear(); res.add(temp.val); } } } int[] result = new int[res.size()]; int i = 0; for (int x : res){ result[i] = x; i++; } return result; }} 236. 二叉树的最近公共祖先力扣题目链接 公共祖先一共有两种情况： 判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。 递归三部曲： 确定递归函数返回值以及参数 1public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { 因为需要返回最近的公共节点，所以返回值的类型是TreeNode ，TreeNode P和TreeNode q作为需要查找的参数也要放到传入参数中。这样就可以 确定终止条件 如果 root == q，或者 root == p，说明找到 q p ，则将其返回 123if (root == null || root == p || root == q) { // 递归结束条件 return root;} 确定单次循环 12345678910111213// 后序遍历TreeNode left = lowestCommonAncestor(root.left, p, q);TreeNode right = lowestCommonAncestor(root.right, p, q);if(left == null &amp;&amp; right == null) { // 若未找到节点 p 或 q return null;}else if(left == null &amp;&amp; right != null) { // 若找到一个节点 return right;}else if(left != null &amp;&amp; right == null) { // 若找到一个节点 return left;}else { // 若找到两个节点 return root;} 在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。 235. 二叉搜索树的最近公共祖先力扣题目链接 除了可以用二叉树的方法解决还可以利用二叉树的特性 1234567class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; }} 迭代法 1234567891011121314class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (true) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { root = root.left; } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { root = root.right; } else { break; } } return root; }} 701.二叉搜索树中的插入操作力扣题目链接 这个题目的插入可以随便的插入因为可以直接插入到叶子节点 别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱。 递归 12345678910111213141516171819202122class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode newRoot = root; TreeNode pre = root; while (root != null) { pre = root; if (root.val &gt; val) { root = root.left; } else if (root.val &lt; val) { root = root.right; } } if (pre.val &gt; val) { pre.left = new TreeNode(val); } else { pre.right = new TreeNode(val); } return newRoot; }} 迭代 1234567891011121314151617181920class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } TreeNode* cur = root; TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点 while (cur != NULL) { parent = cur; if (cur-&gt;val &gt; val) cur = cur-&gt;left; else cur = cur-&gt;right; } TreeNode* node = new TreeNode(val); if (val &lt; parent-&gt;val) parent-&gt;left = node;// 此时是用parent节点的进行赋值 else parent-&gt;right = node; return root; }} 450.删除二叉搜索树中的节点力扣题目链接 删除时遇到的五种情况 有以下五种情况： 第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 第五种情况有点难以理解，看下面动画： 1234567891011121314151617181920212223class Solution { public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return root; if (root.val == key) { if (root.left == null) { return root.right; } else if (root.right == null) { return root.left; } else { TreeNode cur = root.right; while (cur.left != null) { cur = cur.left; } cur.left = root.left; root = root.right; return root; } } if (root.val &gt; key) root.left = deleteNode(root.left, key); if (root.val &lt; key) root.right = deleteNode(root.right, key); return root; }} 669. 修剪二叉搜索树力扣题目链接 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。根据下图我们可以得只不能只根据一个节点不在修建区间就把他的子树完全删除。 因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。 但是有返回值，更方便，可以通过递归函数的返回值来移除节点。 1234567891011121314151617class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) { return null; } if (root.val &lt; low) { return trimBST(root.right, low, high); } if (root.val &gt; high) { return trimBST(root.left, low, high); } // root在[low,high]范围内 root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }} 迭代法 12345678910111213141516171819202122232425262728293031323334class Solution { //iteration public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null) return null; while(root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)){ if(root.val &lt; low) root = root.right; else root = root.left; } TreeNode curr = root; //deal with root's left sub-tree, and deal with the value smaller than low. while(curr != null){ while(curr.left != null &amp;&amp; curr.left.val &lt; low){ curr.left = curr.left.right; } curr = curr.left; } //go back to root; curr = root; //deal with root's righg sub-tree, and deal with the value bigger than high. while(curr != null){ while(curr.right != null &amp;&amp; curr.right.val &gt; high){ curr.right = curr.right.left; } curr = curr.right; } return root; }} #108.将有序数组转换为二叉搜索树力扣题目链接 这个题目的重点是需要转换为平衡的二叉树 因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取","link":"/2024/02/19/Part6.3_Tree/"},{"title":"","text":"110.平衡二叉树力扣题目链接 一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 求深度适合用前序遍历，而求高度适合用后序遍历。 递归法这里有个逻辑是如果子树不是平衡二叉树，那么父节点的同样不是平衡二叉树所以直接返回-1就不用继续判断了 123456789101112131415161718192021222324252627class Solution { /** * 递归法 */ public boolean isBalanced(TreeNode root) { return getHeight(root) != -1; } private int getHeight(TreeNode root) { if (root == null) { return 0; } int leftHeight = getHeight(root.left); if (leftHeight == -1) { return -1; } int rightHeight = getHeight(root.right); if (rightHeight == -1) { return -1; } // 左右子树高度差大于1，return -1表示已经不是平衡树了 if (Math.abs(leftHeight - rightHeight) &gt; 1) { return -1; } return Math.max(leftHeight, rightHeight) + 1; }} 迭代法层序遍历并不适合查找树的高度，因为你需要判断到哪个节点，所以可以采取先使用统一递归求深度，再使用迭代求一层一层的判断左右子树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { /** * 迭代法，效率较低，计算高度时会重复遍历 * 时间复杂度：O(n^2) */ public boolean isBalanced(TreeNode root) { if (root == null) { return true; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while (root!= null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } TreeNode inNode = stack.peek(); // 右结点为null或已经遍历过 if (inNode.right == null || inNode.right == pre) { // 比较左右子树的高度差，输出 if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) &gt; 1) { return false; } stack.pop(); pre = inNode; root = null;// 当前结点下，没有要遍历的结点了 } else { root = inNode.right;// 右结点还没遍历，遍历右结点 } } return true; } /** * 层序遍历，求结点的高度 */ public int getHeight(TreeNode root) { if (root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode poll = deque.poll(); if (poll.left != null) { deque.offer(poll.left); } if (poll.right != null) { deque.offer(poll.right); } } } return depth; }} 257. 二叉树的所有路径力扣题目链接 这个回溯就有很大的问题，我们知道，回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。 所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！ 递归这里回溯的位置是重点。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { /** * 递归法 */ public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; res = new ArrayList&lt;&gt;();// 存最终的结果 if (root == null) { return res; } List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// 作为结果中的路径 traversal(root, paths, res); return res; } private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) { paths.add(root.val);// 前序遍历，中 // 遇到叶子结点 if (root.left == null &amp;&amp; root.right == null) { // 输出 StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快 for (int i = 0; i &lt; paths.size() - 1; i++) { sb.append(paths.get(i)).append(&quot;-&gt;&quot;); } sb.append(paths.get(paths.size() - 1));// 记录最后一个节点 res.add(sb.toString());// 收集一个路径 return; } // 递归和回溯是同时进行，所以要放在同一个花括号里 if (root.left != null) { // 左 traversal(root.left, paths, res); paths.remove(paths.size() - 1);// 回溯 } if (root.right != null) { // 右 traversal(root.right, paths, res); paths.remove(paths.size() - 1);// 回溯 } }} 迭代法12345678910111213141516171819202122232425262728293031323334class Solution { /** * 迭代法 */ public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;Object&gt; stack = new Stack&lt;&gt;(); // 节点和路径同时入栈 stack.push(root); stack.push(root.val + &quot;&quot;); while (!stack.isEmpty()) { // 节点和路径同时出栈 String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); // 若找到叶子节点 if (node.left == null &amp;&amp; node.right == null) { result.add(path); } //右子节点不为空 if (node.right != null) { stack.push(node.right); stack.push(path + &quot;-&gt;&quot; + node.right.val); } //左子节点不为空 if (node.left != null) { stack.push(node.left); stack.push(path + &quot;-&gt;&quot; + node.left.val); } } return result; }} BFS的迭代和DFS的迭代BFS和DFS的迭代都是放入然后加入他的子节点而不同的是，DFS的迭代是使用的栈所以每弹出一个节点会接下来弹出的是他的子节点，而BFS弹出的是他们这一行的节点。 12345678910111213141516171819202122//DFS的中序迭代使用了栈class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; }} 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { checkFun02(root); return resList; } public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } }} 513.找树左下角的值力扣题目链接 重要点是区分树的左下角并不是最左边的节点，而是最深长度那一行的最左的节点，所以这个题目用层序遍历来做十分的简答，但是若果用递归的话就要分两步1.求出是否是最深长度，2.求出最左的节点。 回溯方法关联104.二叉树的最大深度 递归递归三部曲： 确定递归函数的参数和返回值 参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。 1private void traversal(TreeNode root, int depth) 确定终止条件 当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。 确定单层递归的逻辑 1234567891011121314151617181920212223242526272829303132private void traversal(TreeNode root, int depth) { if (root.left == null &amp;&amp; root.right == null) { if (depth &gt; maxDepth) { maxDepth = depth; result = root.val; } return; } if (root.left != null) { depth++; traversal(root.left, depth ); depth--; } if (root.right != null) { depth++; traversal(root.right, depth ); depth--; }}public int findBottomLeftValue(TreeNode root) { traversal(root, 0); return result;}// Assuming TreeNode is defined as follows:// class TreeNode {// int val;// TreeNode left;// TreeNode right;// TreeNode(int x) { val = x; }// } 迭代层序 12345678910111213141516171819public class Solution { public int findBottomLeftValue(TreeNode root) { Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(root); TreeNode out = new TreeNode() ; while (!queue.isEmpty()){ int len = queue.size(); out = queue.peek(); while (len&gt;0){ TreeNode temp = queue.poll(); if (temp.left!=null) queue.add(temp.left); if (temp.right!=null) queue.add(temp.right); len--; } } return out.val; }}","link":"/2024/02/19/Part6.2_Tree/"},{"title":"","text":"定义回溯法也可以叫做回溯搜索法，它是一种搜索的方式。在二叉树系列中，我们已经不止一次，提到了回溯，回溯是递归的副产品，只要有递归就会有回溯。虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案只不过进行了剪枝。 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯法模板回溯三部曲。 回溯函数模板返回值以及参数 回溯算法中函数返回值一般为void。因为一般会把需要返回的值放到参数或者类中，当然也有需要返回值的用于提前终止。 1void backtracking(参数) 回溯函数终止条件 1234if (终止条件) { 存放结果; return;} 回溯搜索的遍历过程 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。所以主要是for循环式横向遍历，递归是纵向遍历。 12345for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果} 第77题. 组合力扣题目链接 题目要求在1-n之间返回k个数的组合，所以这时候就可以使用回溯， 将问题抽象成如图所示，因为是组合所以for循环式每取一个数少一个数 回溯法三部曲定义全局并确定返回值以及参数，这里的startIndex用来记录本层递归的开始位置，这样就不会重复选择同一个数如图 123vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合vector&lt;int&gt; path; // 用来存放符合条件单一结果void backtracking(int n, int k, int startIndex) 终止条件 1234if (path.size() == k) { result.push_back(path); return;} 单次循环 123456for (int i = startIndex; i &lt;= n; i++) { // 控制树的横向遍历 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始 path.pop_back(); // 回溯，撤销处理的节点} 整体代码 1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合 vector&lt;int&gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 } }public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; }}; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 时间复杂度分析：对于回溯算法我们需要 我们需要估计的是回溯法实际产生的节点数目，以此计算回溯法的时间复杂度。 我们的目的是要1-n之间返回k个数的组合，所以算法的时间复杂度主要取决于backtracking函数的执行次数。 2^n 代表了每个元素在每个组合中有两种可能性：要么出现，要么不出现；n 代表了在生成每一种组合时，你最多需要做 n 次操作来构建这个组合，这是由于组合的大小最多为 n。在最坏情况下，即每个候选数都被选择了，我们需要对候选数集合进行完整的遍历。这样，对于每一层递归，我们都需要遍历整个候选数集合， 因为每一个元素的状态无外乎取与不取，一共2^n种状态，每种状态都需要 o(n) 的构造时间，最终时间复杂度为 O(n * 2^n) 。 回溯虽然不是一个高效的方法，但是如果使用暴力那会更加复杂，比如5个数中取随机三个就需要三层的for循，可能更加难写。 当然还有一种剪枝操作，就是当如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 1for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) { // 优化的地方 k - path.size()还需要多少个数，n减去还需要的数不足以组成组合的话就通过for提前结束了，提前结束在了对剩余元素个数的判断。 216.组合总和III力扣题目链接 要求 不存在重复的数字，就是看1-9里有多少个组合 1234567891011121314151617181920212223242526272829class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; // 存放结果集 vector&lt;int&gt; path; // 符合条件的结果 void backtracking(int targetSum, int k, int sum, int startIndex) { if (sum &gt; targetSum) { // 剪枝操作 return; } if (path.size() == k) { if (sum == targetSum) result.push_back(path); return; // 如果path.size() == k 但sum != targetSum 直接返回 } for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) { // 剪枝 sum += i; // 处理 path.push_back(i); // 处理 backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex sum -= i; // 回溯 path.pop_back(); // 回溯 } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { result.clear(); // 可以不加 path.clear(); // 可以不加 backtracking(n, k, 0, 1); return result; }}; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 93.复原IP地址力扣题目链接 其实只要意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {private: vector&lt;string&gt; result;// 记录结果 // startIndex: 搜索的起始位置，pointNum:添加逗点的数量 void backtracking(string&amp; s, int startIndex, int pointNum) { if (pointNum == 3) { // 逗点数量为3时，分隔结束 // 判断第四段子字符串是否合法，如果合法就放进result中 if (isValid(s, startIndex, s.size() - 1)) { result.push_back(s); } return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法 s.insert(s.begin() + i + 1 , '.'); // 在i的后面插入一个逗点 pointNum++; backtracking(s, i + 2, pointNum); // 插入逗点之后下一个子串的起始位置为i+2 pointNum--; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉逗点 } else break; // 不合法，直接结束本层循环 } } // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法 bool isValid(const string&amp; s, int start, int end) { if (start &gt; end) { return false; } if (s[start] == '0' &amp;&amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i &lt;= end; i++) { if (s[i] &gt; '9' || s[i] &lt; '0') { // 遇到非数字字符不合法 return false; } num = num * 10 + (s[i] - '0'); if (num &gt; 255) { // 如果大于255了不合法 return false; } } return true; }public: vector&lt;string&gt; restoreIpAddresses(string s) { result.clear(); if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了 backtracking(s, 0, 0); return result; }}; 39. 组合总和力扣题目链接 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。 123456789101112131415161718192021222324252627282930// 版本一class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex) { if (sum &gt; target) { return; } if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i &lt; candidates.size(); i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i); // 不用i+1了，表示可以重复读取当前的数 sum -= candidates[i]; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { result.clear(); path.clear(); backtracking(candidates, target, 0, 0); return result; }}; 主要的点还是在单次循环上。 40.组合总和II力扣题目链接 这道题目和39.组合总和 (opens new window)如下区别： 本题candidates 中的每个数字在每个组合中只能使用一次。 本题数组candidates的元素是有重复的，而39.组合总和 (opens new window)是无重复元素的数组candidates 第二点是关键，比如我要怎么确定（1,2,3,2）选择的2是哪个2，并且要保证结果中不能出现两个（1,2） 都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。 Q：我们是要同一树层上使用过，还是同一树枝上使用过呢？ A：回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。 单独介绍一下单层循环逻辑：**如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。 此时for循环里就应该做continue的操作。 我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下： used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 used[i - 1] == false，说明同一树层candidates[i - 1]使用过 123456789101112131415for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) { continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次 used[i] = false; sum -= candidates[i]; path.pop_back();} 整体代码 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) { if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) { continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次 used[i] = false; sum -= candidates[i]; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; used(candidates.size(), false); path.clear(); result.clear(); // 首先把给candidates排序，让其相同的元素都挨在一起。 sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0, 0, used); return result; }}; 131.分割回文串力扣题目链接 这个题目的关键是要把分割回文串变为一种组合问题并将切割问题，也可以抽象为一棵树形结构，如图： 1234567891011121314151617181920212223242526272829303132333435363738class Solution {private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 void backtracking (const string&amp; s, int startIndex) { // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) { result.push_back(path); return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); } else { // 不是回文，跳过 continue; } backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 } } bool isPalindrome(const string&amp; s, int start, int end) { for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) { return false; } } return true; }public: vector&lt;vector&lt;string&gt;&gt; partition(string s) { result.clear(); path.clear(); backtracking(s, 0); return result; }};","link":"/2024/02/19/Part7.1backtracking/"},{"title":"哈希表","text":"一般哈希表都是用来快速判断一个元素是否出现集合里。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。Hash法的优势就是牺牲了空间去换了时间，在工业场景中也很适用。 实现理论哈希函数打比方：就是将学生姓名映射为哈希表上的索引，通过特定编码方式生成hashCode。如果hashCode超过哈希表大小（tableSize），会进行取模操作以确保映射在表内。但如果学生数量大于表大小，可能导致多个学生映射到同一索引位置。 发生冲突的解决办法： 拉链法 注意点：拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法 注意点：一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 Hash数组——242.有效的字母异位词力扣题目链接 方法理论很简单，直接定义一个数组critic全为0；判断两个数组中的元素，A数组中存在元素就++，B数组中存在的元素就–；最后判断critic数组是否全为0。为0就代表是移位词。要求只有小写字母，那么就给我们浓浓的暗示，用数组！然后这里涉及到一个要采用哪种hash的实现方法的问题一般有 数组 set （集合） 数组局限性 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。 map(映射) 数组和set来做哈希法的局限 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 每个部分还是有不同底层实现。 所以我们要根据不同的问题来选择实现的方式。然后从速度上分析如果可以用数组解决就用数组解决，因为其他hash方式需要进行hash函数的加密。 Hashset——349. 两个数组的交集力扣题目链接 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。这个思路就是建议用Set来解决问题，因为set可以不用申请连续的空间，而相比之下map是键值对的形式，可以用key存储查找的值，用value存储次数。可以方便的使用set1.contains来检测是在集合中。 123for (int i:nums2){ if (set1.contains(i)) set2.add(i);} ​ Hashmap——454.四数相加II力扣题目链接 这个题目是有四个数组并没不用考虑有重复的四个元素所以可以很直接的想到用hash map来解决。这道题目中并不需要key有序，选择std::unordered_map 效率更高！然后还需要思考map应该怎么用。第一步计算两个数相加的和，用和做键值， value 做重复的次数，然后在用两个数相加来找有多少个为0的情况。 map用来做什么 map中key和value分别表示什么 1234567891011121314151617181920class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { int sum = i + j; map.put(sum, map.getOrDefault(sum, 0) + 1); } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { res += map.getOrDefault(0 - i - j, 0); } } return res; }} 难点还是想到要用hash来解决问题 伪Hash——第15题. 三数之和力扣题目链接 这个题就，如果用hash的解决方法就不行，因为他要求不重复比如 -1，1，0和 1，-1，0就算重复，所以要直接通过两层for循环来判断的话，可能会出现重复的情况。所以现有的解发就是双指针排序，设置左右节点，最外层for循坏迭代，，right和left寻找能与之组队的数判断的原则就是看三数之和大于0还是小于0。其中的List的声明也可以学习一下， 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.length; i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] &gt; 0) { return result; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { // 去重a continue; } int left = i + 1; int right = nums.length - 1; while (right &gt; left) { int sum = nums[i] + nums[left] + nums[right]; if (sum &gt; 0) { right--; } else if (sum &lt; 0) { left++; } else { result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return result; }} Hash常用库函数ArrayListArrayList 是 Java 中常用的动态数组实现，它提供了一系列常用的方法来操作列表。以下是一些常见的 ArrayList 方法： 添加元素： add(E element): 将元素添加到列表的末尾。 add(int index, E element): 在指定位置插入元素。 1234ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;One&quot;);list.add(&quot;Two&quot;);list.add(1, &quot;Three&quot;); // 在索引1处插入元素 &quot;Three&quot; 获取元素： get(int index): 获取指定位置的元素。 1String element = list.get(1); // 获取索引1处的元素 更新元素： set(int index, E element): 替换指定位置的元素。 1list.set(1, &quot;NewElement&quot;); // 将索引1处的元素替换为 &quot;NewElement&quot; 删除元素： remove(int index): 移除指定位置的元素。 remove(Object obj): 移除指定元素。 clear(): 清空列表中的所有元素。 123list.remove(1); // 移除索引1处的元素list.remove(&quot;Two&quot;); // 移除元素 &quot;Two&quot;list.clear(); // 清空列表 查询元素： contains(Object obj): 判断列表是否包含指定元素。 indexOf(Object obj): 返回指定元素的第一个出现位置的索引。 12boolean contains = list.contains(&quot;One&quot;); // 判断列表是否包含 &quot;One&quot;int index = list.indexOf(&quot;Two&quot;); // 获取元素 &quot;Two&quot; 的索引 列表大小和判空： size(): 返回列表中的元素个数。 isEmpty(): 判断列表是否为空。 12int size = list.size(); // 获取列表大小boolean isEmpty = list.isEmpty(); // 判断列表是否为空 HashSetHashSet 是 Java 中的一个集合类，它实现了 Set 接口，底层基于哈希表实现。以下是 HashSet 常用的一些方法： 添加元素： boolean add(E e): 将指定的元素添加到集合中，如果元素已经存在，则不会重复添加，返回 true 表示添加成功，false 表示元素已存在。 123HashSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;); 移除元素： boolean remove(Object o): 从集合中移除指定的元素，如果元素存在并成功移除，则返回 true。 1set.remove(&quot;banana&quot;); 清空集合： void clear(): 移除集合中的所有元素。 1set.clear(); 判断集合是否为空： boolean isEmpty(): 判断集合是否为空。 123if (set.isEmpty()) { System.out.println(&quot;集合为空&quot;);} 获取集合大小： int size(): 获取集合中元素的数量。 1int size = set.size(); 判断元素是否存在： boolean contains(Object o): 判断集合中是否包含指定的元素。 123if (set.contains(&quot;apple&quot;)) { System.out.println(&quot;集合包含苹果&quot;);} 遍历集合： 使用迭代器或增强 for 循环来遍历集合中的元素。 123for (String element : set) { System.out.println(element);} HashMapHashMap 是 Java 中常用的集合类，它实现了 Map 接口，提供了键值对的存储和检索功能。以下是 HashMap 常用的一些方法： put(K key, V value)： 将指定的键值对存储在 HashMap 中。如果键已经存在，则替换对应的值，并返回旧值。 123HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;One&quot;, 1);map.put(&quot;Two&quot;, 2); get(Object key)： 返回指定键所映射的值，如果该键不存在，则返回 null。 1Integer value = map.get(&quot;One&quot;); containsKey(Object key)： 判断 HashMap 中是否包含指定键。 1boolean containsKey = map.containsKey(&quot;Three&quot;); containsValue(Object value)： 判断 HashMap 中是否包含指定值。 1boolean containsValue = map.containsValue(2); remove(Object key)： 从 HashMap 中移除指定键及其对应的值。 1map.remove(&quot;One&quot;); size()： 返回 HashMap 中键值对的数量。 1int size = map.size(); keySet()： 返回包含 HashMap 中所有键的集合。 1Set&lt;String&gt; keys = map.keySet(); values()： 返回包含 HashMap 中所有值的集合。 1Collection&lt;Integer&gt; values = map.values();","link":"/2024/01/25/PartIII_Hash/"},{"title":"","text":"93.复原IP地址力扣题目链接 根据题目的意思是割3刀使所有部分是一个正确的ip地址所以除了判断有效的函数不同其他基本一致，但是终止条件式切3刀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {private: vector&lt;string&gt; result;// 记录结果 // startIndex: 搜索的起始位置，pointNum:添加逗点的数量 void backtracking(string&amp; s, int startIndex, int pointNum) { if (pointNum == 3) { // 逗点数量为3时，分隔结束 // 判断第四段子字符串是否合法，如果合法就放进result中 if (isValid(s, startIndex, s.size() - 1)) { result.push_back(s); } return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法 s.insert(s.begin() + i + 1 , '.'); // 在i的后面插入一个逗点 pointNum++; backtracking(s, i + 2, pointNum); // 插入逗点之后下一个子串的起始位置为i+2 pointNum--; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉逗点 } else break; // 不合法，直接结束本层循环 } } // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法 bool isValid(const string&amp; s, int start, int end) { if (start &gt; end) { return false; } if (s[start] == '0' &amp;&amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i &lt;= end; i++) { if (s[i] &gt; '9' || s[i] &lt; '0') { // 遇到非数字字符不合法 return false; } num = num * 10 + (s[i] - '0'); if (num &gt; 255) { // 如果大于255了不合法 return false; } } return true; }public: vector&lt;string&gt; restoreIpAddresses(string s) { result.clear(); if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了 backtracking(s, 0, 0); return result; }}; 时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。 注意这个时间复杂度，这是递归方法的时间复杂度计算，就是针对于每个数字可能得情况我们进行遍历所以取得 78.子集力扣题目链接 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 你看对弈每一个节点都是子集并不是只存储最后的结果 1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) { result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex &gt;= nums.size()) { // 终止条件可以不加 return; } for (int i = startIndex; i &lt; nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }}; 90.子集II力扣题目链接 在78题的基础上利用use去重 12345678910111213141516171819202122232425262728293031class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex, vector&lt;bool&gt;&amp; used) { result.push_back(path); for (int i = startIndex; i &lt; nums.size(); i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 而我们要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) { continue; } path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); sort(nums.begin(), nums.end()); // 去重需要排序 backtracking(nums, 0, used); return result; }}; 当然也可以使用set来去除重复数据。 491.递增子序列力扣题目链接 这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。 这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的90.子集II (opens new window)。 就是因为太像了，更要注意差别所在，要不就掉坑里了！ 在90.子集II (opens new window)中我们是通过排序，再加一个标记数组来达到去重的目的。 而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。 所以不能使用之前的去重逻辑！ 123456789101112131415161718192021222324252627282930// 版本一class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) { if (path.size() &gt; 1) { result.push_back(path); // 注意这里不要加return，要取树上的节点 } unordered_set&lt;int&gt; uset; // 使用set对本层元素进行去重 for (int i = startIndex; i &lt; nums.size(); i++) { if ((!path.empty() &amp;&amp; nums[i] &lt; path.back()) || uset.find(nums[i]) != uset.end()) { continue; } uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了 path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }}; 46.全排列力扣题目链接 因为是排列问题所以也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方所以我们也就不需要使用startIndex 但是但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示: 当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; }}; 47.全排列 II力扣题目链接 这道题目和46.全排列 (opens new window)的区别在与给定一个可包含重复数字的序列，要返回所有不重复的全排列。 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { // used[i - 1] == true，说明同一树枝nums[i - 1]使用过 // used[i - 1] == false，说明同一树层nums[i - 1]使用过 // 如果同一树层nums[i - 1]使用过则直接跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) { continue; } if (used[i] == false) { used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } }public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); // 排序 vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; }};","link":"/2024/02/19/Part7.2backtracking/"},{"title":"链表","text":"Note注意判断链表为空的情况 while 和if 一样满足条件进入循环 链表操作链表的移除特定数值有两种方法： 方法1：直接使用原来的链表来进行删除操作。需要通过while保证头节点不是移除节点。 12345678910111213141516171819202122public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) { head = head.next; } // 已经为null，提前退出 if (head == null) { return head; } // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return head;} 方法2：使用虚拟节点。这样头结点和其他节点的移除方式完全一致，少了判断头节点是不是目标节点和头节点为空的情况 123456789101112131415161718public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummy.next;} 707.设计链表https://leetcode.cn/problems/design-linked-list/description/ 思路是：创建一个虚拟头保证一致，设计链表最大的问题就是你不确定什么时候是while（temp.next！=null）还是while（temp！=null）这个逻辑就是判断里边需不需要temp.next.val如果不需要那么就可以temp，这样的话就会多迭代一次迭代一次最后的null。所有的尾端插入都一样，头部插入引入虚拟头之后一样，中间插入要记录上一个节点，删除也要记录上一个节点， 24. 两两交换链表中的节点解题思路就是画图，并且你要保证改变指针之后不影响后续的操作。然后虚拟节点的作用也是一样，不用单独考虑头节点的情况。步骤之间的顺序你一定要理清楚，如果中间改变了cur-next那原有的链接就会消失。所以最好的做法就是提前保存这些变量。你如果要调换步骤23那么temp= cur-&gt;next-&gt;next。 1234567891011121314151617181920class Solution { public ListNode swapPairs(ListNode head) { ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点 dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode cur = dumyhead; ListNode temp; // 临时节点，保存两个节点后面的节点 ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点 ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点 while (cur.next != null &amp;&amp; cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } return dumyhead.next; }} 还有一个递归的解法比较难以理解，递归的思想就是从后往前倒退。这里我直接画一个迭代的图，每一次递归的都是两个数之后即next-&gt;next，所以两次head是1，3。再一次递归会出现null并给3的递归new Node 返回null， 1234567891011121314class Solution { public ListNode swapPairs(ListNode head) { // base case 退出提交 if(head == null || head.next == null) return head; // 获取当前节点的下一个节点 ListNode next = head.next; // 进行递归 ListNode newNode = swapPairs(next.next); // 这里进行交换 next.next = head; head.next = newNode; return next; }} 链表相交面试题 02.07. 链表相交 这个暴力通过两个while循环来做很简单，但是提供一种新思路先确定长度，在根据长度，然后计算两个的差，给长的那个的current加上这个差保证统一长度，这样在一对一的比较就可以很快的找到想找的相交点了。 环形链表 https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html 找到相交点可以通过快慢指针决定。证明如下，找到成环点就是x=z所以再创建另一个节点从起点出发就行了与slow的相交点就是入还点。 总结","link":"/2024/01/25/PartII_LInked_list/"},{"title":"数组","text":"定义：数组是存放在连续内存空间上的相同类型数据的集合。 知识 C++：int类型4字节float类型在32位中是4字节 在64位中是8字节 Java的一维数组是连续的，二维数组在内存中不是连续地址空间 右移一维相当于除以2 k–是最后减去k=1 i=k–；之后i=1，k=0 题目二分法前提是数组为有序数组，同时题目还强调数组中无重复元素，解决思路：两个边界，让左边界小于等于右边界通过比较mid与目标的值，来修改两个边界，直到找到目标值。 https://leetcode.cn/problems/binary-search/ Q：二分的边界应该如何判断？优势1：因为取mid值时已经对比了和目标值的是否匹配，所以在之后确定边界时可以加一减一操作 1234567if (guess == target) { return midOfIndex;} else if (guess &lt; target) { minOfIndex = midOfIndex + 1;} else { maxOfIndex = midOfIndex - 1;} 优势2：在while循环中设置一个小于等于，就可以在最后一次判断是否等于边界 例如{0,1,2,3,4}找4 right_index：0 left_index：4 right_index：3 left_index：4 right_index：4 left_index：4 Q：奇数和偶数数组有没有必要考虑？一个数的数组有没有必要考虑其他方法需要，上述代码不用 双指针法特点是通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。，主要问题就是两个指针的作用，一个用于寻找想要的值，一个用与确定目前索引 有两种实现一种是从两边开始，while保证left&lt;=right；从一边开始 index&lt;length 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) https://leetcode.cn/problems/remove-element/description/ https://leetcode.cn/problems/squares-of-a-sorted-array/ 1234567891011121314public class Solution2 { public int removeElement(int[] nums, int val) { int fast_Index = 0; int slow_Index = 0; while(fast_Index &lt; nums.length){ if(nums[fast_Index] != val){ nums[slow_Index] = nums[fast_Index]; slow_Index++; } fast_Index++; } return slow_Index; }} 滑动窗口滑动窗口的思想就是两个指针前边指针用于确定窗口大小，后边指针用于缩小窗口以此为一个循环。循环到底是前指针指到最后。 也可以用于解决失败超时问题 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 模拟遵循循环不变量原则，这样就可以保证，每个边循环次数固定，比如如图所示每个边循环都是2 这样写起来就很简答。","link":"/2024/01/23/PartI_Array/"},{"title":"栈与队列","text":"栈与队列是常用的数据结构，其中栈提供先进后出，队列提供先进先出，这样的数据结构可以解决一些需要顺序解决的问题。在java中实现底层是不一样的原因是栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 在Java中，队列和栈是两种常见的数据结构，它们分别用于不同的场景，而它们的实现通常基于以下几种容器： 队列（Queue）的容器实现： LinkedList： java.util.LinkedList 是一个双向链表，支持在两端进行元素的添加和删除，因此适用于实现队列。 可以使用 offer() 在队尾添加元素，使用 poll() 移除并返回队头元素。 1234Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();queue.offer(1);queue.offer(2);int frontElement = queue.poll(); ArrayDeque： java.util.ArrayDeque 是一个基于数组的双端队列，同样适用于实现队列。 可以使用 offer() 在队尾添加元素，使用 poll() 移除并返回队头元素。 1234Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();queue.offer(1);queue.offer(2);int frontElement = queue.poll(); PriorityQueue： java.util.PriorityQueue 是一个基于优先级堆的无界优先级队列，可以实现具有优先级的队列。 元素按照优先级顺序被移除。 1234Queue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();priorityQueue.offer(3);priorityQueue.offer(1);int highestPriority = priorityQueue.poll(); 栈（Stack）的容器实现： LinkedList： java.util.LinkedList 可以用作栈的实现，因为它是一个双向链表，支持在两端进行元素的添加和删除。 可以使用 push() 入栈，pop() 出栈，peek() 查看栈顶元素。 1234Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();stack.push(1);stack.push(2);int topElement = stack.pop(); ArrayDeque： java.util.ArrayDeque 同样可以用作栈的实现，支持在两端进行元素的添加和删除。 可以使用 push() 入栈，pop() 出栈，peek() 查看栈顶元素。 1234Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();stack.push(1);stack.push(2);int topElement = stack.pop(); 注意：在现代Java编程中，推荐使用 Deque 接口来代替 Stack 类，因为 Deque 提供了更灵活的双端队列操作，并且 Stack 类是一个遗留类。 232.用栈实现队列力扣题目链接 如果要用栈实现队列，那么就要保证先进先出，所以就必须用两个栈，一个负责弹出到底部一个负载接收其他变量。 123456789101112stackIn = new Stack&lt;&gt;(); // 负责进栈stackOut = new Stack&lt;&gt;(); // 负责出栈 public int pop() { dumpstackIn(); return stackOut.pop(); } private void dumpstackIn(){ if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()){ stackOut.push(stackIn.pop()); } } 225. 用队列实现栈力扣题目链接 这个有多种实现思路，可以在放入队列时就保证出栈顺序。也可以在出队列时出最后一个，还可以使用一个队列循环size长度然后把出队的元素重新入队，直到找到最后一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /** 思路1：两个队列在放入时保证出队顺序 */class MyStack { Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列 Queue&lt;Integer&gt; queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue&lt;Integer&gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** 思路2：两个队列在放入时保证出队顺序 */ // Deque 接口继承了 Queue 接口 // 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst Deque&lt;Integer&gt; que1; // 和栈中保持一样元素的队列 Deque&lt;Integer&gt; que2; // 辅助队列 public int pop() { int size = que1.size(); size--; // 将 que1 导入 que2 ，但留下最后一个值 while (size-- &gt; 0) { que2.addLast(que1.peekFirst()); que1.pollFirst(); } int res = que1.pollFirst(); // 将 que2 对象的引用赋给了 que1 ，此时 que1，que2 指向同一个队列 que1 = que2; // 如果直接操作 que2，que1 也会受到影响，所以为 que2 分配一个新的空间 que2 = new ArrayDeque&lt;&gt;(); return res; } /** 思路3：一个队列，一边放一边添加 */ class MyStack { // Deque 接口继承了 Queue 接口 // 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst Deque&lt;Integer&gt; que1; public int pop() { int size = que1.size(); size--; // 将 que1 导入 que2 ，但留下最后一个值 while (size-- &gt; 0) { que1.addLast(que1.peekFirst()); que1.pollFirst(); } int res = que1.pollFirst(); return res; } 20. 有效的括号力扣题目链接 两种情况比较遇见左括号就入栈右括号和遇到左括号就入栈左括号对比，可以看到如果采用遇到左括号就入栈右括号就不用进行匹配了可以直接相等比较。 123456789101112131415for (int i = 0; i &lt; s.length(); i++) { char currentChar = s.charAt(i); if (currentChar == '(' || currentChar == '[' || currentChar == '{') { stack.push(currentChar); } else if (currentChar == ')' || currentChar == ']' || currentChar == '}') { if (stack.isEmpty() || (currentChar == ')' &amp;&amp; stack.peek() != '(') || (currentChar == ']' &amp;&amp; stack.peek() != '[') || (currentChar == '}' &amp;&amp; stack.peek() != '{')) { return false; // Mismatched brackets } stack.pop(); // Matching pair found, remove the opening bracket }} 123456789101112131415161718 for (int i = 0; i &lt; s.length(); i++) { ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == '(') { deque.push(')'); }else if (ch == '{') { deque.push('}'); }else if (ch == '[') { deque.push(']'); } else if (deque.isEmpty() || deque.peek() != ch) { return false; }else {//如果是右括号判断是否和栈顶元素匹配 deque.pop(); } } //最后判断栈中元素是否匹配 return deque.isEmpty();} 1047. 删除字符串中的所有相邻重复项力扣题目链接 很简单的逻辑如果，某个元素和栈顶元素一样就出栈栈顶，不一样就入栈。这里简单介绍三个方法 方法1：列表链接结构可能是最糟糕的结构，每个元素上都有缓存未命中而进行迭代。最重要的是，它们消耗更多的内存。 如果您需要添加/删除两端，ArrayDeque 明显优于 LinkedList。对于循环队列来说，随机访问每个元素也是 O(1)。 链表唯一更好的操作是在迭代期间删除当前元素 12345678910111213141516171819202122class Solution { public String removeDuplicates(String S) { //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点 //参考： ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;(); char ch; for (int i = 0; i &lt; S.length(); i++) { ch = S.charAt(i); if (deque.isEmpty() || deque.peek() != ch) { deque.push(ch); } else { deque.pop(); } } String str = &quot;&quot;; //剩余的元素即为不重复的元素 while (!deque.isEmpty()) { str = deque.pop() + str; } return str; }} 方法2双指针快指针指向需要匹配元素 ，慢指针指向已经匹配元素，其中的slow–和slow++是灵魂，slow–代表如果匹配就删除数组中的slow，slow++不匹配就向前移动。 12345678910111213141516171819lass Solution { public String removeDuplicates(String s) { char[] ch = s.toCharArray(); int fast = 0; int slow = 0; while(fast &lt; s.length()){ // 直接用fast指针覆盖slow指针的值 ch[slow] = ch[fast]; // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了 if(slow &gt; 0 &amp;&amp; ch[slow] == ch[slow - 1]){ slow--; }else{ slow++; } fast++; } return new String(ch,0,slow); }} 239. 滑动窗口最大值力扣题目链接 需要返回滑动窗口的最大值，这可以使用一个单调队列 其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//解法一//自定义数组class MyQueue { Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出 //同时判断队列当前是否为空 void poll(int val) { if (!deque.isEmpty() &amp;&amp; val == deque.peek()) { deque.poll(); } } //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出 //保证队列元素单调递减 //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2 void add(int val) { while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) { deque.removeLast(); } deque.add(val); } //队列队顶元素始终为最大值 int peek() { return deque.peek(); }}class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1) { return nums; } int len = nums.length - k + 1; //存放结果元素的数组 int[] res = new int[len]; int num = 0; //自定义队列 MyQueue myQueue = new MyQueue(); //先将前k的元素放入队列 for (int i = 0; i &lt; k; i++) { myQueue.add(nums[i]); } res[num++] = myQueue.peek(); for (int i = k; i &lt; nums.length; i++) { //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列 myQueue.poll(nums[i - k]); //滑动窗口加入最后面的元素 myQueue.add(nums[i]); //记录对应的最大值 res[num++] = myQueue.peek(); } return res; }} 347.前 K 个高频元素（review）力扣题目链接 什么是优先级队列呢？ 其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。 所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。 所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， * 从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点 * */class Solution { //解法1：基于大顶堆实现 public int[] topKFrequent1(int[] nums, int k) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆) PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair2[1]-pair1[1]); for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//大顶堆需要对所有元素进行排序 pq.add(new int[]{entry.getKey(),entry.getValue()}); } int[] ans = new int[k]; for(int i=0;i&lt;k;i++){//依次从队头弹出k个,就是出现频率前k高的元素 ans[i] = pq.poll()[0]; } return ans; } //解法2：基于小顶堆实现 public int[] topKFrequent2(int[] nums, int k) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆) PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1,pair2)-&gt;pair1[1]-pair2[1]); for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//小顶堆只需要维持k个元素有序 if(pq.size()&lt;k){//小顶堆元素个数小于k个时直接加 pq.add(new int[]{entry.getKey(),entry.getValue()}); }else{ if(entry.getValue()&gt;pq.peek()[1]){//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个) pq.poll();//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了 pq.add(new int[]{entry.getKey(),entry.getValue()}); } } } int[] ans = new int[k]; for(int i=k-1;i&gt;=0;i--){//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多 ans[i] = pq.poll()[0]; } return ans; }}","link":"/2024/01/31/PartV_Stack/"},{"title":"字符串","text":"字符串也就相当于一种字符数组，它在java中有许多的库函数比如： charAt(int index): Returns the character at the specified index in the string. 12String str = &quot;Hello&quot;;char character = str.charAt(0); // Returns 'H' length(): Returns the length of the string. 12String str = &quot;Hello&quot;;int length = str.length(); // Returns 5 substring(int beginIndex, int endIndex): Returns a substring of the string starting from beginIndex up to, but not including, endIndex. 12String str = &quot;Hello&quot;;String subStr = str.substring(0, 3); // Returns &quot;Hel&quot; indexOf(String str): Returns the index of the first occurrence of the specified substring. 12String str = &quot;Hello&quot;;int index = str.indexOf(&quot;lo&quot;); // Returns 3 concat(String str): Concatenates the specified string to the end of the original string. 12String str = &quot;Hello&quot;;String newStr = str.concat(&quot; World&quot;); // Returns &quot;Hello World&quot; toLowerCase() / toUpperCase(): Converts the string to lowercase or uppercase. 123String str = &quot;Hello&quot;;String lowerStr = str.toLowerCase(); // Returns &quot;hello&quot;String upperStr = str.toUpperCase(); // Returns &quot;HELLO&quot; trim(): Removes leading and trailing whitespaces. 12String str = &quot; Hello &quot;;String trimmedStr = str.trim(); // Returns &quot;Hello&quot; replace(char oldChar, char newChar): Replaces all occurrences of oldChar with newChar. 12String str = &quot;Hello&quot;;String replacedStr = str.replace('l', 'w'); // Returns &quot;Hewwo&quot; startsWith(String prefix) / endsWith(String suffix): Checks if the string starts or ends with the specified prefix or suffix. 123String str = &quot;Hello&quot;;boolean startsWith = str.startsWith(&quot;He&quot;); // Returns trueboolean endsWith = str.endsWith(&quot;lo&quot;); // Returns true 声明和转换 1234String str = &quot;Hello&quot;;char[] charArray = str.toCharArray();char[] charArray = {'H', 'e', 'l', 'l', 'o'};String str = new String(charArray); StringBuilder 12345StringBuilder sb = new StringBuilder(); // Default initial capacity (16)StringBuilder sbWithCapacity = new StringBuilder(30); // Initial capacity set to 30StringBuilder sbWithString = new StringBuilder(&quot;Hello&quot;); // Initialize with a stringsb.append(&quot; World&quot;); // Append a stringsb.insert(5, &quot; World&quot;); // Insert a string at index 5 java中的字符串不能进行更改，所以有两种方法一种是转换为char数组，另一种是创建stringbuild对象。 解决字符串的匹配问题最暴力的方法肯定是双层for循环来判断如果没有时间限制，一般可以实现。我们采用这些方法的目的是让我可以在时间和空间上有所提升。从n2到n 反转字符串力扣题目链接 需要头尾调换整个字符串，相当于我们实现一个reverse库函数。这里我们可以使用头尾双指针很方便的实现。 123456789101112public void reverseString(char[] s) { int left = 0; int right = s.length-1; char temp = 0; for (int i=0;i&lt;s.length/2;i++){ temp = s[left]; s[left] = s[right]; s[right]=temp; left++; right--; }} 反转字符串II力扣题目链接 这个题目有自己的反转规则，所以需要根据规则进行反转，所以需要想到的是i += 2 * k，而不是ch.length/2k，因为这样做会更加方便一点，然后还有就是题目的理解了，题目要求只要有k个就翻转k个，没有k个就翻转剩下的，所以最后一步可以直接判断是不是最后所有采用最小值进行替换。 1234567891011121314151617181920class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0;i &lt; ch.length;i += 2 * k){ int start = i; // 判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1,start + k - 1); while(start &lt; end){ char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; } } return new String(ch); }} for循环的执行顺序 for(int i = 0;i &lt; ch.length;i += 2 * k){ } ①int i = 0 ②i &lt; ch.length ③i += 2 * k ④循环体 执行过程是①-&gt;②-&gt;④-&gt;③再返回到2 151.翻转字符串里的单词力扣题目链接 这个主打一个熟悉很多的解决方法可以使用 使用StringBuilder 移除多余空格，将整个字符串反转，将每个单词反转。其中if 的意义是如果单词不是空格就插入，如果单词是空格就要保证上一次不是空格。 123456789101112int start = 0;int end = s.length() - 1;while (s.charAt(start) == ' ') start++;while (s.charAt(end) == ' ') end--;StringBuilder sb = new StringBuilder();while (start &lt;= end) { char c = s.charAt(start); if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } start++;} 创建新的字符串数组，对整体数组从后往前遍历，然后设置一个指针记录右侧位置如果是不是空格就添加。两个while循环确定一个单词的左右边界==‘ ’是用来删除空格的 1234while(i&gt;=0 &amp;&amp; initialArr[i] == ' '){i--;} //跳过空格//此时i位置是边界或!=空格，先记录当前索引，之后的while用来确定单词的首字母的位置int right = i;while(i&gt;=0 &amp;&amp; initialArr[i] != ' '){i--;} 使用char数组主要体现在移除空格上，操作原理同删除数组中的元素，通过双指针实现。这里是空格的if循环放哪里，更体会到了while遍历整个单词的作用。 123456789101112int slow = 0; for (int fast = 0; fast &lt; chars.length; fast++) { //先用 fast 移除所有空格 if (chars[fast] != ' ') { //在用 slow 加空格。 除第一个单词外，单词末尾要加空格 if (slow != 0) chars[slow++] = ' '; //fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了 while (fast &lt; chars.length &amp;&amp; chars[fast] != ' ') chars[slow++] = chars[fast++]; } } 28. 实现 strStr()-KMP力扣题目链接 这个大小子串必然是可以使用暴力解决两层for循环，但是另一种很重要的技术就是KMP实现字符串匹配， KMP理论知识当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。简单的来说就是匹配串自身存在一定的关联关系，如果它前缀上了，就可以通过最长相等前后缀串切换位置。 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。前缀表体现了不匹配时的之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和后缀关系，也就是如何移动将前缀匹配串转移到后缀匹配串上。 前缀表如何计算，比如你要计算aa的前缀表就把aa的所有前缀和后缀列出看看最大能匹配上的数目 这里我以aabaa举例 aabaa的前缀子串是a,aa,aab,aaba; 后缀子串是a,aa,baa,abaa; 所以可以很明显的看出最长匹配得前后缀串是aa所以是2，这时候如果f不匹配那么整个串就可以直接从2开始匹配因为前缀aa和后缀aa完全一致。 前缀表和Next数组的关系 很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？ next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。减一并右移之后就可以和index对应上了。 以下我们以前缀表统一减一之后的next数组来做演示。 有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。 注意next数组是新前缀表（旧前缀表统一减一了）。 仅此而已 KMP的时间复杂度是O(n+m)暴力的复杂度是O(n × m)，所以KMP在字符串匹配中极大地提高了搜索的效率。 KMP具体实现关键点不是反推出上述模式，而是如何根据上述理论推出代码。 123456789101112131415161718192021222324252627282930313233343536373839// 方法一class Solution { public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i &lt; s.length(); i++){ while(j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i &lt; haystack.length(); i++){ while(j&gt;=0 &amp;&amp; haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }} 1234567891011121314151617181920212223242526272829303132class Solution { //前缀表（不减一）Java实现 public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i &lt; haystack.length(); i++) { while (j &gt; 0 &amp;&amp; needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i &lt; s.length(); i++) { while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } }} 然后大小子串直接做就可以了。 459.重复的子字符串力扣题目链接 判断一个串是不是由其子串构成，这时就体现了两个思路 1.将这个串两个连接，然后如果能在其内部找到完整的子串证明其存在船夫的子串。 2.kmp的next 数组记录的是最长公共子前缀那么 证明： 假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。 因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理） 所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。 next 数组记录的就是最长相同前后缀这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。 最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1， 数组长度为：len。 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法","link":"/2024/01/29/PartVI_String/"},{"title":"myFirst Blog","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More infoGGGGGGG: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/21/hello-world/"}],"tags":[],"categories":[],"pages":[]}
{"posts":[{"title":"C++数据结构","text":"库函数：提供标准输入输出流对象，例如cin和cout。：提供字符串操作函数，例如连接、比较、查找等。：提供向量容器类模板，用于动态数组操作。 // For srand() and rand() // For time() MAP的生成和遍历 1234567unordered_map&lt;int,int&gt; map;for (auto it = map.begin(); it != map.end(); ++it) { if (it-&gt;second &gt; max) { max = it-&gt;second; majorityElement = it-&gt;first; } } 构造函数（与结构体同名，冒号后边用于初始化成员变量，大括号用于完成初始化操作如果没有操作可以为空） 123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; 举例 123456789101112class Person { private: std::string name; int age; public: // 构造函数，接受名字和年龄作为参数 Person(std::string n, int a) : name(n), age(a) { // 构造函数体可以留空，因为初始化列表已经完成了初始化工作 // 如果需要执行额外的操作，可以在这里添加代码 }} STL：vector构造函数12345vector&lt;int&gt; v; // 创建一个空的vector vector&lt;int&gt; v(10); // 创建一个含有10个元素的vector，默认初始化为0 vector&lt;int&gt; v(10, 42); // 创建一个含有10个元素的vector，每个元素值为42 vector&lt;int&gt; v2(v); // 复制构造函数，创建一个v的副本v2 vector&lt;int&gt; v3(v.begin(), v.end()); // 使用迭代器创建v的一个副本v3 赋值操作1234vector&lt;int&gt; v1 = {1, 2, 3}; //int数组初始化int a[3]= {1, 2, 3}vector&lt;int&gt; v2; v2 = v1; // 使用赋值运算符复制v1到v2 vector&lt;int&gt; v3(v1); // 直接在构造时复制v1到v3（复制构造函数） 访问元素1234vector&lt;int&gt; v = {10, 20, 30, 40, 50}; int first = v[0]; // 访问第一个元素，值为10 int last = v.back(); // 访问最后一个元素，值为50 int at_pos_2 = v.at(2); // 访问位置为2的元素，并进行边界检查，值为30 迭代器123456789vector&lt;int&gt; v = {1, 2, 3, 4, 5}; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 输出1 2 3 4 5 } // C++11及之后的版本可以使用范围for循环 for (int num : v) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; // 输出1 2 3 4 5 } 容量123456vector&lt;int&gt; v; v.push_back(1); cout &lt;&lt; v.size() &lt;&lt; endl; // 输出元素数量，值为1 cout &lt;&lt; v.capacity() &lt;&lt; endl; // 输出当前已分配的内存可以容纳的元素数量，至少为1 v.reserve(10); // 预留至少10个元素的空间（不改变size，但可能影响capacity） cout &lt;&lt; v.capacity() &lt;&lt; endl; // 输出可能增加，但至少为10 修改12345678vector&lt;int&gt; v = {1, 2, 3}; v.push_back(4); // 在末尾添加元素4，现在v为{1, 2, 3, 4} v.pop_back(); // 移除末尾元素，现在v为{1, 2, 3} v.insert(v.begin() + 1, 99); // 在位置1插入元素99，现在v为{1, 99, 2, 3} v1.insert(v1.end(), v2.begin(), v2.end()); // 在v1的末尾插入v2的所有元素 v.erase(v.begin() + 1); // 删除位置1的元素，现在v为{1, 2, 3} v.clear(); // 清空vector，现在v为空{}v.resize(3); // 将vector的大小改为3，删除或者添加末尾的元素 在C++中，”reverse”通常指的是将容器（如数组、向量、列表等）中的元素反转顺序，它可以用来反转任何支持双向迭代器的容器。 ​ std::reverse(numbers.begin(), numbers.end()); if (rightNode) 判断一个指针式否为空，为空返回false，不为空返回true。 deque（双端队列）经常作为stack和queue的底层容器使用。 1. stack（栈）stack是一个后进先出（LIFO）的数据结构。在STL中，你可以通过以下方式使用它： 声明和初始化123std::stack&lt;int&gt; s; // 默认使用deque作为底层容器 std::stack&lt;int, std::vector&lt;int&gt;&gt; s_vec; // 使用vector作为底层容器 std::stack&lt;int, std::deque&lt;int&gt;&gt; s_deq; // 使用deque作为底层容器（实际上与默认情况相同） 主要成员函数 push(const value_type&amp; val): 将元素压入栈顶。没有返回值。 pop(): 删除栈顶元素。没有返回值 top(): 返回栈顶元素的引用。如果栈不为空，则返回栈顶元素的引用；如果栈为空，则行为是未定义的（通常会导致程序崩溃）。 empty(): 检查栈是否为空。返回一个布尔值，如果栈为空则返回true，否则返回false。 size(): 返回栈中元素的数量。返回一个整数 2. queue（队列）queue是一个先进先出（FIFO）的数据结构。在STL中，你可以通过以下方式使用它： 声明和初始化123std::queue&lt;int&gt; q; // 默认使用deque作为底层容器 std::queue&lt;int, std::list&lt;int&gt;&gt; q_list; // 使用list作为底层容器 std::queue&lt;int, std::deque&lt;int&gt;&gt; q_deq; // 使用deque作为底层容器（实际上与默认情况相同） 主要成员函数 push(const value_type&amp; val): 将元素添加到队列末尾。 pop(): 删除队列的第一个元素。 front(): 返回队列的第一个元素的引用。 back(): 返回队列的最后一个元素的引用（注意：这不是标准队列操作，但在STL的queue中提供）。 empty(): 检查队列是否为空。 size(): 返回队列中元素的数量。 3. deque（双端队列）虽然你提到的是stack和queue，但deque是一个独立的容器，它支持在两端进行插入和删除操作。它可以用作stack和queue的底层容器。 声明和初始化123cpp复制代码std::deque&lt;int&gt; d; 主要成员函数 push_front(const value_type&amp; val): 在双端队列的前端插入元素。 push_back(const value_type&amp; val): 在双端队列的末尾插入元素。 pop_front(): 删除双端队列的第一个元素。 pop_back(): 删除双端队列的最后一个元素。 front(): 返回双端队列的第一个元素的引用。 back(): 返回双端队列的最后一个元素的引用。 empty(): 检查双端队列是否为空。 size(): 返回双端队列中元素的数量。 哈希数据 set（集合） map(映射) 集合 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) 重点关注实现方式以及查询效率，所以一般情况下我们都使用unordered_set和unordered_map可以提升效率。 映射 底层实现 是否有序 数值是否可以重复 能否更改数值 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1) 构造函数 1unordered_map&lt;string, int&gt; ageMap; // 创建一个unordered_map，键为string类型，值为int类型 1map.insert(make_pair(&quot;Alice&quot;, 30)) 或者使用map[j] = i; 的语法来插入或更新元素，这里的 map 是一个 unordered_map 的变量名，j 是键（key），i 是值（value）。 插入与更新：如果该键 j 已经存在于 unordered_map 中，则 map[j] = i; 会更新该键对应的值为 i。如果该键 j 不存在，它会在 unordered_map 中插入一个新元素，键为 j，值为 i。 查找 12345678auto it = ageMap.find(&quot;Charlie&quot;); if (it != ageMap.end()) { // 找到了 cout &lt;&lt; &quot;Charlie's age: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } else { // 没找到 cout &lt;&lt; &quot;Charlie not found&quot; &lt;&lt; endl; } 当你有一个指向map或unordered_map中元素的迭代器it时： it-&gt;first 表示当前元素（键值对）的键。 it-&gt;second 表示当前元素（键值对）的值。 string字符串在C++中，std::string是一个非常有用的类，它表示可变长度的字符串。这个类提供了许多方法来操作字符串。以下是一些常用的std::string成员函数： 构造函数和析构函数 string(): 构造一个空的字符串 string(const string&amp; str): 拷贝构造函数 访问和修改 at(size_t pos): 通过索引访问字符，同时进行范围检查 front(): 返回字符串的第一个字符 back(): 返回字符串的最后一个字符 +=: 连接字符串或字符 append(): 在字符串末尾添加字符或字符串 push_back(char c): 在字符串末尾添加一个字符 insert(): 在指定位置插入字符或字符串 erase(): 删除从指定位置开始的特定数量的字符 replace(): 替换字符串中的一部分 swap(): 交换两个字符串的内容 clear(): 清空字符串内容 字符串信息 size() / length(): 返回字符串的长度 empty(): 检查字符串是否为空 capacity(): 返回当前分配的存储空间的大小 reserve(): 预留一定的存储空间 resize(): 改变字符串的大小 查找和比较 find(): 查找子字符串或字符的位置 其他实用函数 substr(): 返回一个新的字符串，它是此字符串的一个子字符串 c_str(): 返回一个指向正规C字符串的指针, 内容与本字符串相同 get_allocator(): 返回配置器 添加字符 12// 方法2: 使用 + 运算符str1 += str2.substr(0, 3); // 添加 str2 的前三个字符到 str1 reserve(): 函数确实遵循左闭右开原则。这是 C++ 标准库中许多函数共有的范围 链表12345struct ListNode { int val; // 节点存储的数据 ListNode *next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(nullptr) {} // 构造函数}; 整行字符串输入12345678while (getline(cin, s)) { // 接受⼀整⾏字符串 for(int i = 0; i &lt; s.size();i++) { //遍历字符串 }}getchar(); 一行不确定输入123456789101112for (int i = 0; i &lt; n; ++i) { std::cout &lt;&lt; &quot;Enter line &quot; &lt;&lt; (i + 1) &lt;&lt; &quot;: &quot;; std::string line; std::getline(std::cin, line); std::istringstream iss(line); std::vector&lt;int&gt; lineData; int num; while (iss &gt;&gt; num) { lineData.push_back(num); } 123456789//（1）输入数字：while(cin&gt;&gt;i){ cout&lt;&lt;i&lt;&lt;endl;}//（2）输入字符串：while(getline(cin,s)){cout&lt;&lt;s&lt;&lt;endl;} 创建二叉树优先队列1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; 第一个是放入的类型，第二个是存储的方式，第三个是从小到大，less是从大到小 没有遍历只有 1234priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;pq.push()pq.top() pq.pop() 自定义比较函数 大顶堆：在大顶堆中，父节点的值大于或等于其每个子节点的值。因此，堆的根节点（顶部节点）是堆中的最大值。 小顶堆：在小顶堆中，父节点的值小于或等于其每个子节点的值。因此，堆的根节点（顶部节点）是堆中的最小值。 小顶堆的意思是优先队列的头部元素（即队首元素）是最小的。priority_queue默认使用的是大顶堆，也就是说队首元素是最大的 12345678class mycomparison {public: //从头到尾是从小到大 bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.second &gt; rhs.second; }};priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; 1234//常规的从小到大排序bool compare(int a, int b) { return a &lt; b; // 按照升序排序} struct123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}};","link":"/2024/04/29/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"Git从原理到实践","text":"背景如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本 用户 说明 日期 1 张三 删除了软件服务条款5 7/12 10:38 2 张三 增加了License人数限制 7/12 18:09 3 李四 财务部门调整了合同金额 7/13 9:51 4 张三 延长了免费升级周期 7/14 15:17 那么它就是Git 到了 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 安定团结的大好局面在 2005 年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 常用命令git init 初始化仓库 git add &lt;file&gt; 添加文件到缓冲区，git add .添加所有文件到缓冲区（Stage） git commit 提交代码到本地版本库，此时会生成版本的提交hash git status 查看状态，可以查看当前所处的分支，当前的修改内容和提交到版本库里的内容 git diff 可以让你看到你更改的内容 git log 查看commit的版本，参数--pretty=oneline会只显示版本和commit git rest --hard hash or head^会进行版本号的回退可以选用版本的hash值或者HEAD^代表回退上一版本， git reflog 记录你的版本操作， git checkout -- file 可以丢弃工作区的修改。把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况： 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 git checkout file不加横杠就是创建分支 git reset HEAD file 撤销存储在缓冲区里的内容，HEAD 代表最新版本，也可以使用hash。 unstage是撤销缓存区中的内容 将你本地删除的文件在git上也删除，然后再提交，现在，文件就从版本库中被删除了。 12git rm test.txtgit commit -m &quot;remove test.txt&quot; git checkout -- test.txt 是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程库需要把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。 1git remote add origin git@github.com:michaelliao/learngit.git git push -u origin main把本地库的所有内容推送到远程库上，-u参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来 创建分支就是创建了一个指针，他可以独立于master进行提交和更改 1234git checkout -b dev #创建并切换分支#等于下边两条指令git branch dev #创建分支git checkout dev #切换分支 git merge dev 可以将你对分支的提交的修改提交到master上，这里的dev是把dev合并到当前分支，当你同时修改一个文件时才会冲突，修改两个文件不会冲突。然后再提交到缓冲区，在提交版本 git branch -d dev 删除分支 git branch 查看分支 当出现如下修改时不能自动的合并分支 需要我们去手动解决冲突后再提交。git status 也可以告诉我们冲突的文件： 可以看到合并的过程 1git log --graph --pretty=oneline --abbrev-commit git merge --no-ff -m &quot;merge with no-ff&quot; dev会以提交的方式合并分支 git stash 可以保存缓冲区的内容而不用提交 git stash list 可以查看工作现场的列表 git stash apply 恢复保存起来的现场 git stash drop 删除保存起来的现场 git stash apply stash@{0} 恢复指定现场 git branch -D feature-vulcan 强制删除分支 远端合并解决方案分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 如果版本库领先自己一个版本应该如何操作和更改应该git rebase 如何pull和pushgit和pull 和是在和远程库操作，只是在拉取相应的分支并合并，与其他分支之间没有关系 git rebase 原理chatgpt git rebase 是一个强大的 Git 命令，用于将一个分支的提交历史重新应用到另一个分支之上。 基本工作流程假设我们有两个分支，main 和 feature，并且 feature 分支是从 main 分支分出来的，现在我们想要把 feature 分支的更改重新基于 main 最新的提交之上。我们可以使用 git rebase main 来实现这个目标。 内部指令解析假设初始状态： main 分支：A - B - C feature 分支：A - B - C - D - E 执行 git rebase main： 确定共同祖先提交: 1git merge-base main feature 假设共同祖先提交是 A。 创建补丁并保存到临时文件: 1git format-patch A..feature -o /tmp/patches 这会在临时目录中创建从 A 到 feature 的补丁文件。 切换到main分支并重置feature分支: 12git checkout featuregit reset --hard main 现在 feature 分支的 HEAD 和 main 分支的 HEAD 是一致的。 应用补丁: 1git am /tmp/patches/*.patch 这一步会逐个应用补丁，并创建新的提交。应用过程中，如果有冲突，Git 会暂停并允许用户手动解决冲突。 其他常见操作处理冲突如果在应用补丁的过程中遇到冲突，Git 会暂停并提示用户解决冲突。用户解决冲突后，需要执行以下命令继续： 12git add &lt;resolved-files&gt;git rebase --continue 如果用户希望放弃变基，可以执行： 1git rebase --abort git rebase 和git pull 的替换可以使用 git pull、git push 和 git merge 来实现类似 git rebase 的效果。虽然这并不是完全相同的操作，但通过一些步骤，你可以手动完成类似的变基过程。 以下是一个示例，展示如何使用这些命令来实现 git rebase 的效果： 场景设置假设有两个分支： main 分支 feature 分支 我们希望将 feature 分支的更改重新基于 main 分支的最新提交之上。 步骤1. 更新 main 分支首先，确保 main 分支是最新的： 12git checkout maingit pull origin main 这将把 main 分支拉到最新状态。 2. 更新 feature 分支接下来，切换到 feature 分支并拉取最新的更改： 12git checkout featuregit pull origin feature 这将确保 feature 分支也是最新的。 3. 创建临时分支创建一个临时分支来保存 feature 分支的更改： 1git checkout -b feature-temp 4. 将 feature 分支重置到 main 分支切换回 feature 分支并将其重置到 main 分支的最新提交： 12git checkout featuregit reset --hard main 现在 feature 分支的 HEAD 与 main 分支的 HEAD 相同。 5. 合并临时分支的更改将临时分支的更改合并到 feature 分支： 1git merge feature-temp 在这个过程中，如果有冲突，解决冲突并继续合并。 6. 推送更改如果合并成功，将 feature 分支的更改推送到远程仓库： 1git push origin feature --force 总结通过这样述步骤，可以实现类似 git rebase 的效果总结步骤如下： 更新 main 分支和 feature 分支。 创建一个临时分支保存 feature 分支的更改。 将 feature 分支重置到 main 分支。 合并临时分支的更改到 feature 分支。 推送更改到远程仓库。 hexo常用命令https://www.jianshu.com/p/c14e70f5885d 参考https://doc.yonyoucloud.com/doc/wiki/project/git-tutorial/index.html","link":"/2024/06/02/Git/"},{"title":"Linux基础","text":"VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 drwxr-xr-x 表示文件所有者、文件所属组和其他用户的权限。 r 表示读权限（read），表示允许读取该文件或目录的内容。 w 表示写权限（write），表示允许对该文件或目录进行写入操作，包括修改、删除等。 x 表示执行权限（execute），对于文件来说表示可以执行，对于目录来说表示可以进入该目录。 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 **Ctrl+C**： 在终端中，Ctrl+C 通常用于中断当前正在运行的进程。当你按下 Ctrl+C 键时，终端会向当前正在前台运行的程序发送一个中断信号（SIGINT），导致程序终止运行并返回到终端提示符状态。 这个操作对于停止长时间运行的命令或程序非常有用，例如如果你运行了一个无限循环的命令，按下 Ctrl+C 就可以停止它。 **Ctrl+Z**： 在终端中，Ctrl+Z 通常用于将当前正在运行的进程挂起（暂停）。 当你按下 Ctrl+Z 键时，终端会向当前正在前台运行的程序发送一个挂起信号（SIGTSTP），导致程序被暂停执行，并返回到终端提示符状态。 挂起的程序可以使用 fg 命令恢复到前台继续执行，也可以使用 bg 命令将其转移到后台继续执行。 PATH可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 1/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin 文件系统对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。 文件与目录的基本操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1234## ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd更换当前目录。 1cd [相对路径或绝对路径] 3. mkdir创建目录。 123## mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 4. rmdir删除目录，目录必须为空。 12rmdir [-p] 目录名称-p ：递归删除目录 5. touch更新文件时间或者建立新文件。 123456## touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。 12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm删除文件。 1234## rm [-fir] 文件或目录-f：强制删除，不进行确认提示。-i：交互模式，在删除之前会询问用户是否确认删除。-r：递归删除，用于删除目录及其下所有文件和子目录。 8. mv移动文件。 123## mv [-fiu] source destination## mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 1## chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1## chmod 754 .bashrc 也可以使用符号来设定权限。 1234## chmod [ugoa] [+-=] [rwx] dirname/filename- +：添加权限- -：移除权限- =：设定权限 示例：为 .bashrc 文件的所有用户添加写权限。 链接 123## ln [-sf] source_filename dist_filename-s ：默认是实体链接，加 -s 为符号链接-f ：如果目标文件存在时，先删除目标文件 1. 实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 1234## ln /etc/crontab .## ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 因为记录的是路径，所以可以为目录建立符号链接。 123## ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 获取文件内容1. cat取得文件内容。 12## cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 指令与文件搜索1. which指令搜索。 12## which [-a] command-a ：将所有指令列出，而不是只列第一个 4. find文件搜索。可以使用文件的属性和权限进行搜索。 12## find [basedir] [option]example: find . -name &quot;shadow*&quot; ① 与时间有关的选项 12345-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件-newer file ： 列出比 file 更新的文件find . -mtime -10 +4、4 和 -4 的指示的时间范围如下： ② 与文件拥有者和所属群组有关的选项 123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 ③ 与文件权限和名称有关的选项 123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 压缩指令gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 七、Bash特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 ll 是 ls -al 的别名 shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 变量操作对一个变量赋值直接使用 =。 对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式； 输出变量使用 echo 命令。 123$ x=abc$ echo $x$ echo ${x} 变量内容如果有空格，必须使用双引号或者单引号。 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 八、管道指令管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。 在命令之间使用 | 分隔各个管道命令。 1$ ls -al /etc | less 九、正则表达式grepg/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 123456$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 统计匹配到行的个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 123456$ grep -n 'the' regular_express.txt8:I can't finish the test.12:the symbol '*' is represented as start.15:You are the best is mean you are the no. 1.16:The world Happy is the same with &quot;glad&quot;.18:google is the best tools for search keyword 示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。 1$ grep -n 'a\\{2,5\\}' regular_express.txt","link":"/2024/04/29/Linux%E5%9F%BA%E7%A1%80/"},{"title":"二叉树","text":"二叉树注意点确定那种遍历方法（BFS，DFS）如果是深度优先遍历，确定是前序后序还是中序。确定遍历方法的哪种实现（递归，迭代） 二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。 满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。 完全二叉树完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。 所有满二叉树都是完全二叉树，但并非所有完全二叉树都是满二叉树。 二叉搜索树前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 下面这两棵树都是搜索树 平衡二叉搜索树平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 链式存储方式就用指针， 顺序存储的方式就是用数组。 链式存储如图： 数组实现如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 二叉树的遍历方式 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式： 深度优先遍历 前序遍历（递归法，迭代法）——中左右 中序遍历（递归法，迭代法）——左中右 后序遍历（递归法，迭代法）——左右中 广度优先遍历 层次遍历（迭代法） 二叉树的定义 12345678910111213public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; }} java底层对象的实现方式： ArrayList： 基于动态数组实现。内部使用数组来存储元素，当数组容量不足时，会自动进行扩容。 LinkedList： 基于双向链表实现。每个节点包含数据和指向前后节点的引用，支持快速的插入和删除操作。 HashSet： 基于哈希表实现。元素存储在哈希表的桶中，通过哈希码确定元素在桶中的位置。 TreeSet： 基于红黑树实现。红黑树是一种自平衡的二叉查找树，用于保持元素的有序性。 HashMap： 基于哈希表实现。使用键的哈希码来确定键值对在哈希表中的位置。 TreeMap： 基于红黑树实现。与TreeSet类似，使用红黑树来保持键的有序性。 深度优先遍历（DFS）-递归遍历前边我们已经知道了前序遍历中序遍历已经后序遍历的顺序每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！ 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，因为递归是动态变化的，所以参数值应是随着递归会变化的参数值。并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 1public void preorder(TreeNode root, List&lt;Integer&gt; result) 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 123if (root == null) { return;} 确定单层递归的逻辑： 确定每一层递归需要处理的信息。单层需要做哪些处理，递归的位置在哪。 123result.add(root.val);preorder(root.left, result);preorder(root.right, result); 完整的递归遍历二叉树的方法 12345678910111213141516class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); preorder(root, result); return result; } public void preorder(TreeNode root, List&lt;Integer&gt; result) { if (root == null) { return; } result.add(root.val); preorder(root.left, result); preorder(root.right, result); }} 深度优先遍历（DFS）-迭代遍历可以看到递归遍历二叉树很简单，但是迭代遍历可能有些不同，并且这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！所以前序遍历代码还不同于中序遍历 前序遍历设置一个栈每次弹出他们的父亲节点然后添加左右孩子节点。这样看起来也是实现递归，因为同理递归的实现也是依靠栈。 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()){ TreeNode node = stack.pop(); result.add(node.val); if (node.right != null){ stack.push(node.right); } if (node.left != null){ stack.push(node.left); } } return result; }} 中序遍历中序遍历不同于前序主要原因是遍历节点不是处理的节点，需要创建一个cur的指针，中序遍历是左中右，所以一路向左到叶子节点。最左的叶子节点先弹出，并加入结果，然后遍历叶子的右同样为null的话证明他的节点遍历完了，此时cur==叶子节点的负节点把他加入结果遍历右节点。 123456789101112131415161718192021class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; }} 后续遍历翻转前序遍历即可 1Collections.reverse(result); 统一迭代如何让迭代风代统一呢那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。 如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { //前序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 //中序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） //后序 st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; }} 广度优先搜索（BFS）层序遍历递归用数组实现，传递参数时传递深度，由此可以找到，迭代是每次循环都添加新的一层到队列，秉承先进先出可以保证顺序一致。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { //checkFun01(root,0); checkFun02(root); return resList; } //DFS--递归方式 public void checkFun01(TreeNode node, Integer deep) { if (node == null) return; deep++; if (resList.size() &lt; deep) { //当层级增加时，list的Item也增加，利用list的索引值进行层级界定 List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;(); resList.add(item); } resList.get(deep - 1).add(node.val); checkFun01(node.left, deep); checkFun01(node.right, deep); } //BFS--迭代方式--借助队列 public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } }} 226.翻转二叉树力扣题目链接 把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果，所以这个就属于一个遍历的应用主要看在遍历过程中交换的位置在哪里。 DFS123456789101112131415161718192021class Solution { /** * 前后序遍历都可以 * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换） */ public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } invertTree(root.left); invertTree(root.right); swapChildren(root); return root; } private void swapChildren(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; }} BFS1234567891011121314151617181920212223class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) {return null;} ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;(); deque.offer(root); while (!deque.isEmpty()) { int size = deque.size(); while (size-- &gt; 0) { TreeNode node = deque.poll(); swap(node); if (node.left != null) deque.offer(node.left); if (node.right != null) deque.offer(node.right); } } return root; } public void swap(TreeNode root) { TreeNode temp = root.left; root.left = root.right; root.right = temp; }} 101. 对称二叉树力扣题目链接 要比较的并不是左右节点而是两个子树的里侧和外侧的元素是否相等 确定终止条件 要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。 节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点） 左节点为空，右节点不为空，不对称，return false 左不为空，右为空，不对称 return false 左右都为空，对称，返回true 此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空： 左右都不为空，比较节点数值，不相同就return false 迭代法 123456789101112131415161718192021222324252627public boolean isSymmetric3(TreeNode root) { Queue&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root.left); deque.offer(root.right); while (!deque.isEmpty()) { TreeNode leftNode = deque.poll(); TreeNode rightNode = deque.poll(); if (leftNode == null &amp;&amp; rightNode == null) { continue; } if (leftNode == null &amp;&amp; rightNode != null) { return false; } if (leftNode != null &amp;&amp; rightNode == null) { return false; } if (leftNode.val != rightNode.val) { return false; } // 这里顺序与使用Deque不同 deque.offer(leftNode.left); deque.offer(rightNode.right); deque.offer(leftNode.right); deque.offer(rightNode.left); } return true;} 104.二叉树的最大深度力扣题目链接 就是看看二叉树有多少层 本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）就是根向下数 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）就是从叶子向上数。 递归法递归法就是再求从叶子节点开始以贪心的方式找最大深度 12345678910111213class solution { /** * 递归法 */ public int maxDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); return Math.max(leftDepth, rightDepth) + 1; }} 迭代法迭代法是层序遍历的模板 123456789101112131415161718192021222324252627class solution { /** * 迭代法，使用层序遍历 */ public int maxDepth(TreeNode root) { if(root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode node = deque.poll(); if (node.left != null) { deque.offer(node.left); } if (node.right != null) { deque.offer(node.right); } } } return depth; }} 111.二叉树的最小深度力扣题目链接 不能直接的使用最大深度取一个最小值的情况，因为还有没有节点的情况，最小深度是指从根到叶子，并不是如果没有节点就是最小比如下图。叶子节点的特征是左右子树都为空。所以第一次判断右子树为空左子树不为空应该返回的是左子树+1的深度。 递归法123456789101112131415161718192021class Solution { /** * 递归法，相比求MaxDepth要复杂点 * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量 */ public int minDepth(TreeNode root) { if (root == null) { return 0; } int leftDepth = minDepth(root.left); int rightDepth = minDepth(root.right); if (root.left == null) { return rightDepth + 1; } if (root.right == null) { return leftDepth + 1; } // 左右结点都不为null return Math.min(leftDepth, rightDepth) + 1; }} 迭代法12345678910111213141516171819202122232425262728293031class Solution { /** * 迭代法，层序遍历 */ public int minDepth(TreeNode root) { if (root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode poll = deque.poll(); if (poll.left == null &amp;&amp; poll.right == null) { // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值 return depth; } if (poll.left != null) { deque.offer(poll.left); } if (poll.right != null) { deque.offer(poll.right); } } } return depth; }} 222.完全二叉树的节点个数力扣题目链接 通用解决方法123456789101112class Solution { // 通用递归解法 public int countNodes(TreeNode root) { if(root == null) { return 0; } int leftNum = getNodesNum(root.left); // 左 int rightNum = getNodesNum(root.right); // 右 int treeNum = leftNum + rightNum + 1; // 中 return treeNum; }} 12345678910111213141516171819class Solution { // 迭代法 public int countNodes(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int result = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size -- &gt; 0) { TreeNode cur = queue.poll(); result++; if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); } } return result; }} 完全二叉树解决方法但是完全二叉树是否有更简单的求法呢，当然，就是判断他的左右子树的深度是否完全一样如果完全一样就是一个满二叉树就可以用满二叉树的计算公式 2^树深度 - 1 因为完全二叉树要求如果有节点不满那么一定在左边，所以如果深度不一样则说明不是满二叉树。 12345678910111213141516171819202122232425class Solution { /** * 针对完全二叉树的解法 * * 满二叉树的结点数为：2^depth - 1 */ public int countNodes(TreeNode root) { if (root == null) return 0; TreeNode left = root.left; TreeNode right = root.right; int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便 while (left != null) { // 求左子树深度 left = left.left; leftDepth++; } while (right != null) { // 求右子树深度 right = right.right; rightDepth++; } if (leftDepth == rightDepth) { return (2 &lt;&lt; leftDepth) - 1; // 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0 } return countNodes(root.left) + countNodes(root.right) + 1; }}","link":"/2024/02/19/Part6.1%20_Tree/"},{"title":"二叉树2","text":"110.平衡二叉树力扣题目链接 一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 求深度适合用前序遍历，而求高度适合用后序遍历。 递归法这里有个逻辑是如果子树不是平衡二叉树，那么父节点的同样不是平衡二叉树所以直接返回-1就不用继续判断了 123456789101112131415161718192021222324252627class Solution { /** * 递归法 */ public boolean isBalanced(TreeNode root) { return getHeight(root) != -1; } private int getHeight(TreeNode root) { if (root == null) { return 0; } int leftHeight = getHeight(root.left); if (leftHeight == -1) { return -1; } int rightHeight = getHeight(root.right); if (rightHeight == -1) { return -1; } // 左右子树高度差大于1，return -1表示已经不是平衡树了 if (Math.abs(leftHeight - rightHeight) &gt; 1) { return -1; } return Math.max(leftHeight, rightHeight) + 1; }} 迭代法层序遍历并不适合查找树的高度，因为你需要判断到哪个节点，所以可以采取先使用统一递归求深度，再使用迭代求一层一层的判断左右子树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { /** * 迭代法，效率较低，计算高度时会重复遍历 * 时间复杂度：O(n^2) */ public boolean isBalanced(TreeNode root) { if (root == null) { return true; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while (root!= null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } TreeNode inNode = stack.peek(); // 右结点为null或已经遍历过 if (inNode.right == null || inNode.right == pre) { // 比较左右子树的高度差，输出 if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) &gt; 1) { return false; } stack.pop(); pre = inNode; root = null;// 当前结点下，没有要遍历的结点了 } else { root = inNode.right;// 右结点还没遍历，遍历右结点 } } return true; } /** * 层序遍历，求结点的高度 */ public int getHeight(TreeNode root) { if (root == null) { return 0; } Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;(); deque.offer(root); int depth = 0; while (!deque.isEmpty()) { int size = deque.size(); depth++; for (int i = 0; i &lt; size; i++) { TreeNode poll = deque.poll(); if (poll.left != null) { deque.offer(poll.left); } if (poll.right != null) { deque.offer(poll.right); } } } return depth; }} 257. 二叉树的所有路径力扣题目链接 这个回溯就有很大的问题，我们知道，回溯和递归是一一对应的，有一个递归，就要有一个回溯，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。 所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！ 递归这里回溯的位置是重点。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { /** * 递归法 */ public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; res = new ArrayList&lt;&gt;();// 存最终的结果 if (root == null) { return res; } List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// 作为结果中的路径 traversal(root, paths, res); return res; } private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) { paths.add(root.val);// 前序遍历，中 // 遇到叶子结点 if (root.left == null &amp;&amp; root.right == null) { // 输出 StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快 for (int i = 0; i &lt; paths.size() - 1; i++) { sb.append(paths.get(i)).append(&quot;-&gt;&quot;); } sb.append(paths.get(paths.size() - 1));// 记录最后一个节点 res.add(sb.toString());// 收集一个路径 return; } // 递归和回溯是同时进行，所以要放在同一个花括号里 if (root.left != null) { // 左 traversal(root.left, paths, res); paths.remove(paths.size() - 1);// 回溯 } if (root.right != null) { // 右 traversal(root.right, paths, res); paths.remove(paths.size() - 1);// 回溯 } }} 迭代法12345678910111213141516171819202122232425262728293031323334class Solution { /** * 迭代法 */ public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; Stack&lt;Object&gt; stack = new Stack&lt;&gt;(); // 节点和路径同时入栈 stack.push(root); stack.push(root.val + &quot;&quot;); while (!stack.isEmpty()) { // 节点和路径同时出栈 String path = (String) stack.pop(); TreeNode node = (TreeNode) stack.pop(); // 若找到叶子节点 if (node.left == null &amp;&amp; node.right == null) { result.add(path); } //右子节点不为空 if (node.right != null) { stack.push(node.right); stack.push(path + &quot;-&gt;&quot; + node.right.val); } //左子节点不为空 if (node.left != null) { stack.push(node.left); stack.push(path + &quot;-&gt;&quot; + node.left.val); } } return result; }} BFS的迭代和DFS的迭代BFS和DFS的迭代都是放入然后加入他的子节点而不同的是，DFS的迭代是使用的栈所以每弹出一个节点会接下来弹出的是他的子节点，而BFS弹出的是他们这一行的节点。 12345678910111213141516171819202122//DFS的中序迭代使用了栈class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null){ return result; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; }} 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { checkFun02(root); return resList; } public void checkFun02(TreeNode node) { if (node == null) return; Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); que.offer(node); while (!que.isEmpty()) { List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); int len = que.size(); while (len &gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } }} 513.找树左下角的值力扣题目链接 重要点是区分树的左下角并不是最左边的节点，而是最深长度那一行的最左的节点，所以这个题目用层序遍历来做十分的简答，但是若果用递归的话就要分两步1.求出是否是最深长度，2.求出最左的节点。 回溯方法关联104.二叉树的最大深度 递归递归三部曲： 确定递归函数的参数和返回值 参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。 1private void traversal(TreeNode root, int depth) 确定终止条件 当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。 确定单层递归的逻辑 1234567891011121314151617181920212223242526272829303132private void traversal(TreeNode root, int depth) { if (root.left == null &amp;&amp; root.right == null) { if (depth &gt; maxDepth) { maxDepth = depth; result = root.val; } return; } if (root.left != null) { depth++; traversal(root.left, depth ); depth--; } if (root.right != null) { depth++; traversal(root.right, depth ); depth--; }}public int findBottomLeftValue(TreeNode root) { traversal(root, 0); return result;}// Assuming TreeNode is defined as follows:// class TreeNode {// int val;// TreeNode left;// TreeNode right;// TreeNode(int x) { val = x; }// } 迭代层序 12345678910111213141516171819public class Solution { public int findBottomLeftValue(TreeNode root) { Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(root); TreeNode out = new TreeNode() ; while (!queue.isEmpty()){ int len = queue.size(); out = queue.peek(); while (len&gt;0){ TreeNode temp = queue.poll(); if (temp.left!=null) queue.add(temp.left); if (temp.right!=null) queue.add(temp.right); len--; } } return out.val; }}","link":"/2024/02/19/Part6.2_Tree/"},{"title":"二叉树3","text":"112. 路径总和力扣题目链接 递归可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树 确定递归函数的参数和返回类型 参数：二叉树的根节点，sum：来计算加上二叉树的一条边之和是否等于是目标和。 再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点： 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii） 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍） 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况） 106.从中序与后序遍历序列构造二叉树力扣题目链接 前序和中序，中序和后序都可以构成二叉树。 来看一下一共分几步： 第一步：如果数组大小为零的话，说明是空节点了。 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组） 第五步：切割后序数组，切成后序左数组和后序右数组 第六步：递归处理左区间和右区间 inorder前序，postorder中序 12345678910111213141516171819202122232425class Solution { Map&lt;Integer, Integer&gt; map; // 方便根据数值查找位置 public TreeNode buildTree(int[] inorder, int[] postorder) { map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) { // 用map保存中序序列的数值对应位置 map.put(inorder[i], i); } return findNode(inorder, 0, inorder.length, postorder,0, postorder.length); // 前闭后开 } public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) { // 参数里的范围都是前闭后开 if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) { // 不满足左闭右开，说明没有元素，返回空树 return null; } int rootIndex = map.get(postorder[postEnd - 1]); // 找到后序遍历的最后一个元素在中序遍历中的位置 TreeNode root = new TreeNode(inorder[rootIndex]); // 构造结点 int lenOfLeft = rootIndex - inBegin; // 保存中序左子树个数，用来确定后序数列的个数 root.left = findNode(inorder, inBegin, rootIndex, postorder, postBegin, postBegin + lenOfLeft); root.right = findNode(inorder, rootIndex + 1, inEnd, postorder, postBegin + lenOfLeft, postEnd - 1); return root; }} 654.最大二叉树力扣题目地址 构造树一般采用的是前序遍历 递归法的三个步骤“确定传入参数和返回类型、确定终止条件、确定单次的内部结构。 123456789101112131415161718192021222324252627class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return constructMaximumBinaryTree1(nums, 0, nums.length); } public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) { if (rightIndex - leftIndex &lt; 1) {// 没有元素了 return null; } if (rightIndex - leftIndex == 1) {// 只有一个元素 return new TreeNode(nums[leftIndex]); } int maxIndex = leftIndex;// 最大值所在位置 int maxVal = nums[maxIndex];// 最大值 for (int i = leftIndex + 1; i &lt; rightIndex; i++) { if (nums[i] &gt; maxVal){ maxVal = nums[i]; maxIndex = i; } } TreeNode root = new TreeNode(maxVal); // 根据maxIndex划分左右子树 root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex); root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex); return root; }} 617.合并二叉树力扣题目链接 因为不涉及 中节点的处理只有遍历，所以用哪种深度优先的方法都是可以的 123456789101112class Solution { // 递归 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 == null) return root1; root1.val += root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }} 栈迭代 123456789101112131415161718192021222324252627282930313233343536class Solution { // 使用栈迭代 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) { return root2; } if (root2 == null) { return root1; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root2); stack.push(root1); while (!stack.isEmpty()) { TreeNode node1 = stack.pop(); TreeNode node2 = stack.pop(); node1.val += node2.val; if (node2.right != null &amp;&amp; node1.right != null) { stack.push(node2.right); stack.push(node1.right); } else { if (node1.right == null) { node1.right = node2.right; } } if (node2.left != null &amp;&amp; node1.left != null) { stack.push(node2.left); stack.push(node1.left); } else { if (node1.left == null) { node1.left = node2.left; } } } return root1; }} 队列迭代 1234567891011121314151617181920212223242526272829303132333435class Solution { // 使用队列迭代 public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if (root1 == null) return root2; if (root2 ==null) return root1; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root1); queue.offer(root2); while (!queue.isEmpty()) { TreeNode node1 = queue.poll(); TreeNode node2 = queue.poll(); // 此时两个节点一定不为空，val相加 node1.val = node1.val + node2.val; // 如果两棵树左节点都不为空，加入队列 if (node1.left != null &amp;&amp; node2.left != null) { queue.offer(node1.left); queue.offer(node2.left); } // 如果两棵树右节点都不为空，加入队列 if (node1.right != null &amp;&amp; node2.right != null) { queue.offer(node1.right); queue.offer(node2.right); } // 若node1的左节点为空，直接赋值 if (node1.left == null &amp;&amp; node2.left != null) { node1.left = node2.left; } // 若node1的右节点为空，直接赋值 if (node1.right == null &amp;&amp; node2.right != null) { node1.right = node2.right; } } return root1; }} 700.二叉搜索树中的搜索力扣题目地址 递归很简单不给出代码 迭代 1234567891011class Solution {public: TreeNode* searchBST(TreeNode* root, int val) { while (root != NULL) { if (root-&gt;val &gt; val) root = root-&gt;left; else if (root-&gt;val &lt; val) root = root-&gt;right; else return root; } return NULL; }}; 530.二叉搜索树的最小绝对差力扣题目链接 计算的是任意两节点的最小值 最简单的方法是二叉搜索树的中序遍历是有序的我们可以计算出数组数组相邻的最小绝对差，当然也可以采用一个双指针，pre记录上一个访问的节点 123456789101112131415161718192021class Solution { TreeNode pre;// 记录上一个遍历的结点 int result = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) { if(root==null)return 0; traversal(root); return result; } public void traversal(TreeNode root){ if(root==null)return; //左 traversal(root.left); //中 if(pre!=null){ result = Math.min(result,root.val-pre.val); } pre = root; //右 traversal(root.right); }} 这里给出迭代方法层序遍历的迭代方法和深度遍历的迭代方法不同的是，深度遍历每次while只出一个节点，层序遍历每次最外层的while都是获取len然后再次计算循环完一层 1234567891011121314151617181920212223242526272829class Solution { public int getMinimumDifference(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; int result = Integer.MAX_VALUE; if(root != null) stack.add(root); while(!stack.isEmpty()){ TreeNode curr = stack.peek(); if(curr != null){ stack.pop(); if(curr.right != null) stack.add(curr.right); stack.add(curr); stack.add(null); if(curr.left != null) stack.add(curr.left); }else{ stack.pop(); TreeNode temp = stack.pop(); if(pre != null) result = Math.min(result, temp.val - pre.val); pre = temp; } } return result; }} 501.二叉搜索树中的众数力扣题目链接 这个题目要找到出现频率最高的元素 如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。 12345678910111213141516171819202122232425262728293031323334public class Solution2 { Map&lt;Integer,Integer&gt; res = new HashMap&lt;&gt;(); public int[] findMode(TreeNode root) { int maxFrequency = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list.stream().mapToInt(Integer::intValue).toArray(); travleNode(root); for (Map.Entry&lt;Integer, Integer&gt; entry : res.entrySet()) { int number = entry.getKey(); int frequency = entry.getValue(); if (frequency &gt; maxFrequency) { // 如果找到了更大的频率，重置列表，并添加当前数字 maxFrequency = frequency; list.clear(); list.add(number); } else if (frequency == maxFrequency) { // 如果频率相同，添加当前数字到列表 list.add(number); } } int[] result = list.stream().mapToInt(Integer::intValue).toArray(); return result; } public void travleNode(TreeNode treeNode){ if(treeNode==null)return; if (treeNode.right!=null) travleNode(treeNode.right); res.put(treeNode.val, res.getOrDefault(treeNode.val, 0) + 1); if (treeNode.left!=null) travleNode(treeNode.left); }} 其次一个关键就是利用搜索二叉树的特性中序遍历是一个有序的，所以再次使用一下之前的pre和cur指针就可以判断有多少个相同了 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { ArrayList&lt;Integer&gt; resList; int maxCount; int count; TreeNode pre; public int[] findMode(TreeNode root) { resList = new ArrayList&lt;&gt;(); maxCount = 0; count = 0; pre = null; findMode1(root); int[] res = new int[resList.size()]; for (int i = 0; i &lt; resList.size(); i++) { res[i] = resList.get(i); } return res; } public void findMode1(TreeNode root) { if (root == null) { return; } findMode1(root.left); int rootValue = root.val; // 计数 if (pre == null || rootValue != pre.val) { count = 1; } else { count++; } // 更新结果以及maxCount if (count &gt; maxCount) { resList.clear(); resList.add(rootValue); maxCount = count; } else if (count == maxCount) { resList.add(rootValue); } pre = root; findMode1(root.right); }} 统一迭代法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int[] findMode(TreeNode root) { int count = 0; int maxCount = 0; TreeNode pre = null; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root != null) stack.add(root); while(!stack.isEmpty()){ TreeNode curr = stack.peek(); if(curr != null){ stack.pop(); if(curr.right != null) stack.add(curr.right); stack.add(curr); stack.add(null); if(curr.left != null) stack.add(curr.left); }else{ stack.pop(); TreeNode temp = stack.pop(); if(pre == null) count = 1; else if(pre != null &amp;&amp; pre.val == temp.val) count++; else count = 1; pre = temp; if(count == maxCount) res.add(temp.val); if(count &gt; maxCount){ maxCount = count; res.clear(); res.add(temp.val); } } } int[] result = new int[res.size()]; int i = 0; for (int x : res){ result[i] = x; i++; } return result; }} 236. 二叉树的最近公共祖先力扣题目链接 公共祖先一共有两种情况： 判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。 递归三部曲： 确定递归函数返回值以及参数 1public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { 因为需要返回最近的公共节点，所以返回值的类型是TreeNode ，TreeNode P和TreeNode q作为需要查找的参数也要放到传入参数中。这样就可以 确定终止条件 如果 root == q，或者 root == p，说明找到 q p ，则将其返回 123if (root == null || root == p || root == q) { // 递归结束条件 return root;} 确定单次循环 12345678910111213// 后序遍历TreeNode left = lowestCommonAncestor(root.left, p, q);TreeNode right = lowestCommonAncestor(root.right, p, q);if(left == null &amp;&amp; right == null) { // 若未找到节点 p 或 q return null;}else if(left == null &amp;&amp; right != null) { // 若找到一个节点 return right;}else if(left != null &amp;&amp; right == null) { // 若找到一个节点 return left;}else { // 若找到两个节点 return root;} 在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。 235. 二叉搜索树的最近公共祖先力扣题目链接 除了可以用二叉树的方法解决还可以利用二叉树的特性 1234567class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q); if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q); return root; }} 迭代法 1234567891011121314class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { while (true) { if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) { root = root.left; } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) { root = root.right; } else { break; } } return root; }} 701.二叉搜索树中的插入操作力扣题目链接 这个题目的插入可以随便的插入因为可以直接插入到叶子节点 别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱。 递归 12345678910111213141516171819202122class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) return new TreeNode(val); TreeNode newRoot = root; TreeNode pre = root; while (root != null) { pre = root; if (root.val &gt; val) { root = root.left; } else if (root.val &lt; val) { root = root.right; } } if (pre.val &gt; val) { pre.left = new TreeNode(val); } else { pre.right = new TreeNode(val); } return newRoot; }} 迭代 1234567891011121314151617181920class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if (root == NULL) { TreeNode* node = new TreeNode(val); return node; } TreeNode* cur = root; TreeNode* parent = root; // 这个很重要，需要记录上一个节点，否则无法赋值新节点 while (cur != NULL) { parent = cur; if (cur-&gt;val &gt; val) cur = cur-&gt;left; else cur = cur-&gt;right; } TreeNode* node = new TreeNode(val); if (val &lt; parent-&gt;val) parent-&gt;left = node;// 此时是用parent节点的进行赋值 else parent-&gt;right = node; return root; }} 450.删除二叉搜索树中的节点力扣题目链接 删除时遇到的五种情况 有以下五种情况： 第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 第五种情况有点难以理解，看下面动画： 1234567891011121314151617181920212223class Solution { public TreeNode deleteNode(TreeNode root, int key) { if (root == null) return root; if (root.val == key) { if (root.left == null) { return root.right; } else if (root.right == null) { return root.left; } else { TreeNode cur = root.right; while (cur.left != null) { cur = cur.left; } cur.left = root.left; root = root.right; return root; } } if (root.val &gt; key) root.left = deleteNode(root.left, key); if (root.val &lt; key) root.right = deleteNode(root.right, key); return root; }} 669. 修剪二叉搜索树力扣题目链接 给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。根据下图我们可以得只不能只根据一个节点不在修建区间就把他的子树完全删除。 因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作。 但是有返回值，更方便，可以通过递归函数的返回值来移除节点。 1234567891011121314151617class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) { return null; } if (root.val &lt; low) { return trimBST(root.right, low, high); } if (root.val &gt; high) { return trimBST(root.left, low, high); } // root在[low,high]范围内 root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }} 迭代法 12345678910111213141516171819202122232425262728293031323334class Solution { //iteration public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null) return null; while(root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)){ if(root.val &lt; low) root = root.right; else root = root.left; } TreeNode curr = root; //deal with root's left sub-tree, and deal with the value smaller than low. while(curr != null){ while(curr.left != null &amp;&amp; curr.left.val &lt; low){ curr.left = curr.left.right; } curr = curr.left; } //go back to root; curr = root; //deal with root's righg sub-tree, and deal with the value bigger than high. while(curr != null){ while(curr.right != null &amp;&amp; curr.right.val &gt; high){ curr.right = curr.right.left; } curr = curr.right; } return root; }} #108.将有序数组转换为二叉搜索树力扣题目链接 这个题目的重点是需要转换为平衡的二叉树 因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取","link":"/2024/02/19/Part6.3_Tree/"},{"title":"单调栈","text":"什么时候用单调栈呢？通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。 那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。 更直白来说，就是用一个栈来记录我们遍历过的元素，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。 单调栈里存放的元素是什么？单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。 单调栈里元素是递增呢？ 还是递减呢？如果求一个元素右边第一个更大元素，从栈头到栈底就是递增的，如果求一个元素右边第一个更小元素从栈头到栈底就是递减的。 使用单调栈主要有三个判断条件。 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 739. 每日温度力扣题目链接 因为要求右边第一个更大的元素所以使用递增的也就是放进去是小于栈顶的。 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) { // 递增栈 stack&lt;int&gt; st; vector&lt;int&gt; result(T.size(), 0); st.push(0); for (int i = 1; i &lt; T.size(); i++) { if (T[i] &lt; T[st.top()]) { // 情况一 st.push(i); } else if (T[i] == T[st.top()]) { // 情况二 st.push(i); } else { while (!st.empty() &amp;&amp; T[i] &gt; T[st.top()]) { // 情况三 result[st.top()] = i - st.top(); st.pop(); } st.push(i); } } return result; }}; 496.下一个更大元素 I力扣题目链接 根据题目就知道要使用单调栈，但是题目给了两个数组，要找对应数组中相等的值之后的下一个更大的元素， 所以我们先使用 unordered_map&lt;int, int&gt; umap; // key:下标元素，value：下标记录下标与元素这样可以方便我们搜索。 然后把各个元素比较的情况列出： 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 此时满足递增栈（栈头到栈底的顺序），所以直接入栈。 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！ 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。 1234567891011121314151617181920212223242526272829303132// 版本一class Solution {public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { stack&lt;int&gt; st; vector&lt;int&gt; result(nums1.size(), -1); if (nums1.size() == 0) return result; unordered_map&lt;int, int&gt; umap; // key:下标元素，value：下标 for (int i = 0; i &lt; nums1.size(); i++) { umap[nums1[i]] = i; } st.push(0); for (int i = 1; i &lt; nums2.size(); i++) { if (nums2[i] &lt; nums2[st.top()]) { // 情况一 st.push(i); } else if (nums2[i] == nums2[st.top()]) { // 情况二 st.push(i); } else { // 情况三 while (!st.empty() &amp;&amp; nums2[i] &gt; nums2[st.top()]) { if (umap.count(nums2[st.top()]) &gt; 0) { // 看map里是否存在这个元素 int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标 result[index] = nums2[i]; } st.pop(); } st.push(i); } } return result; }}; 503.下一个更大元素II力扣题目链接 不再是单一的数组而是循环了，可以用数组*2的方式解决 123456789101112131415161718192021222324252627282930// 版本一class Solution {public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) { // 拼接一个新的nums vector&lt;int&gt; nums1(nums.begin(), nums.end()); nums.insert(nums.end(), nums1.begin(), nums1.end()); // 用新的nums大小来初始化result vector&lt;int&gt; result(nums.size(), -1); if (nums.size() == 0) return result; // 开始单调栈 stack&lt;int&gt; st; st.push(0); for (int i = 1; i &lt; nums.size(); i++) { if (nums[i] &lt; nums[st.top()]) st.push(i); else if (nums[i] == nums[st.top()]) st.push(i); else { while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) { result[st.top()] = nums[i]; st.pop(); } st.push(i); } } // 最后再把结果集即result数组resize到原数组大小 result.resize(nums.size() / 2); return result; }}; 42. 接雨水力扣题目链接 这个图就是大厂面试经典题目，接雨水！ 最常青藤的一道题，面试官百出不厌！ 本文深度讲解如下两种方法： 双指针优化 单调栈 首先要明确，要按照行来计算，还是按照列来计算。 双指针优化我们可以使用按列的计算方式，这样我们需要找到列4两侧高度最高的列然后取他们的最小值，很显然可以看出水的高度与两侧最高的列有关。 我们提前用指针数组记录，i左边的最大位置 123456789maxLeft[0] = height[0];for (int i = 1; i &lt; size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]);}// 记录每个柱子右边柱子最大高度maxRight[size - 1] = height[size - 1];for (int i = size - 2; i &gt;= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]);} 123456789101112131415161718192021222324252627class Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.size() &lt;= 2) return 0; vector&lt;int&gt; maxLeft(height.size(), 0); vector&lt;int&gt; maxRight(height.size(), 0); int size = maxRight.size(); // 记录每个柱子左边柱子最大高度 maxLeft[0] = height[0]; for (int i = 1; i &lt; size; i++) { maxLeft[i] = max(height[i], maxLeft[i - 1]); } // 记录每个柱子右边柱子最大高度 maxRight[size - 1] = height[size - 1]; for (int i = size - 2; i &gt;= 0; i--) { maxRight[i] = max(height[i], maxRight[i + 1]); } // 求和 int sum = 0; for (int i = 0; i &lt; size; i++) { int count = min(maxLeft[i], maxRight[i]) - height[i]; if (count &gt; 0) sum += count; } return sum; }}; 单调栈解法因为单调栈可以用来计算右边第一个比自己大的元素，所以就可以按照行的方式来进行接雨水的计算。 遇到相同高度的柱子怎么办。 遇到相同的元素，更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。 例如 5 5 1 3 这种情况。如果添加第二个5的时候就应该将第一个5的下标弹出，把第二个5添加到栈中。 因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。 1234567891011121314151617181920212223242526272829class Solution {public: int trap(vector&lt;int&gt;&amp; height) { if (height.size() &lt;= 2) return 0; // 可以不加 stack&lt;int&gt; st; // 存着下标，计算的时候用下标对应的柱子高度 st.push(0); int sum = 0; for (int i = 1; i &lt; height.size(); i++) { if (height[i] &lt; height[st.top()]) { // 情况一 st.push(i); } if (height[i] == height[st.top()]) { // 情况二 st.pop(); // 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。 st.push(i); } else { // 情况三 while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) { // 注意这里是while int mid = st.top(); st.pop(); if (!st.empty()) { int h = min(height[st.top()], height[i]) - height[mid]; int w = i - st.top() - 1; // 注意减一，只求中间宽度 sum += h * w; } } st.push(i); } } return sum; }}; 84.柱状图中最大的矩形力扣题目链接 单调栈这个就是求右边第一个比自己小的元素，所以用从栈头到栈尾是递减的 栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度 这里有两个需要注意的点一个是在数组尾部加0避免递增数组的出现，另外一个就是int w = right - left - 1;也是向求雨水一样求得是横向的需要长乘宽。 12345678910111213141516171819202122232425262728293031323334class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { int result = 0; stack&lt;int&gt; st; heights.insert(heights.begin(), 0); // 数组头部加入元素0 heights.push_back(0); // 数组尾部加入元素0 st.push(0); // 第一个元素已经入栈，从下标1开始 for (int i = 1; i &lt; heights.size(); i++) { if (heights[i] &gt; heights[st.top()]) { // 情况一 st.push(i); } else if (heights[i] == heights[st.top()]) { // 情况二 st.pop(); // 这个可以加，可以不加，效果一样，思路不同 st.push(i); } else { // 情况三 while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) { // 注意是while int mid = st.top(); st.pop(); if (!st.empty()) { int left = st.top(); int right = i; int w = right - left - 1; int h = heights[mid]; result = max(result, w * h); } } st.push(i); } } return result; }}; 双指针现在双指针不是求得左侧侧最大高度了，左边第一个小于该柱子的下标，所以minRightIndex记录的第一个比他小的下标，这样才能保证长乘宽 1234567891011121314151617181920212223242526272829303132class Solution {public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) { vector&lt;int&gt; minLeftIndex(heights.size()); vector&lt;int&gt; minRightIndex(heights.size()); int size = heights.size(); // 记录每个柱子 左边第一个小于该柱子的下标 minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环 for (int i = 1; i &lt; size; i++) { int t = i - 1; // 这里不是用if，而是不断向左寻找的过程 while (t &gt;= 0 &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t]; minLeftIndex[i] = t; } // 记录每个柱子 右边第一个小于该柱子的下标 minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环 for (int i = size - 2; i &gt;= 0; i--) { int t = i + 1; // 这里不是用if，而是不断向右寻找的过程 while (t &lt; size &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t]; minRightIndex[i] = t; } // 求和 int result = 0; for (int i = 0; i &lt; size; i++) { int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1); result = max(sum, result); } return result; }}; 这里给出左边的标准输出 i-最小坐标 1-1 21 32 41 54 然后求和这里可以看到仍然有一个减一 也就是比如只算6的面积就是 左边第一个小于他的是2 右边第一个小于他的是4然后w=4-2-1=1然后h=6， 如果是56组成的矩形就是从5看左边第一个小于他的是1邮编第一个小于他的是4然后w=4-1-1=2然后h=5。","link":"/2024/03/10/Part10monotonic%20stack/"},{"title":"回溯","text":"定义回溯法也可以叫做回溯搜索法，它是一种搜索的方式。在二叉树系列中，我们已经不止一次，提到了回溯，回溯是递归的副产品，只要有递归就会有回溯。虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案只不过进行了剪枝。 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯法模板回溯三部曲。 回溯函数模板返回值以及参数 回溯算法中函数返回值一般为void。因为一般会把需要返回的值放到参数或者类中，当然也有需要返回值的用于提前终止。 1void backtracking(参数) 回溯函数终止条件 1234if (终止条件) { 存放结果; return;} 回溯搜索的遍历过程 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。所以主要是for循环式横向遍历，递归是纵向遍历。 12345for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果} 第77题. 组合力扣题目链接 题目要求在1-n之间返回k个数的组合，所以这时候就可以使用回溯， 将问题抽象成如图所示，因为是组合所以for循环式每取一个数少一个数 回溯法三部曲定义全局并确定返回值以及参数，这里的startIndex用来记录本层递归的开始位置，这样就不会重复选择同一个数如图 123vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合vector&lt;int&gt; path; // 用来存放符合条件单一结果void backtracking(int n, int k, int startIndex) 终止条件 1234if (path.size() == k) { result.push_back(path); return;} 单次循环 123456for (int i = startIndex; i &lt;= n; i++) { // 控制树的横向遍历 path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始 path.pop_back(); // 回溯，撤销处理的节点} 整体代码 1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合 vector&lt;int&gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) { if (path.size() == k) { result.push_back(path); return; } for (int i = startIndex; i &lt;= n; i++) { path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 } }public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; }}; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 时间复杂度分析：对于回溯算法我们需要 我们需要估计的是回溯法实际产生的节点数目，以此计算回溯法的时间复杂度。 我们的目的是要1-n之间返回k个数的组合，所以算法的时间复杂度主要取决于backtracking函数的执行次数。 2^n 代表了每个元素在每个组合中有两种可能性：要么出现，要么不出现；n 代表了在生成每一种组合时，你最多需要做 n 次操作来构建这个组合，这是由于组合的大小最多为 n。在最坏情况下，即每个候选数都被选择了，我们需要对候选数集合进行完整的遍历。这样，对于每一层递归，我们都需要遍历整个候选数集合， 因为每一个元素的状态无外乎取与不取，一共2^n种状态，每种状态都需要 o(n) 的构造时间，最终时间复杂度为 O(n * 2^n) 。 回溯虽然不是一个高效的方法，但是如果使用暴力那会更加复杂，比如5个数中取随机三个就需要三层的for循，可能更加难写。 当然还有一种剪枝操作，就是当如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。 1for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++) { // 优化的地方 k - path.size()还需要多少个数，n减去还需要的数不足以组成组合的话就通过for提前结束了，提前结束在了对剩余元素个数的判断。 216.组合总和III力扣题目链接 要求 不存在重复的数字，就是看1-9里有多少个组合 1234567891011121314151617181920212223242526272829class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; // 存放结果集 vector&lt;int&gt; path; // 符合条件的结果 void backtracking(int targetSum, int k, int sum, int startIndex) { if (sum &gt; targetSum) { // 剪枝操作 return; } if (path.size() == k) { if (sum == targetSum) result.push_back(path); return; // 如果path.size() == k 但sum != targetSum 直接返回 } for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) { // 剪枝 sum += i; // 处理 path.push_back(i); // 处理 backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex sum -= i; // 回溯 path.pop_back(); // 回溯 } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { result.clear(); // 可以不加 path.clear(); // 可以不加 backtracking(n, k, 0, 1); return result; }}; 时间复杂度: O(n * 2^n) 空间复杂度: O(n) 93.复原IP地址力扣题目链接 其实只要意识到这是切割问题，切割问题就可以使用回溯搜索法把所有可能性搜出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {private: vector&lt;string&gt; result;// 记录结果 // startIndex: 搜索的起始位置，pointNum:添加逗点的数量 void backtracking(string&amp; s, int startIndex, int pointNum) { if (pointNum == 3) { // 逗点数量为3时，分隔结束 // 判断第四段子字符串是否合法，如果合法就放进result中 if (isValid(s, startIndex, s.size() - 1)) { result.push_back(s); } return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法 s.insert(s.begin() + i + 1 , '.'); // 在i的后面插入一个逗点 pointNum++; backtracking(s, i + 2, pointNum); // 插入逗点之后下一个子串的起始位置为i+2 pointNum--; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉逗点 } else break; // 不合法，直接结束本层循环 } } // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法 bool isValid(const string&amp; s, int start, int end) { if (start &gt; end) { return false; } if (s[start] == '0' &amp;&amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i &lt;= end; i++) { if (s[i] &gt; '9' || s[i] &lt; '0') { // 遇到非数字字符不合法 return false; } num = num * 10 + (s[i] - '0'); if (num &gt; 255) { // 如果大于255了不合法 return false; } } return true; }public: vector&lt;string&gt; restoreIpAddresses(string s) { result.clear(); if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了 backtracking(s, 0, 0); return result; }}; 39. 组合总和力扣题目链接 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。 123456789101112131415161718192021222324252627282930// 版本一class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex) { if (sum &gt; target) { return; } if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i &lt; candidates.size(); i++) { sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, sum, i); // 不用i+1了，表示可以重复读取当前的数 sum -= candidates[i]; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { result.clear(); path.clear(); backtracking(candidates, target, 0, 0); return result; }}; 主要的点还是在单次循环上。 40.组合总和II力扣题目链接 这道题目和39.组合总和 (opens new window)如下区别： 本题candidates 中的每个数字在每个组合中只能使用一次。 本题数组candidates的元素是有重复的，而39.组合总和 (opens new window)是无重复元素的数组candidates 第二点是关键，比如我要怎么确定（1,2,3,2）选择的2是哪个2，并且要保证结果中不能出现两个（1,2） 都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。 Q：我们是要同一树层上使用过，还是同一树枝上使用过呢？ A：回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。 单独介绍一下单层循环逻辑：**如果candidates[i] == candidates[i - 1] 并且 used[i - 1] == false，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。 此时for循环里就应该做continue的操作。 我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下： used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 used[i - 1] == false，说明同一树层candidates[i - 1]使用过 123456789101112131415for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) { continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次 used[i] = false; sum -= candidates[i]; path.pop_back();} 整体代码 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; candidates, int target, int sum, int startIndex, vector&lt;bool&gt;&amp; used) { if (sum == target) { result.push_back(path); return; } for (int i = startIndex; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false) { continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次 used[i] = false; sum -= candidates[i]; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; used(candidates.size(), false); path.clear(); result.clear(); // 首先把给candidates排序，让其相同的元素都挨在一起。 sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0, 0, used); return result; }}; 131.分割回文串力扣题目链接 这个题目的关键是要把分割回文串变为一种组合问题并将切割问题，也可以抽象为一棵树形结构，如图： 1234567891011121314151617181920212223242526272829303132333435363738class Solution {private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 void backtracking (const string&amp; s, int startIndex) { // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) { result.push_back(path); return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isPalindrome(s, startIndex, i)) { // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); } else { // 不是回文，跳过 continue; } backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 } } bool isPalindrome(const string&amp; s, int start, int end) { for (int i = start, j = end; i &lt; j; i++, j--) { if (s[i] != s[j]) { return false; } } return true; }public: vector&lt;vector&lt;string&gt;&gt; partition(string s) { result.clear(); path.clear(); backtracking(s, 0); return result; }};","link":"/2024/02/19/Part7.1backtracking/"},{"title":"回溯2","text":"93.复原IP地址力扣题目链接 根据题目的意思是割3刀使所有部分是一个正确的ip地址所以除了判断有效的函数不同其他基本一致，但是终止条件式切3刀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {private: vector&lt;string&gt; result;// 记录结果 // startIndex: 搜索的起始位置，pointNum:添加逗点的数量 void backtracking(string&amp; s, int startIndex, int pointNum) { if (pointNum == 3) { // 逗点数量为3时，分隔结束 // 判断第四段子字符串是否合法，如果合法就放进result中 if (isValid(s, startIndex, s.size() - 1)) { result.push_back(s); } return; } for (int i = startIndex; i &lt; s.size(); i++) { if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法 s.insert(s.begin() + i + 1 , '.'); // 在i的后面插入一个逗点 pointNum++; backtracking(s, i + 2, pointNum); // 插入逗点之后下一个子串的起始位置为i+2 pointNum--; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉逗点 } else break; // 不合法，直接结束本层循环 } } // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法 bool isValid(const string&amp; s, int start, int end) { if (start &gt; end) { return false; } if (s[start] == '0' &amp;&amp; start != end) { // 0开头的数字不合法 return false; } int num = 0; for (int i = start; i &lt;= end; i++) { if (s[i] &gt; '9' || s[i] &lt; '0') { // 遇到非数字字符不合法 return false; } num = num * 10 + (s[i] - '0'); if (num &gt; 255) { // 如果大于255了不合法 return false; } } return true; }public: vector&lt;string&gt; restoreIpAddresses(string s) { result.clear(); if (s.size() &lt; 4 || s.size() &gt; 12) return result; // 算是剪枝了 backtracking(s, 0, 0); return result; }}; 时间复杂度: O(3^4)，IP地址最多包含4个数字，每个数字最多有3种可能的分割方式，则搜索树的最大深度为4，每个节点最多有3个子节点。 注意这个时间复杂度，这是递归方法的时间复杂度计算，就是针对于每个数字可能得情况我们进行遍历所以取得 78.子集力扣题目链接 如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！ 你看对弈每一个节点都是子集并不是只存储最后的结果 1234567891011121314151617181920212223class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) { result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己 if (startIndex &gt;= nums.size()) { // 终止条件可以不加 return; } for (int i = startIndex; i &lt; nums.size(); i++) { path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }}; 90.子集II力扣题目链接 在78题的基础上利用use去重 12345678910111213141516171819202122232425262728293031class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex, vector&lt;bool&gt;&amp; used) { result.push_back(path); for (int i = startIndex; i &lt; nums.size(); i++) { // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 // used[i - 1] == false，说明同一树层candidates[i - 1]使用过 // 而我们要对同一树层使用过的元素进行跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) { continue; } path.push_back(nums[i]); used[i] = true; backtracking(nums, i + 1, used); used[i] = false; path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); sort(nums.begin(), nums.end()); // 去重需要排序 backtracking(nums, 0, used); return result; }}; 当然也可以使用set来去除重复数据。 491.递增子序列力扣题目链接 这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。 这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的90.子集II (opens new window)。 就是因为太像了，更要注意差别所在，要不就掉坑里了！ 在90.子集II (opens new window)中我们是通过排序，再加一个标记数组来达到去重的目的。 而本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。 所以不能使用之前的去重逻辑！ 123456789101112131415161718192021222324252627282930// 版本一class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) { if (path.size() &gt; 1) { result.push_back(path); // 注意这里不要加return，要取树上的节点 } unordered_set&lt;int&gt; uset; // 使用set对本层元素进行去重 for (int i = startIndex; i &lt; nums.size(); i++) { if ((!path.empty() &amp;&amp; nums[i] &lt; path.back()) || uset.find(nums[i]) != uset.end()) { continue; } uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了 path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); } }public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); backtracking(nums, 0); return result; }}; 46.全排列力扣题目链接 因为是排列问题所以也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方所以我们也就不需要使用startIndex 但是但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示: 当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。 123456789101112131415161718192021222324252627class Solution {public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; }}; 47.全排列 II力扣题目链接 这道题目和46.全排列 (opens new window)的区别在与给定一个可包含重复数字的序列，要返回所有不重复的全排列。 123456789101112131415161718192021222324252627282930313233343536class Solution {private: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) { // 此时说明找到了一组 if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i &lt; nums.size(); i++) { // used[i - 1] == true，说明同一树枝nums[i - 1]使用过 // used[i - 1] == false，说明同一树层nums[i - 1]使用过 // 如果同一树层nums[i - 1]使用过则直接跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) { continue; } if (used[i] == false) { used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; } } }public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { result.clear(); path.clear(); sort(nums.begin(), nums.end()); // 排序 vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; }};","link":"/2024/02/19/Part7.2backtracking/"},{"title":"贪心算法1","text":"贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 这么说有点抽象，来举一个例子： 例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？ 指定每次拿最大的，最终结果就是拿走最大数额的钱。 每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。 贪心的主要思路就是通过手动模拟 455.分发饼干力扣题目链接 每个孩子给一块饼干，并满足他的胃口，所以我们应该对排序完的孩子和饼干，每次都把最小的且能满足其胃口额度饼干分给那个孩子。 1234567891011121314151617// 版本一class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = s.size() - 1; // 饼干数组的下标 int result = 0; for (int i = g.size() - 1; i &gt;= 0; i--) { // 遍历胃口 if (index &gt;= 0 &amp;&amp; s[index] &gt;= g[i]) { // 遍历饼干 result++; index--; } } return result; }}; 376. 摆动序列力扣题目链接 连续数字之间的差严格地在正数和负数之间交替，可以从原始序列中删除一些，所以我们的分析就是如何删除元素，图示举例我们删除元素删除单调的元素 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。 整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。 在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果prediff &lt; 0 &amp;&amp; curdiff &gt; 0 或者 prediff &gt; 0 &amp;&amp; curdiff &lt; 0 此时就有波动就需要统计。然后我们要做的分析情况 情况一：上下坡中有平坡 删左面三个 2 的规则，那么 当 prediff = 0 &amp;&amp; curdiff &lt; 0 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。 峰值记录规则改为(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) 情况二：数组首尾两端 可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？ 之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff &lt; 0 或者 &gt;0 也记为波谷。 那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图： 这样就解决了prediff 初始值的问题 12345678910111213141516171819// 版本一class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); int curDiff = 0; // 当前一对差值 int preDiff = 0; // 前一对差值 int result = 1; // 记录峰值个数，序列默认序列最右边有一个峰值 for (int i = 0; i &lt; nums.size() - 1; i++) { curDiff = nums[i + 1] - nums[i]; // 出现峰值 if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) { result++; } preDiff = curDiff; } return result; }}; 情况三：单调坡中有平坡 但是上述的代码并不能退解决单调坡上有平坡的图，因为我们在实时的更新我们的pre导致最后是0和上升。 123456789101112131415161718class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); int curDiff = 0; // 当前一对差值 int preDiff = 0; // 前一对差值 int result = 1; // 记录峰值个数，序列默认序列最右边有一个峰值 for (int i = 0; i &lt; nums.size() - 1; i++) { curDiff = nums[i + 1] - nums[i]; // 出现峰值 if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) { result++; preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff } } return result; }}; 53. 最大子序和力扣题目链接 找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。 从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。 123456789101112131415class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int result = INT32_MIN; int count = 0; for (int i = 0; i &lt; nums.size(); i++) { count += nums[i]; if (count &gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置） result = count; } if (count &lt;= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和 } return result; }}; 122.买卖股票的最佳时机 II力扣题目链接 这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。 如果想到其实最终利润是可以分解的，那么本题就很容易了！ 所以我们就可以计算每一天的利润，如果是负就不买这样 或者可以画一个图，我们只去上升部分在最低点买，最高点卖，总结出就是 12345678910class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int result = 0; for (int i = 1; i &lt; prices.size(); i++) { result += max(prices[i] - prices[i - 1], 0); } return result; }}; 55. 跳跃游戏力扣题目链接 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 所以我们的思路就是包括 比如我在位置0可以跳3步，那么我就要找保证位置0在内的0-3位置可以跳的最远的位置跳到那里去，然后继续计算， 123456789101112class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int cover = 0; if (nums.size() == 1) return true; // 只有一个元素，就是能达到 for (int i = 0; i &lt;= cover; i++) { // 注意这里是小于等于cover cover = max(i + nums[i], cover); if (cover &gt;= nums.size() - 1) return true; // 说明可以覆盖到终点了 } return false; }}; 45.跳跃游戏 II力扣题目链接 请你使用最少跳数调到目的地 本题要计算最少步数，那么就要想清楚什么时候步数才一定要加一呢？ 贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。 思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。 所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！ 这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。 123456789101112131415161718class Solution {public: int jump(vector&lt;int&gt;&amp; nums) { if (nums.size() == 1) return 0; int curDistance = 0; // 当前覆盖最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖最远距离下标 for (int i = 0; i &lt; nums.size(); i++) { nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖最远距离下标 if (i == curDistance) { // 遇到当前覆盖最远距离下标 ans++; // 需要走下一步 curDistance = nextDistance; // 更新当前覆盖最远距离下标（相当于加油了） if (nextDistance &gt;= nums.size() - 1) break; // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束 } } return ans; }}; 1005.K次取反后最大化的数组和力扣题目链接 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小 第二步：从前向后遍历，遇到负数将其变为正数，同时K– 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完 第四步：求和 12345678910111213141516171819class Solution {static bool cmp(int a, int b) { return abs(a) &gt; abs(b);}public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) { sort(A.begin(), A.end(), cmp); // 第一步 for (int i = 0; i &lt; A.size(); i++) { // 第二步 if (A[i] &lt; 0 &amp;&amp; K &gt; 0) { A[i] *= -1; K--; } } if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步 int result = 0; for (int a : A) result += a; // 第四步 return result; }}; 134. 加油站力扣题目链接 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 很容易想到如果油量加起来是负我们就重新开始，因为如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。 123456789101112131415161718class Solution {public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) { int curSum = 0; int totalSum = 0; int start = 0; for (int i = 0; i &lt; gas.size(); i++) { curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) { // 当前累加rest[i]和 curSum一旦小于0 start = i + 1; // 起始位置更新为i+1 curSum = 0; // curSum从0开始 } } if (totalSum &lt; 0) return -1; // 说明怎么走都不可能跑一圈了 return start; }}; 135. 分发糖果力扣题目链接 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。 那么遍历是用从后遍历还是从前遍历呢 如果左孩子比右孩子比较，rating[5]与rating[4]的比较 就不能用上 rating[5]与rating[6]的比较结果了 。 1234567891011121314151617181920class Solution {public: int candy(vector&lt;int&gt;&amp; ratings) { vector&lt;int&gt; candyVec(ratings.size(), 1); // 从前向后 for (int i = 1; i &lt; ratings.size(); i++) { if (ratings[i] &gt; ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1; } // 从后向前 for (int i = ratings.size() - 2; i &gt;= 0; i--) { if (ratings[i] &gt; ratings[i + 1] ) { candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1); } } // 统计结果 int result = 0; for (int i = 0; i &lt; candyVec.size(); i++) result += candyVec[i]; return result; }};","link":"/2024/02/21/Part8.1greedy/"},{"title":"动态规划1","text":"所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的， 动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。 但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。 动态规划的解题步骤 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。 然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了 可以自己先思考这三个问题： 这道题目我举例推导状态转移公式了么？ 我打印dp数组的日志了么？ 打印出来了dp数组和我想的一样么？ 509. 斐波那契数力扣题目链接 动规五部曲： 这里我们要用一个一维dp数组来保存递归的结果 确定dp数组以及下标的含义 dp[i]的定义为：第i个数的斐波那契数值是dp[i] 确定递推公式 为什么这是一道非常简单的入门题目呢？ 因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]; dp数组如何初始化 题目中把如何初始化也直接给我们了 确定遍历顺序 从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的 举例推导dp数组 按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列： 12345678910111213class Solution {public: int fib(int N) { if (N &lt;= 1) return N; vector&lt;int&gt; dp(N + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[N]; }}; 这里的每一步都很有必要。如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。 递归解法 1234567class Solution {public: int fib(int N) { if (N &lt; 2) return N; return fib(N - 1) + fib(N - 2); }}; 时间复杂度：O(2^n) 时间复杂度就等于递归的次数，一次递归都会有两个递归生成类似于二叉树的结构。所以是2^n 70. 爬楼梯力扣题目链接 这个问题相比上一个就是需要自己推到dp公式 确定dp数组以及下标的含义 dp[i]： 爬到第i层楼梯，有dp[i]种方法 确定递推公式 如何可以推出dp[i]呢？ 从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。 首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。 还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。 那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！ 所以dp[i] = dp[i - 1] + dp[i - 2] 。 在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。 这体现出确定dp数组以及下标的含义的重要性！ dp数组如何初始化 根据结果初始化 确定遍历顺序 从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的 举例推导dp数组 举例当n为5的时候，dp table（dp数组）应该是这样的 12345678910111213class Solution {public: int climbStairs(int n) { if (n &lt;= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针 vector&lt;int&gt; dp(n + 1); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { // 注意i是从3开始的 dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }}; 746. 使用最小花费爬楼梯力扣题目链接 123456789101112class Solution {public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size() + 1); dp[0] = 0; // 默认第一步都是不花费体力的 dp[1] = 0; for (int i = 2; i &lt;= cost.size(); i++) { dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); } return dp[cost.size()]; }};","link":"/2024/02/21/Part9.1DP/"},{"title":"动态规划3","text":"完全背包有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 代码上两者最大的不同就是遍历顺序 一维数组的01背包要求先遍历物品，再遍历容量并且要按照从大到小的顺序进行容量遍历。这样可以保证前边数据在使用dp[i-j]时使用的是上一阶段数据，也就是dp[i]和dp[i-j]都是上一轮的而不是在这一轮实时更新的 而完全背包就不一样我就是可以多次的添加，所以把倒序变了回来。 1234567// 先遍历物品，再遍历背包for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！因为没有了倒序所以就无所谓了。 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。 遍历物品在外层循环，遍历背包容量在内层循环，状态如图： 遍历背包容量在外层循环，遍历物品在内层循环，状态如图： 518.零钱兑换II力扣题目链接 面额的数目无限，那么就是完全背包，并且要求有多少种方案，那么就是一个组合的问题，当然可以通过回溯的方法搜索但是，太大了，所以可以通过dp解决 直接动态规划五部曲 确定dp数组以及下标的含义 意义就是对于j的钱最多有dp[j]种方法凑齐 递推公式 对于每一个钱都有取和不取的情况，所以在总金额j的时候就是需要把所有金额的可能情况算一遍比如j=5 硬币为123，我们遍历就是对拿了1的时候dp[4]有多少种情况，拿了2dp[3]有多少种情况，所以递推公式为dp[j] += dp[j - coins[i]] dp数组如何初始化 首先我们得保证最开始不为0 ，那么最开始为多少合适呢可以从dp[1]开始看，如果dp[1]=1那么不就是dp[0]=1 确定遍历顺序 因为没有了从后遍历那么先遍历背包还是物品就变得随意了，但是我们的题目要求的是凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。 我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。 12345for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j &lt;= amount; j++) { // 遍历背包容量 dp[j] += dp[j - coins[i]]; }} 假设：coins[0] = 1，coins[1] = 5。 然而此时是先遍历的物品所以物品只使用一次 物品只有coins[0] 时，dp[6]时使用了1，那么dp[5]有多少方案1中111111 然后当dp[6]使用到5时就才使一个完全体 那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。 所以这种遍历顺序中dp[j]里计算的是组合数！ 如果把两个for交换顺序，代码如下： 12345for (int j = 0; j &lt;= amount; j++) { // 遍历背包容量 for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品 if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]]; }} 我们来分析dp[6]因为遍历了物品如果使用了1那么dp[5]有多少方案，如果使用了5那么dp[1]有多少方案 背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。 此时dp[j]里算出来的就是排列数！ 记住先遍历物品组合后遍历物品排列。 12345678910111213class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j &lt;= amount; j++) { // 遍历背包 dp[j] += dp[j - coins[i]]; } } return dp[amount]; }}; 70. 爬楼梯（进阶版）卡码网：57. 爬楼梯 每次你可以爬至多m (1 &lt;= m &lt; n)个台阶 每次你可以取1-m任意的数 所以就是完全背包 确定dp数组以及下标的含义 dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。 确定递推公式 dp[i] += dp[i - j] dp数组如何初始化 这种累加一般都初始化为1 确定遍历顺序 这是求得排列问题所以后遍历物品 一些说明： i=1就是？都可以 j=1是最少一层 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { int n, m; while (cin &gt;&gt; n &gt;&gt; m) { vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; i++) { // 遍历背包 for (int j = 1; j &lt;= m; j++) { // 遍历物品 if (i - j &gt;= 0) dp[i] += dp[i - j]; } } cout &lt;&lt; dp[n] &lt;&lt; endl; }} 322. 零钱兑换力扣题目链接 递推公式 dp[j] = min(dp[j - coins[i]] + 1, dp[j]); dp数组如何初始化 考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。 确定遍历顺序 本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。 所以本题并不强调集合是组合还是排列。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 12345678910111213141516class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) { // 遍历物品 for (int j = coins[i]; j &lt;= amount; j++) { // 遍历背包 if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过 dp[j] = min(dp[j - coins[i]] + 1, dp[j]); } } } if (dp[amount] == INT_MAX) return -1; return dp[amount]; }}; 279.完全平方数力扣题目链接 确定dp数组（dp table）以及下标的含义 dp[j]：和为j的完全平方数的最少数量为dp[j] 确定递推公式 dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。 初始化 所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。 确定遍历顺序 12345678910111213class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &lt;= n; i++) { // 遍历背包 for (int j = 1; j * j &lt;= i; j++) { // 遍历物品 dp[i] = min(dp[i - j * j] + 1, dp[i]); } } return dp[n]; }}; 139.单词拆分力扣题目链接 回溯算法：分割回文串 (opens new window)：是枚举分割后的所有子串，判断是否回文。 本道是枚举分割所有字符串，判断是否在字典里出现过。 那么这里我也给出回溯法C++代码： 1234567891011121314151617181920class Solution {private: bool backtracking (const string&amp; s, const unordered_set&lt;string&gt;&amp; wordSet, int startIndex) { if (startIndex &gt;= s.size()) { return true; } for (int i = startIndex; i &lt; s.size(); i++) { string word = s.substr(startIndex, i - startIndex + 1); if (wordSet.find(word) != wordSet.end() &amp;&amp; backtracking(s, wordSet, i + 1)) { return true; } } return false; }public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); return backtracking(s, wordSet, 0); }}; 时间复杂度：O(2^n)，因为每一个单词都有两个状态，切割和不切割 空间复杂度：O(n)，算法递归系统调用栈的空间 但是超时 背包问题单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。 确定dp数组以及下标的含义 dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 确定递推公式 ​ 如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。 ​ 所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。 dp数组如何初始化 ​ 从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。 确定遍历顺序 题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。 还要讨论两层for循环的前后顺序。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 而本题其实我们求的是排列数，为什么呢。 拿 s = “applepenapple”, wordDict = [“apple”, “pen”] 举例。 “apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。 “apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是强调物品之间顺序。 所以说，本题一定是 先遍历背包，再遍历物品。 1234567891011121314151617class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i &lt;= s.size(); i++) { // 遍历背包 for (int j = 0; j &lt; i; j++) { // 遍历物品 string word = s.substr(j, i - j); //substr(起始位置，截取的个数) if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) { dp[i] = true; } } } return dp[s.size()]; }}; 难点1在于想到用背包解决：单词s能不能被完全找到 难点2一定要先遍历背包 难点3遍历物品时把当前容量拆开看看能不能被填满也就是for (int j = 0; j &lt; i; j++)难想 拓展：关于遍历顺序，再给大家讲一下为什么 先遍历物品再遍历背包不行。 这里可以给出先遍历物品再遍历背包的代码： 123456789101112131415161718192021class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; for (int j = 0; j &lt; wordDict.size(); j++) { // 物品 for (int i = wordDict[j].size(); i &lt;= s.size(); i++) { // 背包 string word = s.substr(i - wordDict[j].size(), wordDict[j].size()); // cout &lt;&lt; word &lt;&lt; endl; if ( word == wordDict[j] &amp;&amp; dp[i - wordDict[j].size()]) { dp[i] = true; } // for (int k = 0; k &lt;= s.size(); k++) cout &lt;&lt; dp[k] &lt;&lt; &quot; &quot;; //这里打印 dp数组的情况 // cout &lt;&lt; endl; } } return dp[s.size()]; }}; 使用用例：s = “applepenapple”, wordDict = [“apple”, “pen”]，对应的dp数组状态如下： 最后dp[s.size()] = 0 即 dp[13] = 0 ，而不是1，因为先用 “apple” 去遍历的时候，dp[8]并没有被赋值为1 （还没用”pen”），所以 dp[13]也不能变成1。 除非是先用 “apple” 遍历一遍，再用 “pen” 遍历，此时 dp[8]已经是1，最后再用 “apple” 去遍历，dp[13]才能是1。 多重背包代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main() { int bagWeight,n; cin &gt;&gt; bagWeight &gt;&gt; n; vector&lt;int&gt; weight(n, 0); vector&lt;int&gt; value(n, 0); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) cin &gt;&gt; weight[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; value[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; nums[i]; vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; n; i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) { // 遍历个数 dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]); } } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;} 背包问题总结 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 其实这五部里哪一步都很关键，但确定递推公式和确定遍历顺序都具有规律性和代表性，所以下面我从这两点来对背包问题做一做 背包递推公式问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下： 动态规划：416.分割等和子集(opens new window) 动态规划：1049.最后一块石头的重量 II(opens new window) 问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下： 动态规划：494.目标和(opens new window) 动态规划：518. 零钱兑换 II(opens new window) 动态规划：377.组合总和Ⅳ(opens new window) 动态规划：70. 爬楼梯进阶版（完全背包）(opens new window) 问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下： 动态规划：474.一和零(opens new window) 问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下： 动态规划：322.零钱兑换(opens new window) 动态规划：279.完全平方数(opens new window) 遍历顺序01背包在动态规划：关于01背包问题，你该了解这些！ (opens new window)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。 和动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。 一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！ 完全背包说完01背包，再看看完全背包。 在动态规划：关于完全背包，你该了解这些！ (opens new window)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。 但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 相关题目如下： 求组合数：动态规划：518.零钱兑换II(opens new window) 求排列数：动态规划：377. 组合总和 Ⅳ (opens new window)、动态规划：70. 爬楼梯进阶版（完全背包）(opens new window) 如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下： 求最小数：动态规划：322. 零钱兑换 (opens new window)、动态规划：279.完全平方数(opens new window) 对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了。 总结总结这篇背包问题总结篇是对背包问题的高度概括，讲最关键的两部：递推公式和遍历顺序，结合力扣上的题目全都抽象出来了。 而且每一个点，我都给出了对应的力扣题目。 最后如果你想了解多重背包，可以看这篇动态规划：关于多重背包，你该了解这些！ (opens new window)，力扣上还没有多重背包的题目，也不是面试考察的重点。 如果把我本篇总结出来的内容都掌握的话，可以说对背包问题理解的就很深刻了，用来对付面试中的背包问题绰绰有余！","link":"/2024/02/28/Part9.3DP/"},{"title":"贪心算法2","text":"860.柠檬水找零 力扣题目链接 模拟的一个知识：账单是20的情况要优先消耗一个10和一个5因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！ 1234567891011121314151617181920212223242526272829class Solution {public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five = 0, ten = 0, twenty = 0; for (int bill : bills) { // 情况一 if (bill == 5) five++; // 情况二 if (bill == 10) { if (five &lt;= 0) return false; ten++; five--; } // 情况三 if (bill == 20) { // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着 if (five &gt; 0 &amp;&amp; ten &gt; 0) { five--; ten--; twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零 } else if (five &gt;= 3) { five -= 3; twenty++; // 同理，这行代码也可以删了 } else return false; } } return true; }}; 452. 用最少数量的箭引爆气球力扣题目链接 如何使用最少的弓箭呢？ 直觉上来看，貌似只射重叠最多的气球，用的弓箭一定最少，那么有没有当前重叠了三个气球，我射两个，留下一个和后面的一起射这样弓箭用的更少的情况呢？ 尝试一下举反例，发现没有这种情况。 那么就试一试贪心吧！局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。 我们目的是引爆所有气球，所以我们就把排序后的结果，找到最多可以重叠的个数然后加一把箭 如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭。 12345678910111213141516171819202122class Solution {private: static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { return a[0] &lt; b[0]; }public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) { if (points.size() == 0) return 0; sort(points.begin(), points.end(), cmp); int result = 1; // points 不为空至少需要一支箭 for (int i = 1; i &lt; points.size(); i++) { if (points[i][0] &gt; points[i - 1][1]) { // 气球i和气球i-1不挨着，注意这里不是&gt;= result++; // 需要一支箭 } else { // 气球i和气球i-1挨着 points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界 } } return result; }}; 注意题目中说的是：满足 xstart ≤ x ≤ xend，则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆， 所以代码中 if (points[i][0] &gt; points[i - 1][1]) 不能是&gt;= 435. 无重叠区间力扣题目链接 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 思路上和上一题一模一样，但是按照左边界排序还是右边界排序呢。按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。 1234567891011121314151617181920class Solution {public: // 按照区间右边界排序 static bool cmp (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { return a[1] &lt; b[1]; } int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.size() == 0) return 0; sort(intervals.begin(), intervals.end(), cmp); int count = 1; // 记录非交叉区间的个数 int end = intervals[0][1]; // 记录区间分割点 for (int i = 1; i &lt; intervals.size(); i++) { if (end &lt;= intervals[i][0]) { end = intervals[i][1]; count++; } } return intervals.size() - count; }}; 左边界排序我们就是直接求 重叠的区间，count为记录重叠区间数。 1234567891011121314151617181920class Solution {public: static bool cmp (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) { return a[0] &lt; b[0]; // 改为左边界排序 } int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if (intervals.size() == 0) return 0; sort(intervals.begin(), intervals.end(), cmp); int count = 0; // 注意这里从0开始，因为是记录重叠区间 int end = intervals[0][1]; // 记录区间分割点 for (int i = 1; i &lt; intervals.size(); i++) { if (intervals[i][0] &gt;= end) end = intervals[i][1]; // 无重叠的情况 else { // 重叠情况 end = min(end, intervals[i][1]); count++; } } return count; }}; 763.划分字母区间力扣题目链接 这个题目的重点是想到用数组统计每一个字符最后出现的位置 然后比较每个对应字符是否是最后出现的位置。 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; partitionLabels(string S) { int hash[27] = {0}; // i为字符，hash[i]为字符出现的最后位置 for (int i = 0; i &lt; S.size(); i++) { // 统计每一个字符最后出现的位置 hash[S[i] - 'a'] = i; } vector&lt;int&gt; result; int left = 0; int right = 0; for (int i = 0; i &lt; S.size(); i++) { right = max(right, hash[S[i] - 'a']); // 找到字符出现的最远边界 if (i == right) { result.push_back(right - left + 1); left = i + 1; } } return result; }}; 738.单调递增的数字力扣题目链接 12345678910111213141516171819class Solution {public: int monotoneIncreasingDigits(int N) { string strNum = to_string(N); // flag用来标记赋值9从哪里开始 // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行 int flag = strNum.size(); for (int i = strNum.size() - 1; i &gt; 0; i--) { if (strNum[i - 1] &gt; strNum[i] ) { flag = i; strNum[i - 1]--; } } for (int i = flag; i &lt; strNum.size(); i++) { strNum[i] = '9'; } return stoi(strNum); }}; 968.监控二叉树力扣题目链接 左右中后序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {private: int result; int traversal(TreeNode* cur) { // 空节点，该节点有覆盖 if (cur == NULL) return 2; int left = traversal(cur-&gt;left); // 左 int right = traversal(cur-&gt;right); // 右 // 情况1 // 左右节点都有覆盖 if (left == 2 &amp;&amp; right == 2) return 0; // 情况2 // left == 0 &amp;&amp; right == 0 左右节点无覆盖 // left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖 // left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头 // left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖 // left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖 if (left == 0 || right == 0) { result++; return 1; } // 情况3 // left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖 // left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头 // left == 1 &amp;&amp; right == 1 左右节点都有摄像头 // 其他情况前段代码均已覆盖 if (left == 1 || right == 1) return 2; // 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解 // 这个 return -1 逻辑不会走到这里。 return -1; }public: int minCameraCover(TreeNode* root) { result = 0; // 情况4 if (traversal(root) == 0) { // root 无覆盖 result++; } return result; }};","link":"/2024/02/21/Part8.2greedy/"},{"title":"动态规划4","text":"198.打家劫舍力扣题目链接 分析：偷相邻的会报警，所以问题就是如何在不偷相邻的房间然后达到最大。 仔细一想，当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。这个问题很容易感觉到，当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。 确定dp数组（dp table）以及下标的含义 **dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。 确定递推公式 如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点） 决定dp[i]的因素就是第i房间偷还是不偷。 dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); dp数组如何初始化 递推公式的基础就是dp[0] 和 dp[1]从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]); 确定遍历顺序 dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 举例推导dp数组 以示例二，输入[2,7,9,3,1]为例。 代码 1234567891011121314class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[nums.size() - 1]; }}; 213.打家劫舍II力扣题目链接 现在问题进化房间组成一个环，也就是最后一个和第一个是相邻的房间 所以我们要画出问题的状态，并且尽量的屡成一条线 对于一个数组，成环的话主要有如下三种情况： 情况一：考虑不包含首尾元素 情况二：考虑包含首元素，不包含尾元素 情况三：考虑包含尾元素，不包含首元素 而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。 因为假设现在是情况2 但是下标对应的值num[0]&lt;[1]就会自动转换成情况一，所以最后就是考虑两种情况。 12345678910111213141516171819202122// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; int result1 = robRange(nums, 0, nums.size() - 2); // 情况二 int result2 = robRange(nums, 1, nums.size() - 1); // 情况三 return max(result1, result2); } // 198.打家劫舍的逻辑 int robRange(vector&lt;int&gt;&amp; nums, int start, int end) { if (end == start) return nums[start]; vector&lt;int&gt; dp(nums.size()); dp[start] = nums[start]; dp[start + 1] = max(nums[start], nums[start + 1]); for (int i = start + 2; i &lt;= end; i++) { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); } return dp[end]; }}; 337.打家劫舍 III力扣题目链接 家庭呈现树形排列，只能偷父与子中的一个 先是一个优化的回溯方法 1234567891011121314151617class Solution {public: unordered_map&lt;TreeNode* , int&gt; umap; // 记录计算过的结果 int rob(TreeNode* root) { if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return root-&gt;val; if (umap[root]) return umap[root]; // 如果umap里已经有记录则直接返回 // 偷父节点 int val1 = root-&gt;val; if (root-&gt;left) val1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); // 跳过root-&gt;left if (root-&gt;right) val1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 跳过root-&gt;right // 不偷父节点 int val2 = rob(root-&gt;left) + rob(root-&gt;right); // 考虑root的左右孩子 umap[root] = max(val1, val2); // umap记录一下结果 return max(val1, val2); }}; 然后就是以树形dp的方式来解决这个题目 这个题目算是树形DP的入门题目 确定递归函数的参数和返回值 这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。 dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。 为什么是长度为2呢因为只用判断父与子之间的关系。 确定终止条件 在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回 1if (cur == NULL) return vector&lt;int&gt;{0, 0}; 确定遍历顺序 首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。因为我们需要判断左右节点与根节点的关系，如果是后序遍历的话，判断的过程就放在了 通过递归左节点，得到左节点偷与不偷的金钱。 通过递归右节点，得到右节点偷与不偷的金钱。 确定单层递归的逻辑 如果是偷当前节点，那么左右孩子就不能偷，val1 = cur-&gt;val + left[0] + right[0]; （下标为0记录的是不偷获取的最大值） 如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]); 最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱} 代码如下： 12345678vector&lt;int&gt; left = robTree(cur-&gt;left); // 左vector&lt;int&gt; right = robTree(cur-&gt;right); // 右// 偷curint val1 = cur-&gt;val + left[0] + right[0];// 不偷curint val2 = max(left[0], left[1]) + max(right[0], right[1]);return {val2, val1}; 123456789101112131415161718class Solution {public: int rob(TreeNode* root) { vector&lt;int&gt; result = robTree(root); return max(result[0], result[1]); } // 长度为2的数组，0：不偷，1：偷 vector&lt;int&gt; robTree(TreeNode* cur) { if (cur == NULL) return vector&lt;int&gt;{0, 0}; vector&lt;int&gt; left = robTree(cur-&gt;left); vector&lt;int&gt; right = robTree(cur-&gt;right); // 偷cur，那么就不能偷左右节点。 int val1 = cur-&gt;val + left[0] + right[0]; // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return {val2, val1}; }}; 所以树形DO只不过平时我们习惯了在一维数组或者二维数组上推导公式，一下子换成了树，就需要对树的遍历方式足够了解！ 121. 买卖股票的最佳时机力扣题目链接 买股票的题用贪心做也可以，用DP做也可以。 贪心算法 123456789101112class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int low = INT_MAX; int result = 0; for (int i = 0; i &lt; prices.size(); i++) { low = min(low, prices[i]); // 取最左最小价格 result = max(result, prices[i] - low); // 直接取最大区间利润 } return result; }}; 在寻找low值的同时就计算了result； 动态规划动规五部曲分析如下： 确定dp数组（dp table）以及下标的含义 动态规划中最难想的就是DP数组的意义，买卖股票的题我们设置一个二维的DP数组其中 dp[i][0] 表示第i天持有股票所得最多现金 注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态，对于一次买卖来说持有就代表着，当前最低的买入价格。而每天的持有又依赖于上一天的持有，对于能明确这种依赖关系的最好就使用DP实现。 dp[i][1] 表示第i天不持有股票所得最多现金 可以由两个状态推出来 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1] 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0] 所以递推公式是：dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); dp数组如何初始化 dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -= prices[0];这个完全是为了可以满足递推关系所写，没有实际的意义。 dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] = 0; 确定遍历顺序 从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); if (len == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); } return dp[len - 1][1]; } 122.买卖股票的最佳时机II力扣题目链接 可以进行多次买卖，但是不能同时参与多笔交易 那么我每次卖了之后我持有的资金就会变化，所以不同主要体现在DP公式上dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); 1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); } return dp[len - 1][1]; }}; 123.买卖股票的最佳时机III力扣题目链接 最多可以完成两笔交易,和前边的可以进行多次交易形成对比，多次交易持有的资金是上一次的卖出资金，那么最多进行两次交易的第二次交易是在第一次卖出的基础上，更新持有的资金。 接来下我用动态规划五部曲详细分析一下： 确定dp数组以及下标的含义 一天一共就有五个状态， 没有操作 （其实我们也可以不设置这个状态） 第一次持有股票 第一次不持有股票 第二次持有股票 第二次不持有股票 dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。 需要注意：dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票。 例如 dp[i][1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i][1] 延续买入股票的这个状态。 确定递推公式 达到dp[i][1]状态，有两个具体操作： 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i] 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1] 这两个操作中一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]); 同理dp[i][2]也有两个操作： 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i] 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2] 所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]) 同理可推出剩下状态部分： dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); dp数组如何初始化 第0天做第一次买入的操作，dp[0][1] = -prices[0]; 第0天做第一次卖出的操作，这个初始值应该是多少呢？ 此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0; 第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？ 第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。 所以第二次买入操作，初始化为：dp[0][3] = -prices[0]; 同理第二次卖出初始化dp[0][4] = 0; 确定遍历顺序 从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。 举例推导dp数组 以输入[1,2,3,4,5]为例 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; prices.size(); i++) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]); dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); } return dp[prices.size() - 1][4]; }}; 188.买卖股票的最佳时机IV力扣题目链接 hard难度题，最多可以完成 k 笔交易，和上一题的分析类似。 123456789101112131415161718class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(2 * k + 1, 0)); for (int j = 1; j &lt; 2 * k; j += 2) { dp[0][j] = -prices[0]; } for (int i = 1;i &lt; prices.size(); i++) { for (int j = 0; j &lt; 2 * k - 1; j += 2) { dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]); dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]); } } return dp[prices.size() - 1][2 * k]; }}; 309.最佳买卖股票时机含冷冻期力扣题目链接 是因为出现冷冻期之后，状态其实是比较复杂度，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 但是我们可以区分出如下四个状态： 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有） 不持有股票状态，这里就有两种卖出股票状态 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作） 状态三：今天卖出股票 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！ 根绝这个图我们可以看出转移到持有股票状态现在有两种方式，一种还是之前的卖出状态，还多了一个冷冻状态，代表买入的前一天是冷冻状态。 确定递推公式 达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作： 操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0] 操作二：今天买入了，有两种情况 前一天是冷冻期（状态四），dp[i - 1][3] - prices[i] 前一天是保持卖出股票的状态（状态二），dp[i - 1][1] - prices[i] 那么dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]); 达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作： 操作一：前一天就是状态二 操作二：前一天是冷冻期（状态四） dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); 达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作： 昨天一定是持有股票状态（状态一），今天卖出 即：dp[i][2] = dp[i - 1][0] + prices[i]; 达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作： 昨天卖出了股票（状态三） dp[i][3] = dp[i - 1][2]; 综上分析，递推代码如下： 1234dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);dp[i][2] = dp[i - 1][0] + prices[i];dp[i][3] = dp[i - 1][2]; 经过这样的拆分，就可以把冷冻区融进了DP数组 dp数组如何初始化 这里主要讨论一下第0天如何初始化。 如果是持有股票状态（状态一）那么：dp[0][0] = -prices[0]，一定是当天买入股票。 保持卖出股票状态（状态二），这里其实从 「状态二」的定义来说 ，很难明确应该初始多少，这种情况我们就看递推公式需要我们给他初始成什么数值。 如果i为1，第1天买入股票，那么递归公式中需要计算 dp[i - 1][1] - prices[i] ，即 dp[0][1] - prices[1]，那么大家感受一下 dp[0][1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。 今天卖出了股票（状态三），同上分析，dp[0][2]初始化为0，dp[0][3]也初始为0。 12345678910111213141516class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if (n == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(4, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i &lt; n; i++) { dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])); dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; } return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2])); }}; 714.买卖股票的最佳时机含手续费力扣题目链接 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i &lt; n; i++) { dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); } return max(dp[n - 1][0], dp[n - 1][1]); }}; 主要的不同体现在返回值可能不买才使最优的操作，所以要在dp[n - 1][0], dp[n - 1][1]选一个最大的。","link":"/2024/03/03/Part9.4DP/"},{"title":"动态规划2","text":"背包问题01 背包有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 举一个例子： 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 问背包能背的物品最大价值是多少？ 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。i代表物品j代表容量。 确定递推公式 再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 那么可以有两个方向推出来dp[i][j]， 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。) 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组初始化 首先是当j=0时是放不进去任务物品的，然后根据递推公式是由i-1 得出的，所以要得出所有的i=0时的值。由第一个物品重量为1所以之后的值物品0的价值可以放到1-4 确定遍历顺序 从两个角度都可以理解，从先遍历物品的角度理解就是对于0-n的物品随着背包容量遍历的最大价值变化 从先遍历重量是对于0-n的重量随着可放物品的多少最大价值的变化。最主要的原因还是递推公式只会用到左上方的数字 举例推导dp数组 代码 12345678910111213141516171819202122232425262728void test_2_wei_bag_problem1() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagweight = 4; // 二维数组 vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0)); // 初始化 for (int j = weight[0]; j &lt;= bagweight; j++) { dp[0][j] = value[0]; } // weight数组的大小 就是物品个数 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); } } cout &lt;&lt; dp[weight.size() - 1][bagweight] &lt;&lt; endl;}int main() { test_2_wei_bag_problem1();} 01背包理论基础（滚动数组）对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 唯一的变化是遍历顺序因为要一直使用二维数组中左上角的数组， 所以为了避免影响后续的数组，我们需要从后往前遍历。因为背包是个左闭右闭的问题所以要申请bagWeight + 1的容量。 123456789101112131415161718void test_1_wei_bag_problem() { vector&lt;int&gt; weight = {1, 3, 4}; vector&lt;int&gt; value = {15, 20, 30}; int bagWeight = 4; // 初始化 vector&lt;int&gt; dp(bagWeight + 1, 0); for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } } cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;}int main() { test_1_wei_bag_problem();} 416. 分割等和子集力扣题目链接 使得两个子集的元素和相等。那么我们是否可以这么理解我们希望他两端等于sum/2 动规五部曲分析如下： 确定dp数组以及下标的含义 01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。 本题中每一个元素的数值既是重量，也是价值。 **套到本题，dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]**。 为什么求的是最大价值呢，因为背包的容量是j如果装进去的东西的重量也是j的话，那么他就是达到了最大重量。 那么如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] == target 的时候，背包就装满了。 确定递推公式 递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); dp数组如何初始化 在01背包，一维dp如何初始化，已经讲过， 从dp[j]的定义来看，首先dp[0]一定是0。 如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。 这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了。 本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。 代码如下： 123// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了vector&lt;int&gt; dp(10001, 0); 确定遍历顺序 如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！ 举例推导dp数组 dp[j]的数值一定是小于等于j的。 如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。 用例1，输入[1,5,11,5] 为例，如图： 最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。 12345678910111213141516171819202122232425262728class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = 0; // dp[i]中的i表示背包内总和 // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200 // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了 vector&lt;int&gt; dp(10001, 0); for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; } // 也可以使用库函数一步求和 // int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; int target = sum / 2; // 开始 01背包 for(int i = 0; i &lt; nums.size(); i++) { for(int j = target; j &gt;= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); } } // 集合中的元素正好可以凑成总和target if (dp[target] == target) return true; return false; }}; 1049.最后一块石头的重量II力扣题目链接 这个题目看起来和上一题挺不一样，但是从另一角度如果三块石头分别是 5，4，1。那么最后的石头重量就是0达到最小 所以也是把上述的数组分成两堆。两个代码不一样的部分就是少了前边不是一样的数组 123456789101112131415class Solution {public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) { vector&lt;int&gt; dp(15001, 0); int sum = 0; for (int i = 0; i &lt; stones.size(); i++) sum += stones[i]; int target = sum / 2; for (int i = 0; i &lt; stones.size(); i++) { // 遍历物品 for (int j = target; j &gt;= stones[i]; j--) { // 遍历背包 dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); } } return sum - dp[target] - dp[target]; }}; 494.目标和力扣题目链接 本问题从解决思路上来说就是一个回溯的问题，我们的目标是寻找最后和为target的值，所以就是从 本题要如何使表达式结果为target，既然为target，那么就一定有 left组合 - right组合 = target。left + right = sum，而sum是固定的。right = sum - left公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。 target是固定的，sum是固定的，left就可以求出来。 此时问题就是在集合nums中找出和为left的组合。 动态规划 确定dp数组以及下标的含义 我们可以把left设为背包容量，看能否找到填满j（包括j）这么大容积的包，有dp[j]种方法 确定递推公式 有哪些来源可以推出dp[j]呢？ 只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。 例如：dp[j]，j 为5， 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包 那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。 1dp[j] += dp[j - nums[i]] dp数组如何初始化 如果数组[0] ，target = 0，那么 bagSize = (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。 确定遍历顺序 举例推导dp数组 输入：nums: [1, 1, 1, 1, 1], S: 3 bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4 dp数组状态变化如下： 123456789101112131415161718class Solution {public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) { int sum = 0; for (int i = 0; i &lt; nums.size(); i++) sum += nums[i]; if (abs(S) &gt; sum) return 0; // 此时没有方案 if ((S + sum) % 2 == 1) return 0; // 此时没有方案 int bagSize = (S + sum) / 2; vector&lt;int&gt; dp(bagSize + 1, 0); dp[0] = 1; for (int i = 0; i &lt; nums.size(); i++) { for (int j = bagSize; j &gt;= nums[i]; j--) { dp[j] += dp[j - nums[i]]; } } return dp[bagSize]; }}; 474.一和零力扣题目链接 而m 和 n相当于是一个背包，两个维度的背包。 理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。 但本题其实是01背包问题！ 只不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品的容量。 开始动规五部曲： 确定dp数组（dp table）以及下标的含义 **dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]**。 确定递推公式 dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。 dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。 然后我们在遍历的过程中，取dp[i][j]的最大值。 所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); 此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。 dp数组如何初始化 01背包的dp数组初始化为0就可以。因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。 确定遍历顺序 举例推导dp数组 12345678910111213141516171819class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); // 默认初始化0 for (string str : strs) { // 遍历物品 int oneNum = 0, zeroNum = 0; for (char c : str) { if (c == '0') zeroNum++; else oneNum++; } for (int i = m; i &gt;= zeroNum; i--) { // 遍历背包容量且从后向前遍历！ for (int j = n; j &gt;= oneNum; j--) { dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); } } } return dp[m][n]; }}; 上一次的最大子集数与这次这个数放进去。也是放与不放两个状态","link":"/2024/02/26/Part9.2DP/"},{"title":"动态规划5","text":"300.最长递增子序列力扣题目链接 本题要先有一个逻辑，就是我们怎么确定一个状态转移，如果我dp要取这个数那么之前的状态怎么找，所以很明显需要两轮遍历， dp[i]的定义 dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度 为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在做递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。 状态转移方程 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。 所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); 这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值。 dp[i]的初始化 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1. dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。 j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。 123456789101112131415class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 1) return nums.size(); vector&lt;int&gt; dp(nums.size(), 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++) { for (int j = 0; j &lt; i; j++) { if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); } if (dp[i] &gt; result) result = dp[i]; // 取长的子序列 } return result; }}; 因为这里DP的含义是包括i的以nums[i]结尾的最长递增子序列的长度，所以包括它并不代表他是最长的这里举例 12459676 这里并不是12346是最长的但是dp[7]的结果就是5其实最长的是dp[6]1234567。 所以需要在每轮判断 if (dp[i] &gt; result) result = dp[i]; 包括上这个结尾的最长子串。 然后重新分析题目，两种状态包含结尾和不包含结尾，如果是不包含结尾那么就不更新或者说按照包含i-1来，如果是包含结尾那么就比较是按照之前的i-1来还是采用新的最长串。 这种题目的难点在于dp的定义（包含结尾），以及不包含结尾时值要怎么确定。 674. 最长连续递增序列力扣题目链接 这个问题因为是连续的，所以如果前边的数不是递增的那么就可以直接断开，那么一次循环就行 问题仍然要包含末尾节点 确定dp数组（dp table）以及下标的含义 **dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]**。 注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。 确定递推公式 如果 nums[i] &gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。 即：dp[i] = dp[i - 1] + 1; 因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。 既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i] 和 nums[i - 1]。 这里大家要好好体会一下！ dp数组如何初始化 以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。 所以dp[i]应该初始1; 确定遍历顺序 从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。 本文在确定递推公式的时候也说明了为什么本题只需要一层for循环，代码如下： 123456789101112131415class Solution {public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; int result = 1; vector&lt;int&gt; dp(nums.size() ,1); for (int i = 1; i &lt; nums.size(); i++) { if (nums[i] &gt; nums[i - 1]) { // 连续记录 dp[i] = dp[i - 1] + 1; } if (dp[i] &gt; result) result = dp[i]; } return result; }}; 718. 最长重复子数组力扣题目链接 两个数组那么很显然一维的dp不能解决，状态的转移是[i][j]，i代表一个数组j代表一个数组。还要求连续那么dp的更新和上一步一样。 确定dp数组（dp table）以及下标的含义 dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）为什么下标i-1 初始化部分介绍 确定递推公式 根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。 即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1; 根据递推公式可以看出，遍历i 和 j 要从1开始！ dp数组如何初始化 定义中使用下标i-1这样就可以解决需要如果最开始a[0]=b[0]就要初始化dp为1 根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！ 但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1; 所以dp[i][0] 和dp[0][j]初始化为0。 确定遍历顺序 同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来。 12345678910111213141516class Solution {public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp (nums1.size() + 1, vector&lt;int&gt;(nums2.size() + 1, 0)); int result = 0; for (int i = 1; i &lt;= nums1.size(); i++) { for (int j = 1; j &lt;= nums2.size(); j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } if (dp[i][j] &gt; result) result = dp[i][j]; } } return result; }}; 123 #如果不定义为-1的话要进行如下判断。for (int i = 0; i &lt; nums1.size(); i++) if (nums1[i] == nums2[0]) dp[i][0] = 1;for (int j = 0; j &lt; nums2.size(); j++) if (nums1[0] == nums2[j]) dp[0][j] = 1; 1143.最长公共子序列力扣题目链接 本题和 718. 最长重复子数组力扣题目链接区别在于这里不要求是连续的了，与300.最长递增子序列力扣题目链接要从两个数组考虑。 整个流程相当于两个的结合。 确定dp数组（dp table）以及下标的含义 dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j] 用i-1简化了dp数组第一行和第一列的初始化逻辑。 确定递推公式 主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1; 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[ i - 2]与text2[ j - 1]的最长公共子序列和 text1[i - 1]与text2[ j - 2]的最长公共子序列，取最大的。 即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); 代码如下： dp数组如何初始化 test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0; 同理dp[0][j]也是0。 其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。 确定遍历顺序 从递推公式，可以看出，有三个方向可以推出dp[i][j]，如图： 那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。 12345678910111213141516class Solution {public: int longestCommonSubsequence(string text1, string text2) { vector&lt;vector&lt;int&gt;&gt; dp(text1.size() + 1, vector&lt;int&gt;(text2.size() + 1, 0)); for (int i = 1; i &lt;= text1.size(); i++) { for (int j = 1; j &lt;= text2.size(); j++) { if (text1[i - 1] == text2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[text1.size()][text2.size()]; }}; 1035.不相交的线力扣题目链接 两个数组和前边一样需要二维dp数组分别找i和j大小的 本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！ 12345678910111213141516class Solution {public: int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { vector&lt;vector&lt;int&gt;&gt; dp(A.size() + 1, vector&lt;int&gt;(B.size() + 1, 0)); for (int i = 1; i &lt;= A.size(); i++) { for (int j = 1; j &lt;= B.size(); j++) { if (A[i - 1] == B[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[A.size()][B.size()]; }}; 53. 最大子序和力扣题目链接 确定dp数组（dp table）以及下标的含义 **dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]**。 确定递推公式 dp[i]只有两个方向可以推出来，要么从前边累加要么从头算： dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和 nums[i]，即：从头开始计算当前连续子序列和 一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]); dp数组如何初始化 从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。 根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。 确定遍历顺序 递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。 1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i &lt; nums.size(); i++) { dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式 if (dp[i] &gt; result) result = dp[i]; // result 保存dp[i]的最大值 } return result; }}; 只要是以xxx为结尾的都需要记录一下result 392.判断子序列力扣题目链接 确定dp数组（dp table）以及下标的含义 **dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。 注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。 确定递推公式 在确定递推公式的时候，首先要考虑如下两种操作，整理如下： if (s[i - 1] == t[j - 1])，那么dp[i][j] = dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符， if (s[i - 1] != t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1]; dp数组如何初始化 从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。 这里大家已经可以发现，在定义dp[i][j]含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。 1234567891011121314class Solution {public: bool isSubsequence(string s, string t) { vector&lt;vector&lt;int&gt;&gt; dp(s.size() + 1, vector&lt;int&gt;(t.size() + 1, 0)); for (int i = 1; i &lt;= s.size(); i++) { for (int j = 1; j &lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i][j - 1]; } } if (dp[s.size()][t.size()] == s.size()) return true; return false; }}; 115.不同的子序列力扣题目链接 确定dp数组（dp table）以及下标的含义 dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。 为什么i-1，j-1 这么定义我在 718. 最长重复子数组 (opens new window)中做了详细的讲解。 确定递推公式 这一类问题，基本是要分析两种情况 s[i - 1] 与 t[j - 1]相等 s[i - 1] 与 t[j - 1] 不相等 当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。 一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1]。 一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。 这里可能有录友不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。 例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。 当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。 所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：dp[i - 1][j] 所以递推公式为：dp[i][j] = dp[i - 1][j]; 这里可能有录友还疑惑，为什么只考虑 “不用s[i - 1]来匹配” 这种情况， 不考虑 “不用t[j - 1]来匹配” 的情况呢。 这里大家要明确，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况。 dp数组如何初始化 从递推公式dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][j] 是从上方和左上方推导而来，如图：，那么 dp[i][0] 和dp[0][j]是一定要初始化的。 每次当初始化的时候，都要回顾一下dp[i][j]的定义，不要凭感觉初始化。 dp[i][0]表示什么呢？ dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。 那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。 再来看dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。 那么dp[0][j]一定都是0，s如论如何也变成不了t。 最后就要看一个特殊位置了，即：dp[0][0] 应该是多少。 dp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。 123456789101112131415161718class Solution {public: int numDistinct(string s, string t) { vector&lt;vector&lt;uint64_t&gt;&gt; dp(s.size() + 1, vector&lt;uint64_t&gt;(t.size() + 1)); for (int i = 0; i &lt; s.size(); i++) dp[i][0] = 1; for (int j = 1; j &lt; t.size(); j++) dp[0][j] = 0; for (int i = 1; i &lt;= s.size(); i++) { for (int j = 1; j &lt;= t.size(); j++) { if (s[i - 1] == t[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[s.size()][t.size()]; }};","link":"/2024/03/10/Part9.5DP/"},{"title":"动态规划6","text":"583. 两个字符串的删除操作力扣题目链接 相比之前现在两个字符串都可以删除， 确定dp数组（dp table）以及下标的含义 dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。 这里和原来的匹配长度的dp定义不同， 确定递推公式 当word1[i - 1] 与 word2[j - 1]相同的时候 当word1[i - 1] 与 word2[j - 1]不相同的时候 当word1[i - 1] 与 word2[j - 1]相同的时候就不删除，那么就取上一个的dp[i][j] = dp[i - 1][j - 1]; 当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况： 情况一：删word1[i - 1]，最少操作次数为以i-1和j结尾的最少操作次数dp[i - 1][j]再加 1 情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1 情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2 那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1}); 因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); 这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i][j-1] + 1。 dp数组如何初始化 从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。 dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。 123456789101112131415161718class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i &lt;= word1.size(); i++) { for (int j = 1; j &lt;= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); } } } return dp[word1.size()][word2.size()]; }}; 方法2：本题和动态规划：1143.最长公共子序列 (opens new window)基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。 12345678910111213class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size()+1, vector&lt;int&gt;(word2.size()+1, 0)); for (int i=1; i&lt;=word1.size(); i++){ for (int j=1; j&lt;=word2.size(); j++){ if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } return word1.size()+word2.size()-dp[word1.size()][word2.size()]*2; }}; 72. 编辑距离力扣题目链接 现在不匹配的可以进行的操作变多了，可以进行增删改 1. 确定dp数组（dp table）以及下标的含义**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。 2. 确定递推公式在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下： 123456if (word1[i - 1] == word2[j - 1]) 不操作if (word1[i - 1] != word2[j - 1]) 增 删 换 也就是如上4种情况。 1if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]; word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的最近编辑距离dp[i - 1][j - 1]就是 dp[i][j]了。 在下面的讲解中，如果哪里看不懂，就回想一下dp[i][j]的定义，就明白了。 在整个动规的过程中，最为关键就是正确理解dp[i][j]的定义！ if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？ 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。 即 dp[i][j] = dp[i - 1][j] + 1; 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。 即 dp[i][j] = dp[i][j - 1] + 1; 操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。 可以回顾一下，if (word1[i - 1] == word2[j - 1])的时候我们的操作 是 dp[i][j] = dp[i - 1][j - 1] 对吧。 那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。 所以 dp[i][j] = dp[i - 1][j - 1] + 1; 综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; 递归公式代码如下： 123456if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1];}else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;} 3. dp数组如何初始化再回顾一下dp[i][j]的定义： **dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。 那么dp[i][0] 和 dp[0][j] 表示什么呢？ dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。 那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i; 同理dp[0][j] = j; 所以C++代码如下： 12for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i;for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; 4. 确定遍历顺序从如下四个递推公式： dp[i][j] = dp[i - 1][j - 1] dp[i][j] = dp[i - 1][j - 1] + 1 dp[i][j] = dp[i][j - 1] + 1 dp[i][j] = dp[i - 1][j] + 1 可以看出dp[i][j]是依赖左方，上方和左上方元素的，如图： 12345678910111213141516171819class Solution {public: int minDistance(string word1, string word2) { vector&lt;vector&lt;int&gt;&gt; dp(word1.size() + 1, vector&lt;int&gt;(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int j = 0; j &lt;= word2.size(); j++) dp[0][j] = j; for (int i = 1; i &lt;= word1.size(); i++) { for (int j = 1; j &lt;= word2.size(); j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1; } } } return dp[word1.size()][word2.size()]; }}; 647. 回文子串力扣题目链接 确定dp数组（dp table）以及下标的含义 如果大家做了很多这种子序列相关的题目，在定义dp数组的时候 很自然就会想题目求什么，我们就如何定义dp数组。 绝大多数题目确实是这样，不过本题如果我们定义，dp[i] 为 下标i结尾的字符串有 dp[i]个回文串的话，我们会发现很难找到递归关系。 dp[i] 和 dp[i-1] ，dp[i + 1] 看上去都没啥关系。 所以我们要看回文串的性质。 如图： 我们在判断字符串S是否是回文，那么如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。 那么此时我们是不是能找到一种递归关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。 所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。 布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 确定递推公式 在确定递推公式时，就要分析如下几种情况。 整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。 当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。 当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串 情况二：下标i 与 j相差为1，例如aa，也是回文子串 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。 以上三种情况分析完了，那么递归公式如下： 123456789if (s[i] == s[j]) { if (j - i &lt;= 1) { // 情况一 和 情况二 result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { // 情况三 result++; dp[i][j] = true; }} result就是统计回文子串的数量。 注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i][j]初始化的时候，就初始为false。 dp数组如何初始化 dp[i][j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。 所以dp[i][j]初始化为false。 确定遍历顺序 遍历顺序可有有点讲究了。 首先从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的。 dp[i + 1][j - 1] 在 dp[i][j]的左下角，如图： 如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。 所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的。 有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1][j - 1]都是经过计算的。 123456789101112131415161718192021class Solution {public: int countSubstrings(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); int result = 0; for (int i = s.size() - 1; i &gt;= 0; i--) { // 注意遍历顺序 for (int j = i; j &lt; s.size(); j++) { if (s[i] == s[j]) { if (j - i &lt;= 1) { // 情况一 和 情况二 result++; dp[i][j] = true; } else if (dp[i + 1][j - 1]) { // 情况三 result++; dp[i][j] = true; } } } } return result; }}; 516.最长回文子序列力扣题目链接 1234567891011121314151617class Solution {public: int longestPalindromeSubseq(string s) { vector&lt;vector&lt;int&gt;&gt; dp(s.size(), vector&lt;int&gt;(s.size(), 0)); for (int i = 0; i &lt; s.size(); i++) dp[i][i] = 1; for (int i = s.size() - 1; i &gt;= 0; i--) { for (int j = i + 1; j &lt; s.size(); j++) { if (s[i] == s[j]) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.size() - 1]; }};","link":"/2024/03/10/Part9.6DP/"},{"title":"哈希表","text":"一般哈希表都是用来快速判断一个元素是否出现集合里。但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。Hash法的优势就是牺牲了空间去换了时间，在工业场景中也很适用。 实现理论哈希函数打比方：就是将学生姓名映射为哈希表上的索引，通过特定编码方式生成hashCode。如果hashCode超过哈希表大小（tableSize），会进行取模操作以确保映射在表内。但如果学生数量大于表大小，可能导致多个学生映射到同一索引位置。 发生冲突的解决办法： 拉链法 注意点：拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 线性探测法 注意点：一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。 Hash数组——242.有效的字母异位词力扣题目链接 方法理论很简单，直接定义一个数组critic全为0；判断两个数组中的元素，A数组中存在元素就++，B数组中存在的元素就–；最后判断critic数组是否全为0。为0就代表是移位词。要求只有小写字母，那么就给我们浓浓的暗示，用数组！然后这里涉及到一个要采用哪种hash的实现方法的问题一般有 数组 set （集合） 数组局限性 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。 map(映射) 数组和set来做哈希法的局限 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。 set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。 每个部分还是有不同底层实现。 所以我们要根据不同的问题来选择实现的方式。然后从速度上分析如果可以用数组解决就用数组解决，因为其他hash方式需要进行hash函数的加密。 Hashset——349. 两个数组的交集力扣题目链接 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。这个思路就是建议用Set来解决问题，因为set可以不用申请连续的空间，而相比之下map是键值对的形式，可以用key存储查找的值，用value存储次数。可以方便的使用set1.contains来检测是在集合中。 123for (int i:nums2){ if (set1.contains(i)) set2.add(i);} ​ Hashmap——454.四数相加II力扣题目链接 这个题目是有四个数组并没不用考虑有重复的四个元素所以可以很直接的想到用hash map来解决。这道题目中并不需要key有序，选择std::unordered_map 效率更高！然后还需要思考map应该怎么用。第一步计算两个数相加的和，用和做键值， value 做重复的次数，然后在用两个数相加来找有多少个为0的情况。 map用来做什么 map中key和value分别表示什么 1234567891011121314151617181920class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //统计两个数组中的元素之和，同时统计出现的次数，放入map for (int i : nums1) { for (int j : nums2) { int sum = i + j; map.put(sum, map.getOrDefault(sum, 0) + 1); } } //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数 for (int i : nums3) { for (int j : nums4) { res += map.getOrDefault(0 - i - j, 0); } } return res; }} 难点还是想到要用hash来解决问题 伪Hash——第15题. 三数之和力扣题目链接 这个题就，如果用hash的解决方法就不行，因为他要求不重复比如 -1，1，0和 1，-1，0就算重复，所以要直接通过两层for循环来判断的话，可能会出现重复的情况。所以现有的解发就是双指针排序，设置左右节点，最外层for循坏迭代，，right和left寻找能与之组队的数判断的原则就是看三数之和大于0还是小于0。其中的List的声明也可以学习一下， 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.length; i++) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] &gt; 0) { return result; } if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { // 去重a continue; } int left = i + 1; int right = nums.length - 1; while (right &gt; left) { int sum = nums[i] + nums[left] + nums[right]; if (sum &gt; 0) { right--; } else if (sum &lt; 0) { left++; } else { result.add(Arrays.asList(nums[i], nums[left], nums[right])); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return result; }} Hash常用库函数ArrayListArrayList 是 Java 中常用的动态数组实现，它提供了一系列常用的方法来操作列表。以下是一些常见的 ArrayList 方法： 添加元素： add(E element): 将元素添加到列表的末尾。 add(int index, E element): 在指定位置插入元素。 1234ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;One&quot;);list.add(&quot;Two&quot;);list.add(1, &quot;Three&quot;); // 在索引1处插入元素 &quot;Three&quot; 获取元素： get(int index): 获取指定位置的元素。 1String element = list.get(1); // 获取索引1处的元素 更新元素： set(int index, E element): 替换指定位置的元素。 1list.set(1, &quot;NewElement&quot;); // 将索引1处的元素替换为 &quot;NewElement&quot; 删除元素： remove(int index): 移除指定位置的元素。 remove(Object obj): 移除指定元素。 clear(): 清空列表中的所有元素。 123list.remove(1); // 移除索引1处的元素list.remove(&quot;Two&quot;); // 移除元素 &quot;Two&quot;list.clear(); // 清空列表 查询元素： contains(Object obj): 判断列表是否包含指定元素。 indexOf(Object obj): 返回指定元素的第一个出现位置的索引。 12boolean contains = list.contains(&quot;One&quot;); // 判断列表是否包含 &quot;One&quot;int index = list.indexOf(&quot;Two&quot;); // 获取元素 &quot;Two&quot; 的索引 列表大小和判空： size(): 返回列表中的元素个数。 isEmpty(): 判断列表是否为空。 12int size = list.size(); // 获取列表大小boolean isEmpty = list.isEmpty(); // 判断列表是否为空 HashSetHashSet 是 Java 中的一个集合类，它实现了 Set 接口，底层基于哈希表实现。以下是 HashSet 常用的一些方法： 添加元素： boolean add(E e): 将指定的元素添加到集合中，如果元素已经存在，则不会重复添加，返回 true 表示添加成功，false 表示元素已存在。 123HashSet&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;apple&quot;);set.add(&quot;banana&quot;); 移除元素： boolean remove(Object o): 从集合中移除指定的元素，如果元素存在并成功移除，则返回 true。 1set.remove(&quot;banana&quot;); 清空集合： void clear(): 移除集合中的所有元素。 1set.clear(); 判断集合是否为空： boolean isEmpty(): 判断集合是否为空。 123if (set.isEmpty()) { System.out.println(&quot;集合为空&quot;);} 获取集合大小： int size(): 获取集合中元素的数量。 1int size = set.size(); 判断元素是否存在： boolean contains(Object o): 判断集合中是否包含指定的元素。 123if (set.contains(&quot;apple&quot;)) { System.out.println(&quot;集合包含苹果&quot;);} 遍历集合： 使用迭代器或增强 for 循环来遍历集合中的元素。 123for (String element : set) { System.out.println(element);} HashMapHashMap 是 Java 中常用的集合类，它实现了 Map 接口，提供了键值对的存储和检索功能。以下是 HashMap 常用的一些方法： put(K key, V value)： 将指定的键值对存储在 HashMap 中。如果键已经存在，则替换对应的值，并返回旧值。 123HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;One&quot;, 1);map.put(&quot;Two&quot;, 2); get(Object key)： 返回指定键所映射的值，如果该键不存在，则返回 null。 1Integer value = map.get(&quot;One&quot;); containsKey(Object key)： 判断 HashMap 中是否包含指定键。 1boolean containsKey = map.containsKey(&quot;Three&quot;); containsValue(Object value)： 判断 HashMap 中是否包含指定值。 1boolean containsValue = map.containsValue(2); remove(Object key)： 从 HashMap 中移除指定键及其对应的值。 1map.remove(&quot;One&quot;); size()： 返回 HashMap 中键值对的数量。 1int size = map.size(); keySet()： 返回包含 HashMap 中所有键的集合。 1Set&lt;String&gt; keys = map.keySet(); values()： 返回包含 HashMap 中所有值的集合。 1Collection&lt;Integer&gt; values = map.values();","link":"/2024/01/25/PartIII_Hash/"},{"title":"链表","text":"Note注意判断链表为空的情况 while 和if 一样满足条件进入循环 链表操作链表的移除特定数值有两种方法： 方法1：直接使用原来的链表来进行删除操作。需要通过while保证头节点不是移除节点。 12345678910111213141516171819202122public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) { head = head.next; } // 已经为null，提前退出 if (head == null) { return head; } // 已确定当前head.val != val ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return head;} 方法2：使用虚拟节点。这样头结点和其他节点的移除方式完全一致，少了判断头节点是不是目标节点和头节点为空的情况 123456789101112131415161718public ListNode removeElements(ListNode head, int val) { if (head == null) { return head; } // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作 ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode cur = head; while (cur != null) { if (cur.val == val) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummy.next;} 707.设计链表https://leetcode.cn/problems/design-linked-list/description/ 思路是：创建一个虚拟头保证一致，设计链表最大的问题就是你不确定什么时候是while（temp.next！=null）还是while（temp！=null）这个逻辑就是判断里边需不需要temp.next.val如果不需要那么就可以temp，这样的话就会多迭代一次迭代一次最后的null。所有的尾端插入都一样，头部插入引入虚拟头之后一样，中间插入要记录上一个节点，删除也要记录上一个节点， 24. 两两交换链表中的节点解题思路就是画图，并且你要保证改变指针之后不影响后续的操作。然后虚拟节点的作用也是一样，不用单独考虑头节点的情况。步骤之间的顺序你一定要理清楚，如果中间改变了cur-next那原有的链接就会消失。所以最好的做法就是提前保存这些变量。你如果要调换步骤23那么temp= cur-&gt;next-&gt;next。 1234567891011121314151617181920class Solution { public ListNode swapPairs(ListNode head) { ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点 dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode cur = dumyhead; ListNode temp; // 临时节点，保存两个节点后面的节点 ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点 ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点 while (cur.next != null &amp;&amp; cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } return dumyhead.next; }} 还有一个递归的解法比较难以理解，递归的思想就是从后往前倒退。这里我直接画一个迭代的图，每一次递归的都是两个数之后即next-&gt;next，所以两次head是1，3。再一次递归会出现null并给3的递归new Node 返回null， 1234567891011121314class Solution { public ListNode swapPairs(ListNode head) { // base case 退出提交 if(head == null || head.next == null) return head; // 获取当前节点的下一个节点 ListNode next = head.next; // 进行递归 ListNode newNode = swapPairs(next.next); // 这里进行交换 next.next = head; head.next = newNode; return next; }} 链表相交面试题 02.07. 链表相交 这个暴力通过两个while循环来做很简单，但是提供一种新思路先确定长度，在根据长度，然后计算两个的差，给长的那个的current加上这个差保证统一长度，这样在一对一的比较就可以很快的找到想找的相交点了。 环形链表 https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html 找到相交点可以通过快慢指针决定。证明如下，找到成环点就是x=z所以再创建另一个节点从起点出发就行了与slow的相交点就是入还点。 总结","link":"/2024/01/25/PartII_LInked_list/"},{"title":"数组","text":"定义：数组是存放在连续内存空间上的相同类型数据的集合。 知识 C++：int类型4字节float类型在32位中是4字节 在64位中是8字节 Java的一维数组是连续的，二维数组在内存中不是连续地址空间 右移一维相当于除以2 k–是最后减去k=1 i=k–；之后i=1，k=0 题目二分法前提是数组为有序数组，同时题目还强调数组中无重复元素，解决思路：两个边界，让左边界小于等于右边界通过比较mid与目标的值，来修改两个边界，直到找到目标值。 https://leetcode.cn/problems/binary-search/ Q：二分的边界应该如何判断？优势1：因为取mid值时已经对比了和目标值的是否匹配，所以在之后确定边界时可以加一减一操作 1234567if (guess == target) { return midOfIndex;} else if (guess &lt; target) { minOfIndex = midOfIndex + 1;} else { maxOfIndex = midOfIndex - 1;} 优势2：在while循环中设置一个小于等于，就可以在最后一次判断是否等于边界 例如{0,1,2,3,4}找4 right_index：0 left_index：4 right_index：3 left_index：4 right_index：4 left_index：4 Q：奇数和偶数数组有没有必要考虑？一个数的数组有没有必要考虑其他方法需要，上述代码不用 双指针法特点是通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。，主要问题就是两个指针的作用，一个用于寻找想要的值，一个用与确定目前索引 有两种实现一种是从两边开始，while保证left&lt;=right；从一边开始 index&lt;length 暴力解法时间复杂度：O(n^2) 双指针时间复杂度：O(n) https://leetcode.cn/problems/remove-element/description/ https://leetcode.cn/problems/squares-of-a-sorted-array/ 1234567891011121314public class Solution2 { public int removeElement(int[] nums, int val) { int fast_Index = 0; int slow_Index = 0; while(fast_Index &lt; nums.length){ if(nums[fast_Index] != val){ nums[slow_Index] = nums[fast_Index]; slow_Index++; } fast_Index++; } return slow_Index; }} 滑动窗口滑动窗口的思想就是两个指针前边指针用于确定窗口大小，后边指针用于缩小窗口以此为一个循环。循环到底是前指针指到最后。 也可以用于解决失败超时问题 暴力解法时间复杂度：O(n^2) 滑动窗口时间复杂度：O(n) 模拟遵循循环不变量原则，这样就可以保证，每个边循环次数固定，比如如图所示每个边循环都是2 这样写起来就很简答。","link":"/2024/01/23/PartI_Array/"},{"title":"字符串","text":"字符串也就相当于一种字符数组，它在java中有许多的库函数比如： charAt(int index): Returns the character at the specified index in the string. 12String str = &quot;Hello&quot;;char character = str.charAt(0); // Returns 'H' length(): Returns the length of the string. 12String str = &quot;Hello&quot;;int length = str.length(); // Returns 5 substring(int beginIndex, int endIndex): Returns a substring of the string starting from beginIndex up to, but not including, endIndex. 12String str = &quot;Hello&quot;;String subStr = str.substring(0, 3); // Returns &quot;Hel&quot; indexOf(String str): Returns the index of the first occurrence of the specified substring. 12String str = &quot;Hello&quot;;int index = str.indexOf(&quot;lo&quot;); // Returns 3 concat(String str): Concatenates the specified string to the end of the original string. 12String str = &quot;Hello&quot;;String newStr = str.concat(&quot; World&quot;); // Returns &quot;Hello World&quot; toLowerCase() / toUpperCase(): Converts the string to lowercase or uppercase. 123String str = &quot;Hello&quot;;String lowerStr = str.toLowerCase(); // Returns &quot;hello&quot;String upperStr = str.toUpperCase(); // Returns &quot;HELLO&quot; trim(): Removes leading and trailing whitespaces. 12String str = &quot; Hello &quot;;String trimmedStr = str.trim(); // Returns &quot;Hello&quot; replace(char oldChar, char newChar): Replaces all occurrences of oldChar with newChar. 12String str = &quot;Hello&quot;;String replacedStr = str.replace('l', 'w'); // Returns &quot;Hewwo&quot; startsWith(String prefix) / endsWith(String suffix): Checks if the string starts or ends with the specified prefix or suffix. 123String str = &quot;Hello&quot;;boolean startsWith = str.startsWith(&quot;He&quot;); // Returns trueboolean endsWith = str.endsWith(&quot;lo&quot;); // Returns true 声明和转换 1234String str = &quot;Hello&quot;;char[] charArray = str.toCharArray();char[] charArray = {'H', 'e', 'l', 'l', 'o'};String str = new String(charArray); StringBuilder 12345StringBuilder sb = new StringBuilder(); // Default initial capacity (16)StringBuilder sbWithCapacity = new StringBuilder(30); // Initial capacity set to 30StringBuilder sbWithString = new StringBuilder(&quot;Hello&quot;); // Initialize with a stringsb.append(&quot; World&quot;); // Append a stringsb.insert(5, &quot; World&quot;); // Insert a string at index 5 java中的字符串不能进行更改，所以有两种方法一种是转换为char数组，另一种是创建stringbuild对象。 解决字符串的匹配问题最暴力的方法肯定是双层for循环来判断如果没有时间限制，一般可以实现。我们采用这些方法的目的是让我可以在时间和空间上有所提升。从n2到n 反转字符串力扣题目链接 需要头尾调换整个字符串，相当于我们实现一个reverse库函数。这里我们可以使用头尾双指针很方便的实现。 123456789101112public void reverseString(char[] s) { int left = 0; int right = s.length-1; char temp = 0; for (int i=0;i&lt;s.length/2;i++){ temp = s[left]; s[left] = s[right]; s[right]=temp; left++; right--; }} 反转字符串II力扣题目链接 这个题目有自己的反转规则，所以需要根据规则进行反转，所以需要想到的是i += 2 * k，而不是ch.length/2k，因为这样做会更加方便一点，然后还有就是题目的理解了，题目要求只要有k个就翻转k个，没有k个就翻转剩下的，所以最后一步可以直接判断是不是最后所有采用最小值进行替换。 1234567891011121314151617181920class Solution { public String reverseStr(String s, int k) { char[] ch = s.toCharArray(); for(int i = 0;i &lt; ch.length;i += 2 * k){ int start = i; // 判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1,start + k - 1); while(start &lt; end){ char temp = ch[start]; ch[start] = ch[end]; ch[end] = temp; start++; end--; } } return new String(ch); }} for循环的执行顺序 for(int i = 0;i &lt; ch.length;i += 2 * k){ } ①int i = 0 ②i &lt; ch.length ③i += 2 * k ④循环体 执行过程是①-&gt;②-&gt;④-&gt;③再返回到2 151.翻转字符串里的单词力扣题目链接 这个主打一个熟悉很多的解决方法可以使用 使用StringBuilder 移除多余空格，将整个字符串反转，将每个单词反转。其中if 的意义是如果单词不是空格就插入，如果单词是空格就要保证上一次不是空格。 123456789101112int start = 0;int end = s.length() - 1;while (s.charAt(start) == ' ') start++;while (s.charAt(end) == ' ') end--;StringBuilder sb = new StringBuilder();while (start &lt;= end) { char c = s.charAt(start); if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } start++;} 创建新的字符串数组，对整体数组从后往前遍历，然后设置一个指针记录右侧位置如果是不是空格就添加。两个while循环确定一个单词的左右边界==‘ ’是用来删除空格的 1234while(i&gt;=0 &amp;&amp; initialArr[i] == ' '){i--;} //跳过空格//此时i位置是边界或!=空格，先记录当前索引，之后的while用来确定单词的首字母的位置int right = i;while(i&gt;=0 &amp;&amp; initialArr[i] != ' '){i--;} 使用char数组主要体现在移除空格上，操作原理同删除数组中的元素，通过双指针实现。这里是空格的if循环放哪里，更体会到了while遍历整个单词的作用。 123456789101112int slow = 0; for (int fast = 0; fast &lt; chars.length; fast++) { //先用 fast 移除所有空格 if (chars[fast] != ' ') { //在用 slow 加空格。 除第一个单词外，单词末尾要加空格 if (slow != 0) chars[slow++] = ' '; //fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了 while (fast &lt; chars.length &amp;&amp; chars[fast] != ' ') chars[slow++] = chars[fast++]; } } 28. 实现 strStr()-KMP力扣题目链接 这个大小子串必然是可以使用暴力解决两层for循环，但是另一种很重要的技术就是KMP实现字符串匹配， KMP理论知识当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。 文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。简单的来说就是匹配串自身存在一定的关联关系，如果它前缀上了，就可以通过最长相等前后缀串切换位置。 下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。前缀表体现了不匹配时的之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和后缀关系，也就是如何移动将前缀匹配串转移到后缀匹配串上。 前缀表如何计算，比如你要计算aa的前缀表就把aa的所有前缀和后缀列出看看最大能匹配上的数目 这里我以aabaa举例 aabaa的前缀子串是a,aa,aab,aaba; 后缀子串是a,aa,baa,abaa; 所以可以很明显的看出最长匹配得前后缀串是aa所以是2，这时候如果f不匹配那么整个串就可以直接从2开始匹配因为前缀aa和后缀aa完全一致。 前缀表和Next数组的关系 很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？ next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。减一并右移之后就可以和index对应上了。 以下我们以前缀表统一减一之后的next数组来做演示。 有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。 注意next数组是新前缀表（旧前缀表统一减一了）。 仅此而已 KMP的时间复杂度是O(n+m)暴力的复杂度是O(n × m)，所以KMP在字符串匹配中极大地提高了搜索的效率。 KMP具体实现关键点不是反推出上述模式，而是如何根据上述理论推出代码。 123456789101112131415161718192021222324252627282930313233343536373839// 方法一class Solution { public void getNext(int[] next, String s){ int j = -1; next[0] = j; for (int i = 1; i &lt; s.length(); i++){ while(j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)){ j=next[j]; } if(s.charAt(i) == s.charAt(j+1)){ j++; } next[i] = j; } } public int strStr(String haystack, String needle) { if(needle.length()==0){ return 0; } int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; for(int i = 0; i &lt; haystack.length(); i++){ while(j&gt;=0 &amp;&amp; haystack.charAt(i) != needle.charAt(j+1)){ j = next[j]; } if(haystack.charAt(i) == needle.charAt(j+1)){ j++; } if(j == needle.length()-1){ return (i-needle.length()+1); } } return -1; }} 1234567891011121314151617181920212223242526272829303132class Solution { //前缀表（不减一）Java实现 public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[] next = new int[needle.length()]; getNext(next, needle); int j = 0; for (int i = 0; i &lt; haystack.length(); i++) { while (j &gt; 0 &amp;&amp; needle.charAt(j) != haystack.charAt(i)) j = next[j - 1]; if (needle.charAt(j) == haystack.charAt(i)) j++; if (j == needle.length()) return i - needle.length() + 1; } return -1; } private void getNext(int[] next, String s) { int j = 0; next[0] = 0; for (int i = 1; i &lt; s.length(); i++) { while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i)) j = next[j - 1]; if (s.charAt(j) == s.charAt(i)) j++; next[i] = j; } }} 然后大小子串直接做就可以了。 459.重复的子字符串力扣题目链接 判断一个串是不是由其子串构成，这时就体现了两个思路 1.将这个串两个连接，然后如果能在其内部找到完整的子串证明其存在船夫的子串。 2.kmp的next 数组记录的是最长公共子前缀那么 证明： 假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n * x组成。 因为字符串s的最长相同前后缀的长度一定是不包含s本身，所以 最长相同前后缀长度必然是m * x，而且 n - m = 1，（这里如果不懂，看上面的推理） 所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。 next 数组记录的就是最长相同前后缀这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)， 如果 next[len - 1] != -1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。 最长相等前后缀的长度为：next[len - 1] + 1。(这里的next数组是以统一减一的方式计算的，因此需要+1， 数组长度为：len。 如果len % (len - (next[len - 1] + 1)) == 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 强烈建议大家把next数组打印出来，看看next数组里的规律，有助于理解KMP算法","link":"/2024/01/29/PartVI_String/"},{"title":"栈与队列","text":"栈与队列是常用的数据结构，其中栈提供先进后出，队列提供先进先出，这样的数据结构可以解决一些需要顺序解决的问题。在java中实现底层是不一样的原因是栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。 在Java中，队列和栈是两种常见的数据结构，它们分别用于不同的场景，而它们的实现通常基于以下几种容器： 队列（Queue）的容器实现： LinkedList： java.util.LinkedList 是一个双向链表，支持在两端进行元素的添加和删除，因此适用于实现队列。 可以使用 offer() 在队尾添加元素，使用 poll() 移除并返回队头元素。 1234Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();queue.offer(1);queue.offer(2);int frontElement = queue.poll(); ArrayDeque： java.util.ArrayDeque 是一个基于数组的双端队列，同样适用于实现队列。 可以使用 offer() 在队尾添加元素，使用 poll() 移除并返回队头元素。 1234Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();queue.offer(1);queue.offer(2);int frontElement = queue.poll(); PriorityQueue： java.util.PriorityQueue 是一个基于优先级堆的无界优先级队列，可以实现具有优先级的队列。 元素按照优先级顺序被移除。 1234Queue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();priorityQueue.offer(3);priorityQueue.offer(1);int highestPriority = priorityQueue.poll(); 栈（Stack）的容器实现： LinkedList： java.util.LinkedList 可以用作栈的实现，因为它是一个双向链表，支持在两端进行元素的添加和删除。 可以使用 push() 入栈，pop() 出栈，peek() 查看栈顶元素。 1234Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();stack.push(1);stack.push(2);int topElement = stack.pop(); ArrayDeque： java.util.ArrayDeque 同样可以用作栈的实现，支持在两端进行元素的添加和删除。 可以使用 push() 入栈，pop() 出栈，peek() 查看栈顶元素。 1234Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();stack.push(1);stack.push(2);int topElement = stack.pop(); 注意：在现代Java编程中，推荐使用 Deque 接口来代替 Stack 类，因为 Deque 提供了更灵活的双端队列操作，并且 Stack 类是一个遗留类。 232.用栈实现队列力扣题目链接 如果要用栈实现队列，那么就要保证先进先出，所以就必须用两个栈，一个负责弹出到底部一个负载接收其他变量。 123456789101112stackIn = new Stack&lt;&gt;(); // 负责进栈stackOut = new Stack&lt;&gt;(); // 负责出栈 public int pop() { dumpstackIn(); return stackOut.pop(); } private void dumpstackIn(){ if (!stackOut.isEmpty()) return; while (!stackIn.isEmpty()){ stackOut.push(stackIn.pop()); } } 225. 用队列实现栈力扣题目链接 这个有多种实现思路，可以在放入队列时就保证出栈顺序。也可以在出队列时出最后一个，还可以使用一个队列循环size长度然后把出队的元素重新入队，直到找到最后一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /** 思路1：两个队列在放入时保证出队顺序 */class MyStack { Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列 Queue&lt;Integer&gt; queue2; // 辅助队列 /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty()){ queue2.offer(queue1.poll()); } Queue&lt;Integer&gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中 } /** 思路2：两个队列在放入时保证出队顺序 */ // Deque 接口继承了 Queue 接口 // 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst Deque&lt;Integer&gt; que1; // 和栈中保持一样元素的队列 Deque&lt;Integer&gt; que2; // 辅助队列 public int pop() { int size = que1.size(); size--; // 将 que1 导入 que2 ，但留下最后一个值 while (size-- &gt; 0) { que2.addLast(que1.peekFirst()); que1.pollFirst(); } int res = que1.pollFirst(); // 将 que2 对象的引用赋给了 que1 ，此时 que1，que2 指向同一个队列 que1 = que2; // 如果直接操作 que2，que1 也会受到影响，所以为 que2 分配一个新的空间 que2 = new ArrayDeque&lt;&gt;(); return res; } /** 思路3：一个队列，一边放一边添加 */ class MyStack { // Deque 接口继承了 Queue 接口 // 所以 Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst Deque&lt;Integer&gt; que1; public int pop() { int size = que1.size(); size--; // 将 que1 导入 que2 ，但留下最后一个值 while (size-- &gt; 0) { que1.addLast(que1.peekFirst()); que1.pollFirst(); } int res = que1.pollFirst(); return res; } 20. 有效的括号力扣题目链接 两种情况比较遇见左括号就入栈右括号和遇到左括号就入栈左括号对比，可以看到如果采用遇到左括号就入栈右括号就不用进行匹配了可以直接相等比较。 123456789101112131415for (int i = 0; i &lt; s.length(); i++) { char currentChar = s.charAt(i); if (currentChar == '(' || currentChar == '[' || currentChar == '{') { stack.push(currentChar); } else if (currentChar == ')' || currentChar == ']' || currentChar == '}') { if (stack.isEmpty() || (currentChar == ')' &amp;&amp; stack.peek() != '(') || (currentChar == ']' &amp;&amp; stack.peek() != '[') || (currentChar == '}' &amp;&amp; stack.peek() != '{')) { return false; // Mismatched brackets } stack.pop(); // Matching pair found, remove the opening bracket }} 123456789101112131415161718 for (int i = 0; i &lt; s.length(); i++) { ch = s.charAt(i); //碰到左括号，就把相应的右括号入栈 if (ch == '(') { deque.push(')'); }else if (ch == '{') { deque.push('}'); }else if (ch == '[') { deque.push(']'); } else if (deque.isEmpty() || deque.peek() != ch) { return false; }else {//如果是右括号判断是否和栈顶元素匹配 deque.pop(); } } //最后判断栈中元素是否匹配 return deque.isEmpty();} 1047. 删除字符串中的所有相邻重复项力扣题目链接 很简单的逻辑如果，某个元素和栈顶元素一样就出栈栈顶，不一样就入栈。这里简单介绍三个方法 方法1：列表链接结构可能是最糟糕的结构，每个元素上都有缓存未命中而进行迭代。最重要的是，它们消耗更多的内存。 如果您需要添加/删除两端，ArrayDeque 明显优于 LinkedList。对于循环队列来说，随机访问每个元素也是 O(1)。 链表唯一更好的操作是在迭代期间删除当前元素 12345678910111213141516171819202122class Solution { public String removeDuplicates(String S) { //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点 //参考： ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;(); char ch; for (int i = 0; i &lt; S.length(); i++) { ch = S.charAt(i); if (deque.isEmpty() || deque.peek() != ch) { deque.push(ch); } else { deque.pop(); } } String str = &quot;&quot;; //剩余的元素即为不重复的元素 while (!deque.isEmpty()) { str = deque.pop() + str; } return str; }} 方法2双指针快指针指向需要匹配元素 ，慢指针指向已经匹配元素，其中的slow–和slow++是灵魂，slow–代表如果匹配就删除数组中的slow，slow++不匹配就向前移动。 12345678910111213141516171819lass Solution { public String removeDuplicates(String s) { char[] ch = s.toCharArray(); int fast = 0; int slow = 0; while(fast &lt; s.length()){ // 直接用fast指针覆盖slow指针的值 ch[slow] = ch[fast]; // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了 if(slow &gt; 0 &amp;&amp; ch[slow] == ch[slow - 1]){ slow--; }else{ slow++; } fast++; } return new String(ch,0,slow); }} 239. 滑动窗口最大值力扣题目链接 需要返回滑动窗口的最大值，这可以使用一个单调队列 其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//解法一//自定义数组class MyQueue { Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出 //同时判断队列当前是否为空 void poll(int val) { if (!deque.isEmpty() &amp;&amp; val == deque.peek()) { deque.poll(); } } //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出 //保证队列元素单调递减 //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2 void add(int val) { while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) { deque.removeLast(); } deque.add(val); } //队列队顶元素始终为最大值 int peek() { return deque.peek(); }}class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1) { return nums; } int len = nums.length - k + 1; //存放结果元素的数组 int[] res = new int[len]; int num = 0; //自定义队列 MyQueue myQueue = new MyQueue(); //先将前k的元素放入队列 for (int i = 0; i &lt; k; i++) { myQueue.add(nums[i]); } res[num++] = myQueue.peek(); for (int i = k; i &lt; nums.length; i++) { //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列 myQueue.poll(nums[i - k]); //滑动窗口加入最后面的元素 myQueue.add(nums[i]); //记录对应的最大值 res[num++] = myQueue.peek(); } return res; }} 347.前 K 个高频元素（review）力扣题目链接 什么是优先级队列呢？ 其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。 所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。 所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， * 从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点 * */class Solution { //解法1：基于大顶堆实现 public int[] topKFrequent1(int[] nums, int k) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆) PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair2[1]-pair1[1]); for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//大顶堆需要对所有元素进行排序 pq.add(new int[]{entry.getKey(),entry.getValue()}); } int[] ans = new int[k]; for(int i=0;i&lt;k;i++){//依次从队头弹出k个,就是出现频率前k高的元素 ans[i] = pq.poll()[0]; } return ans; } //解法2：基于小顶堆实现 public int[] topKFrequent2(int[] nums, int k) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数 for(int num:nums){ map.put(num,map.getOrDefault(num,0)+1); } //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数 //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆) PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1,pair2)-&gt;pair1[1]-pair2[1]); for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//小顶堆只需要维持k个元素有序 if(pq.size()&lt;k){//小顶堆元素个数小于k个时直接加 pq.add(new int[]{entry.getKey(),entry.getValue()}); }else{ if(entry.getValue()&gt;pq.peek()[1]){//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个) pq.poll();//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了 pq.add(new int[]{entry.getKey(),entry.getValue()}); } } } int[] ans = new int[k]; for(int i=k-1;i&gt;=0;i--){//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多 ans[i] = pq.poll()[0]; } return ans; }}","link":"/2024/01/31/PartV_Stack/"},{"title":"myFirst Blog","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More infoGGGGGGG: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/01/21/hello-world/"},{"title":"Python数据结构","text":"数据类型列表（List）是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同， 1234567891011121314151617#定义list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ] # 定义一个列表tinylist = [123, 'runoob']L = []classmates = ['Michael', 'Bob', 'Tracy']#获取长度len(classmates)3#用-1做索引，直接获取最后一个元素classmates[-1] 'Tracy'#添加和删除classmates.append('Adam')classmates.pop(1) #用pop(i)方法，其中i是索引位置#返回列表元素最大值max(list) 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 123tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2 )tinytuple = (123, 'runoob')t = (1,) #只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 集合（Set）是一种无序、可变的数据类型，用于存储唯一的元素。 1234sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}print(sites) # 输出集合，重复的元素被自动去掉# 成员测试if 'Runoob' in sites : 字典（dictionary）是Python中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合 1234567dict = {}d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}d['Michael']95#判断是否存在'Thomas' in dFalse 字符串（string）是不变对象，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回， 123456a = 'abc'b = a.replace('a', 'A')b'Abc'a'abc' 特性切片Python提供了切片（Slice）操作符，能大大简化从list取部分元素。 1234567891011#从索引0开始取，直到索引3为止，但不包括索引3L[0:3]['Michael', 'Sarah', 'Tracy']#如果第一个索引是0，还可以省略L[:3]['Michael', 'Sarah', 'Tracy']#从索引1开始，取出2个元素出来L[1:3]['Sarah', 'Tracy']L.split('h') # 以h分割L.reverse()#旋转 倒数第一个元素的索引是-1 Python中的split()方法是字符串处理中非常常用的一个函数，它用于将字符串拆分为子串，并将这些子串作为列表的元素返回。以下是split()方法的一些常见用法： 基本用法：不带任何参数，默认以空格为分隔符拆分字符串。 123text = &quot;Hello World&quot; result = text.split() print(result) # 输出：['Hello', 'World'] 指定分隔符：通过传递sep参数来指定一个分隔符。 123text = &quot;apple,banana,orange&quot; result = text.split(&quot;,&quot;) print(result) # 输出：['apple', 'banana', 'orange'] 限制拆分次数：通过传递maxsplit参数来限制拆分的次数。 123text = &quot;apple,banana,orange,grape&quot; result = text.split(&quot;,&quot;, maxsplit=2) print(result) # 输出：['apple', 'banana', 'orange,grape'] 在这个例子中，尽管字符串中有三个逗号，但由于maxsplit被设置为2，所以只在前两个逗号处进行了拆分。 处理空白字符：如果字符串中有连续的空白字符（空格、制表符、换行符等），split()方法会默认将它们视为一个分隔符，并忽略它们。 123text = &quot;Hello World&quot; result = text.split() print(result) # 输出：['Hello', 'World'] 拆分空字符串：如果字符串为空或只包含空白字符，split()方法会返回一个空列表。 123text = &quot;&quot; result = text.split() print(result) # 输出：[] 结合其他方法使用：split()方法经常与其他字符串方法（如strip()）或列表方法（如join()）结合使用，以实现更复杂的字符串处理任务。 例如，去除拆分后每个子串的首尾空白字符： 123text = &quot; apple , banana , orange &quot; result = [item.strip() for item in text.split(&quot;,&quot;)] print(result) # 输出：['apple', 'banana', 'orange'] 或者使用join()方法将拆分后的子串重新组合成一个字符串： 1234text = &quot;apple,banana,orange&quot; fruits = text.split(&quot;,&quot;) joined_text = &quot;-&quot;.join(fruits) print(joined_text) # 输出：apple-banana-orange 输出isinstance(a, int)用来判断数据类型 12print(str[0:-1]) # 打印字符串第一个到倒数第二个字符（不包含倒数第一个字符）print(str[2:]) # 打印字符串从第三个字符开始到末尾 括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。 在括号中的数字用于指向传入对象在 format() 中的位置，如下所示： 1234 print('{0} 和 {1}'.format('Google', 'Runoob'))Google 和 Runoobprint('{1} 和 {0}'.format('Google', 'Runoob'))Runoob 和 Google 12'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%' 常见占位符 12'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.' 循环12345678names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) #打印1-100的整数 range(101)就可以生成0-100的整数序列for x in range(101): sum = sum + xprint(sum) 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 如果要对list实现类似Java那样的下标循环怎么办 12for i, value in enumerate(['A', 'B', 'C']):... print(i, value) 同时引用了两个变量 12for x, y in [(1, 1), (2, 4), (3, 9)]: print(x, y) list+for1[x * x for x in range(1, 11)] 带有if的判断 1[x * x for x in range(1, 11) if x % 2 == 0] 如果if写在for的后边必须不能带else写在前边必须带else 1[x * x if x % 2 == 0 else -1 for x in range(1, 11)] Python的for循环本质上就是通过不断调用next()函数实现的 python中函数定义时加上__就是私有函数或者私有变量 函数python内置函数所有函数网站 12345abs()pow()len()range()#生成一个不可变的序列 rang(10)生成从0-9type() #判断对象类型，使用 定义函数1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 返回多个值 12345import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 其实返回的仍然是一个值但，是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 默认参数把第二个参数n的默认值设定为2，当我们调用power(5)时，相当于调用power(5, 2)，而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。 注意： 一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）； 二是有多个默认参数时，调用的时候，既可以按顺序提供默认参数，当不按顺序提供部分默认参数时，需要把参数名写上。 三默认参数必须指向不变对象（变量，字符串，元组）！可变对象（集合，字典，列表） 12345678910def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5)25power(5, 2)25 可变参数定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234567891011def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(*nums)14calc(1, 2)5calc()0 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 123456789def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)person('Michael', 30)name: Michael age: 30 other: {}person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}extra = {'city': 'Beijing', 'job': 'Engineer'}person('Jack', 24, **extra)name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} 隐函数lambda arguments: expression 其中，arguments是函数的参数，expression是函数体，它是一个单一的表达式，其值被返回。 1234567891011# 定义一个lambda函数，接受两个参数x和y，返回它们的和 add = lambda x, y: x + y # 使用该函数 result = add(3, 5) print(result) # 输出8# 使用lambda函数和map()函数将一个列表中的每个元素都乘以2 numbers = [1, 2, 3, 4, 5] doubled = list(map(lambda x: x * 2, numbers)) print(doubled) # 输出[2, 4, 6, 8, 10] 其他库导入一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。 文件1with open('example.txt', 'r') as file: #读取文件会自动关闭 异常123456while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) 类类的定义1234567891011121314151617181920#!/usr/bin/python3 #类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 实例化类p = people('runoob',10,30)p.speak() 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 super 在Python中，是否使用super()来调用父类的__init__方法取决于几个因素，包括类的继承结构、你希望在子类中如何定制或扩展父类的行为，以及你对代码可维护性和可读性的考虑。 继承结构 当你的类是从另一个类继承而来时（单继承），你可能想要调用父类的__init__方法来设置一些基本的属性或执行一些必要的初始化操作。这时，你可以选择直接使用父类的名字来调用它，或者更普遍地使用super()。 在多重继承的场景中，使用super()尤为重要，因为它确保所有父类的方法被正确调用，而不仅仅是第一个父类。super()提供了一种动态的方式来查找并调用父类的方法，这在多继承结构中特别有用。 定制和扩展 如果子类需要定制或扩展父类的某些行为，但又不想完全重写父类的__init__方法，那么可以在子类的__init__方法中使用super()来调用父类的__init__方法，然后添加或修改特定的属性或行为。 可读性和可维护性 使用super()可以使代码更具可读性和可维护性，因为它允许你在不知道具体父类名称的情况下调用父类的方法。这在大型项目或需要频繁修改继承结构的项目中尤其重要。 多态和动态绑定 在某些情况下，使用super()可以实现多态和动态绑定，这意味着子类可以调用其任意父类中定义的同名方法，并且具体调用哪个父类的方法是在运行时决定的。 协作式多重继承 当使用多重继承时，一种好的实践是设计父类以便它们能够很好地协同工作。这意味着父类可能预期其子类（或其他子类）将调用它们的方法。在这种情况下，使用super()可以确保这种协作得到尊重。 “不是必须”的情况 值得注意的是，并不是所有情况下都必须调用父类的__init__方法。有时，子类可能完全不需要或不想继承父类的任何初始化行为。在这种情况下，子类可以自由地实现自己的__init__方法，而不必调用super()。 类的继承继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法： 12345678class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): pass 继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...。 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 123456789class Dog(Animal): def run(self): print('Dog is running...')class Cat(Animal): def run(self): print('Cat is running...') 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3 #类定义class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) s = student('ken',10,60,3)s.speak() 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 123456run_twice(Animal())Animal is running...Animal is running...run_twice(Dog())Dog is running...Dog is running... 著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 如果一个变量指向函数或者类，也可以用type()判断：返回的是Class类型 isinstance()判断类型如果继承关系是： 1object -&gt; Animal -&gt; Dog -&gt; Husky 那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象： 12345&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()isinstance(h, Husky)True 当在类里定义的固定的属性属于类属性，不归实例所有调用得使用Student.name 12class Student(object): name = 'Student' python可以动态的绑定实例比如一个类本来没有name属性，但是可以通过绑定的方式来进行绑定。 slots但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。 12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 鸭子特性是什么？ 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 多重继承 对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog： 12class Dog(Mammal, Runnable): pass 进程进程创建multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束： 1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 执行结果如下： 1234Parent process 928.Child process will start.Run child process test (929)...Process end. join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 进程池12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All su bprocesses done.') 进程间通信Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 12345678910111213141516171819202122232425262728293031from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from queue.' % value)if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() 运行结果如下： 12345678Process to write: 50563Put A to queue...Process to read: 50564Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue. 线程创建线程1234567891011121314151617import time, threading# 新线程执行的代码:def loop(): print('thread %s is running...' % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print('thread %s &gt;&gt;&gt; %s' % (threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name='LoopThread')t.start()t.join()print('thread %s ended.' % threading.current_thread().name) 进程和线程对比多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 计算密集型 vs. IO密集型 是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。 在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。 TCP编程TCP服务端： 创建套接字，绑定套接字到本地IP与端口 socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind() 开始监听连接 #s.listen() 进入循环，不断接受客户端的连接请求 #s.accept() 然后接收传来的数据，并发送给对方数据 #s.recv() , s.sendall() 传输完毕后，关闭套接字 #s.close() TCP客户端: 创建套接字，连接远端地址 socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect() 连接后发送数据和接收数据 # s.sendall(), s.recv() 传输完毕后，关闭套接字 #s.close() 客户端1234567# 导入socket库:import socket# 创建一个socket:s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('www.sina.com.cn', 80)) 创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。连接到新浪服务器的80端口，您的操作系统会从可用的临时（或称为“高位”）端口中选择一个来源端口。这个来源端口在TCP连接的另一端（即服务器）上是可见的，但它通常是由操作系统自动分配的，不需要您在应用程序中指定。 建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容： 1234567891011121314# 发送请求s.send(b'GET / HTTP/1.1\\r\\nHost: www.sina.com.cn\\r\\nConnection: close\\r\\n\\r\\n')# 接收数据:buffer = []while True: # 每次最多接收1k字节: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer)# 关闭连接:s.close() 服务器端服务器会打开固定端口（比如9999）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。 服务器端程序 1s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 1234# 监听端口:s.bind(('127.0.0.1', 9999))s.listen(5)print('Waiting for connection...') 1234567891011121314151617while True: # 接受一个新连接: sock, addr = s.accept() # 创建新线程来处理TCP连接: t = threading.Thread(target=tcplink, args=(sock, addr)) t.start()def tcplink(sock, addr): print('Accept new connection from %s:%s...' % addr) sock.send(b'Welcome!') while True: data = sock.recv(1024) time.sleep(1) if not data or data.decode('utf-8') == 'exit': break sock.send(('Hello, %s!' % data.decode('utf-8')).encode('utf-8')) sock.close() print('Connection from %s:%s closed.' % addr) 每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接： 客户端测试程序： 1234567891011s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 建立连接:s.connect(('127.0.0.1', 9999))# 接收欢迎消息:print(s.recv(1024).decode('utf-8'))for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.send(data) print(s.recv(1024).decode('utf-8'))s.send(b'exit')s.close() UDPTCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。 使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。 虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。 我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口： 123s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 绑定端口:s.bind(('127.0.0.1', 9999)) 创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据： 123456print('Bind UDP on 9999...')while True: # 接收数据: data, addr = s.recvfrom(1024) print('Received from %s:%s.' % addr) s.sendto(b'Hello, %s!' % data, addr) recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。 注意这里省掉了多线程，因为这个例子很简单。 客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据： 1234567s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据: s.sendto(data, ('127.0.0.1', 9999)) # 接收数据: print(s.recv(1024).decode('utf-8'))s.close() 从服务器接收数据仍然调用recv()方法。仍然用两个命令行分别启动服务器和客户端","link":"/2024/04/29/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"手写DQN","text":"引用库文件1234567import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimimport randomimport mathimport numpy as np 创建神经网络神经网络类以及初始化 初始化的输入是状态维度，动作维度，以及隐藏层。 12345678910class MLP(nn.Module): def __init__(self, state_dim,action_dim,hidden_dim=128): &quot;&quot;&quot; 初始化q网络，为全连接网络 state_dim: 输入的特征数即环境的状态维度 action_dim: 输出的动作维度 &quot;&quot;&quot; super(MLP, self).__init__() self.fc1 = nn.Linear(state_dim, hidden_dim) # 输入层 self.fc2 = nn.Linear(hidden_dim,hidden_dim) # 隐藏层 self.fc3 = nn.Linear(hidden_dim, action_dim) # 输出层 前向传播函数12345def forward(self, x): # 各层对应的激活函数 x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) return self.fc3(x) 创建缓冲区定义缓冲区类12345class ReplayBuffer: def __init__(self, capacity): self.capacity = capacity # 经验回放的容量 self.buffer = [] # 缓冲区 self.position = 0 定义push函数1234567def push(self, state, action, reward, next_state, done): ''' 缓冲区是一个队列，容量超出时去掉开始存入的转移(transition) ''' if len(self.buffer) &lt; self.capacity: self.buffer.append(None) self.buffer[self.position] = (state, action, reward, next_state, done) self.position = (self.position + 1) % self.capacity 定义采样函数1234def sample(self, batch_size): batch = random.sample(self.buffer, batch_size) # 随机采出小批量转移 state, action, reward, next_state, done = zip(*batch) # 解压成状态，动作等 return state, action, reward, next_state, done 创建DQNDQN类的创建以及初始化定义动作维度，状态维度，以及优化器，目标网络， 1234567891011121314151617class DQN: def __init__(self, state_dim, action_dim, cfg): self.action_dim = action_dim # 总的动作个数 self.device = cfg.device # 设备，cpu或gpu等 self.gamma = cfg.gamma # 奖励的折扣因子 # e-greedy策略相关参数 self.frame_idx = 0 # 用于epsilon的衰减计数 self.epsilon = lambda frame_idx: cfg.epsilon_end + \\ (cfg.epsilon_start - cfg.epsilon_end) * \\ math.exp(-1. * frame_idx / cfg.epsilon_decay) self.batch_size = cfg.batch_size self.policy_net = MLP(state_dim, action_dim,hidden_dim=cfg.hidden_dim).to(self.device) self.target_net = MLP(state_dim, action_dim,hidden_dim=cfg.hidden_dim).to(self.device) for target_param, param in zip(self.target_net.parameters(),self.policy_net.parameters()): # 复制参数到目标网路targe_net target_param.data.copy_(param.data) self.optimizer = optim.Adam(self.policy_net.parameters(), lr=cfg.lr) # 优化器 self.memory = ReplayBuffer(cfg.memory_capacity) # 经验回放 创建动作选择函数注意转变为tensor，再放入网络，以及取max 123456789101112def choose_action(self, state): ''' 选择动作 ''' self.frame_idx += 1 if random.random() &gt; self.epsilon(self.frame_idx): with torch.no_grad(): state = torch.tensor([state], device=self.device, dtype=torch.float32) q_values = self.policy_net(state) action = q_values.max(1)[1].item() # 选择Q值最大的动作 else: action = random.randrange(self.action_dim) return action 网络更新函数1234567891011121314151617181920212223def update(self): if len(self.memory) &lt; self.batch_size: # 当memory中不满足一个批量时，不更新策略 return # 从经验回放中(replay memory)中随机采样一个批量的转移(transition) state_batch, action_batch, reward_batch, next_state_batch, done_batch = self.memory.sample( self.batch_size) # 转为张量 state_batch = torch.tensor(state_batch, device=self.device, dtype=torch.float) action_batch = torch.tensor(action_batch, device=self.device).unsqueeze(1) reward_batch = torch.tensor(reward_batch, device=self.device, dtype=torch.float) next_state_batch = torch.tensor(next_state_batch, device=self.device, dtype=torch.float) done_batch = torch.tensor(np.float32(done_batch), device=self.device) q_values = self.policy_net(state_batch).gather(dim=1, index=action_batch) # 计算当前状态(s_t,a)对应的Q(s_t, a) next_q_values = self.target_net(next_state_batch).max(1)[0].detach() # 计算下一时刻的状态(s_t_,a)对应的Q值 # 计算期望的Q值，对于终止状态，此时done_batch[0]=1, 对应的expected_q_value等于reward expected_q_values = reward_batch + self.gamma * next_q_values * (1-done_batch) loss = nn.MSELoss()(q_values, expected_q_values.unsqueeze(1)) # 计算均方根损失 # 优化更新模型 self.optimizer.zero_grad() loss.backward() for param in self.policy_net.parameters(): # clip防止梯度爆炸 param.grad.data.clamp_(-1, 1) self.optimizer.step() main文件库文件导入123import gymimport torchfrom dqn import DQN config类12345678910111213141516171819202122232425262728293031323334class Config: '''超参数 ''' def __init__(self): ################################## 环境超参数 ################################### self.algo_name = 'DQN' # 算法名称 self.env_name = 'CartPole-v0' # 环境名称 self.device = torch.device( &quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) # 检测GPUgjgjlkhfsf风刀霜的撒发十 self.seed = 10 # 随机种子，置0则不设置随机种子 self.train_eps = 200 # 训练的回合数 self.test_eps = 30 # 测试的回合数 ################################################################################ ################################## 算法超参数 ################################### self.gamma = 0.95 # 强化学习中的折扣因子 self.epsilon_start = 0.90 # e-greedy策略中初始epsilon self.epsilon_end = 0.01 # e-greedy策略中的终止epsilon self.epsilon_decay = 500 # e-greedy策略中epsilon的衰减率 self.lr = 0.0001 # 学习率 self.memory_capacity = 100000 # 经验回放的容量 self.batch_size = 64 # mini-batch SGD中的批量大小 self.target_update = 4 # 目标网络的更新频率 self.hidden_dim = 256 # 网络隐藏层 ################################################################################ ################################# 保存结果相关参数 ################################ self.result_path = curr_path + &quot;/outputs/&quot; + self.env_name + \\ '/' + curr_time + '/results/' # 保存结果的路径 self.model_path = curr_path + &quot;/outputs/&quot; + self.env_name + \\ '/' + curr_time + '/models/' # 保存模型的路径 self.save = True # 是否保存图片 ################################################################################ 创建环境和智能体函数123456789101112def env_agent_config(cfg): ''' 创建环境和智能体 ''' env = gym.make(cfg.env_name) # 创建环境 state_dim = env.observation_space.shape[0] # 状态维度 action_dim = env.action_space.n # 动作维度 agent = DQN(state_dim, action_dim, cfg) # 创建智能体 if cfg.seed !=0: # 设置随机种子 torch.manual_seed(cfg.seed) env.seed(cfg.seed) np.random.seed(cfg.seed) return env, agent 训练函数1234567891011121314151617181920212223242526def train(cfg, env, agent): ''' 训练 ''' print('开始训练!') print(f'环境：{cfg.env_name}, 算法：{cfg.algo_name}, 设备：{cfg.device}') rewards = [] # 记录所有回合的奖励 ma_rewards = [] # 记录所有回合的滑动平均奖励 for i_ep in range(cfg.train_eps): ep_reward = 0 # 记录一回合内的奖励 state = env.reset() # 重置环境，返回初始状态 while True: action = agent.choose_action(state) # 选择动作 next_state, reward, done, _ = env.step(action) # 更新环境，返回transition agent.memory.push(state, action, reward, next_state, done) # 保存transition state = next_state # 更新下一个状态 agent.update() # 更新智能体 ep_reward += reward # 累加奖励 if done: break if (i_ep + 1) % cfg.target_update == 0: # 智能体目标网络更新 agent.target_net.load_state_dict(agent.policy_net.state_dict()) print('完成训练！') env.close() return rewards, ma_rewards main函数12345678910if __name__ == &quot;__main__&quot;: cfg = Config() # 训练 env, agent = env_agent_config(cfg) rewards, ma_rewards = train(cfg, env, agent) make_dir(cfg.result_path, cfg.model_path) # 创建保存结果和模型路径的文件夹 agent.save(path=cfg.model_path) # 保存模型 save_results(rewards, ma_rewards, tag='train', path=cfg.result_path) # 保存结果 plot_rewards(rewards, ma_rewards, cfg, tag=&quot;train&quot;) # 画出结果","link":"/2024/04/29/%E6%89%8B%E5%86%99DQN/"},{"title":"推荐系统-推荐系统简介","text":"在这个时代中，信息的生产者很难将信息呈现在对它们感兴趣的信息消费者面前，而对于信息消费者也很难从海量的信息中找到自己感兴趣的信息。推荐系统就是一个将信息生产者和信息消费者连接起来的桥梁。面对数以万计的物品，需要一个人或者一个工具（它分析你的历史兴趣）把用户感兴趣的内容推荐到用户面前。这就是推荐算法的工作。推荐系统更能满足用户不明确的需求。推荐系统可以解决长尾效应。 推荐系统的类型：基于物品的推荐，基于用户的推荐 推荐系统的应用：网购，电影和视频网站，个性化音乐电台，社交网络，个性化阅读，基于位置的推荐，个性化邮件，个性化广告 好的推荐系统不仅可以预测用户需求，还可以拓展用户需求，帮助用户发现需求。 推荐系统的测评指标推荐系统的实验方法：离线实验获取用户的数据，并分为训练集和测试集，通过对训练集进行推荐系统的训练可以在测试集上验证推荐系统的结果。 优点： 不需要用户参与 速度快 缺点： 无法计算商业上关心的指标（点击率，转换率） 用户调查：可以获得用户的真实感受，但是成本高，风险高 ABtest将用户随机分为几组，每一组用户采用不同的算法，然后统计不同组用户的各种测评指标 优点： 获取到点击率等指标 缺点： 周期长 系统的实验流程一个推荐算法的上线，必须经过离线实验-&gt;用户调研-&gt;ABtest 评测指标用户满意度​ 通过问卷或者实际的消费行为，点击率，用户停留时间，转换率来度量用户满意度。 预测准确率​ 是最重要的离线测试指标。主要分为评分预测和topN预测 评分预测 在已知用户看了一个电影之后预测用户可可能给电影的评分。评价指标主要是均方误差和平均绝对误差 RMSE加大对预测不准的惩罚 topN预测 topN是为用户推荐最感兴趣的N的电影。准确率一般是通过准确率/召回率得到的 召回率：R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u)是用户在测试集上的行为列表。 准确率： 覆盖率通过研究物品在推荐列表中出现的次数的分布描述覆盖率，如果比较陡峭就说明没有均匀的覆盖，覆盖率就比较低。覆盖率的表现形式除了可以使用物品是否被推荐给至少一个用户，还可以使用信息熵和基尼系数。 信息熵：p(i)是物品i的流行度除以所有物品流行度之和 ，信息熵越大代表事物发生的不确定性越大，信息量就越多。 基尼系数：是衡量一个数据不平等程度的指标之一。数值越高表示越不平等，而数值越低则表示越平等。Lorenz 曲线是一个图形，将按照从低到高进行排序，然后横轴表示物品i比例，纵轴表示物品流行度比例。基尼系数 ${i_j}$是按照物品流行度p()从小到大排序的物品列表中第j个物品。下面的代码可以用来计算给定物品流行度分布后的基尼系数： 基尼系数越小则推荐越平均。 多样性多样性描述了推荐列表中物品两两之间的不相似性。 推荐系统需要涵盖用户不同的兴趣领域，而不是只含有一个物品的分类。 新颖性：评测新颖度的最简单方法是利用推荐结果的平均流行度，因为越不热门的物品越可能让用户觉得新颖。 惊喜度：一个完全对用户没有相关的电影，用户看完之后感觉很喜欢那么就给用户带来了惊喜。 实时性首先，推荐系统需要实时地更新推荐列表来满足用户新的行为变化。 推荐系统需要能够将新加入系统的物品推荐给用户（冷启动）。 商业目标：商业目标和网站的盈利模式是息息相关的。 测评指标的获取途径","link":"/2024/04/29/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"},{"title":"推荐系统-冷启动问题","text":"推荐系统冷启动问题主要分为三类 用户冷启动：用户冷启动主要解决如何给新用户做个性化推荐的问题。 物品冷启动 ：物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题 系统冷启动 ：系统冷启动主要解决如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统， 可能得解决方案： 提供非个性化的推荐：热门排行榜，随机推荐 利用年龄等数据做粗粒度的个性化 通过社交账户登陆导入用户好友信息 登陆时收集用户兴趣信息 对于新加入的物品，可以利用内容信息 在系统冷启动时，可以引入专家的知识，通过一定的高效方式迅速建立起物品的相关度表。 利用用户注册信息用户的注册信息分3种： 人口统计学信息 包括用户的年龄、性别、职业、民族、学历和居住地。 用户兴趣的描述 有一些网站会让用户用文字描述他们的兴趣。 从其他网站导入的用户站外行为数据 比如用户通过豆瓣、新浪微博的账号登录，就可以在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据。 人口统计学人口统计学特征包括年龄、性别、工作、学历、居住地、国籍、民族等，这些特征对预测用户的兴趣有很重要的作用，比如男性和女性的兴趣不同， 不同年龄的人兴趣也不同。 图3-3是一个基于用户人口统计学特征推荐的简单例子。如图所示，当一个新的注册用户访问推荐系统时，我们首先从用户注册信息数据库中查询他的注册信息。比如图3-3中的用户，我们查到他是一位28岁的男性，是一位物理学家。然后，查询3张离线计算好的相关表：一张是性别-电视剧相关表，从中可以查询男性最喜欢的电视剧；一张是年龄-电视剧相关表，从中可以查询到28岁用户最喜欢的电视剧；一张是职业-电视剧相关表，可以查询到物理学家最喜欢的电视剧。然后，我们可以将用这3张相关表查询出的电视剧列表按照一定权重相加，得到给用户的最终推荐列表。 所以我们需要计算对于某种特征的用户喜欢什么样的物品 我们可以将${p(f,i)}$ 定义为喜欢物品i的用户中具有特征f的比例 这里分母中使用参数$a$ 的目的是解决数据稀疏问题。比如有一个物品只被1个用户喜欢过，而这个用户刚好就有特征f，那么就有 ${p(f,i)=1}$ 。但是，这种情况并没有统计意义，因此我们为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。 Lastfm数据集包含了更多的用户人口统计学信息，包括用户的性别、年龄和国籍。图3-4给出了该数据集中用户性别的分布。 我们准备用该数据集对比一下使用不同的人口统计学特征预测用户行为的精度。 在测试集中给每一类用户推荐${p(f,i)}$最高的10个物品，并通过准确率和召回率计算预测准确度。同时，我们也会计算推荐的覆盖率来评测推荐结果 MostPopular 给用户推荐最热门的歌手。 GenderMostPopular 给用户推荐对于和他同性别的用户最热门的歌手，这里我们将用户分成男女两类。 AgeMostPopular 给用户推荐对于和他同一个年龄段的用户最热门的歌手，这里我们将10岁作为一个年龄段，将用户按照不同的年龄段分类。 CountryMostPopular 给用户推荐对于和他同一个国家的用户最热门的歌手。 DemographicMostPopular 给用户推荐对于和他同性别、年龄段、国家的用户最热门的歌手。 这 4 种 算 法 具 有 不 同 的 粒 度 ， 其 中 MostPopular 粒 度 最 粗 ， 而DemographicMostPopular算法的粒度最细。结果显示利用的用户人口统计学特征越多，越能准确地预测用户兴趣。 收集用户兴趣信息登录时用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐 启动用户兴趣的物品需要具有以下特点： 比较热门 如果要让用户对一个物品进行反馈，前提是用户知道这个物品是什么东西。 具有代表性和区分性 启动用户兴趣的物品不能是大众化或老少咸宜的， 启动物品集合需要有多样性 在冷启动时，我们不知道用户的兴趣，而用户兴趣的可能性非常多，为了匹配多样的兴趣，我们需要提供具有很高覆盖率的启动物品集合 Nadav Golbandi 通过如下方式度量一个物品的区分度D(i): 其中，${N^{+}(i)}$是喜欢物品i的用户集合，${N^{-}(i)}$ 是不喜欢物品i的用户集合，$ {\\overline{N}(i)}$是没有对物品i评分的用户集合。第一个是是喜欢物品i的用户对其他物品评分的方差，第二个是是不喜欢物品i的 用户对其他物品评分的方差， 第三个是没有对物品i评分的用户对其他物品评分的方差。也就是说，对于物品i， Nadav Golbandi将用户分成3类——喜欢物品i的用户、不喜欢物品i的用户和不知道物品i的用户（即没有给i评分的用户）。如果这3类用户集合内的用户对其他的物品兴趣很不一致，说明物品i具有较高的区分度。 当用户对某个物品有兴趣时，他们对其他物品的评分方差较大可能表明以下几个情况： 多样性的反映: 用户对其他物品的评分分布较为广泛，涵盖了不同类型和风格的物品。这可能意味着用户的兴趣比较多元化，对不同类型的物品都有一定程度的兴趣。因此，这种情况下推荐系统需要更加细致地分析用户的兴趣，提供更加多样化和个性化的推荐，以满足用户的多样化需求。 较强的区分度: 当用户对其他物品的评分方差较大时，不同用户之间的兴趣差异可能较为显著。这意味着推荐系统可以更好地区分用户之间的兴趣差异，从而提供更具针对性的推荐。例如，对于具有较大评分方差的用户，推荐系统可以更加精细地调整推荐策略，提供更符合其个性化需求的推荐结果。 并不是说这个物品很有区分度喜欢这个物品对其他物品的喜欢程度也相同，那么它可能并不符合热门 例子：通过一个简单的例子解释Nadav Golbandi的算法。如图所示，假设通过分析用户数据，我们发现《变形金刚》最有区分度。而在喜欢《变形金刚》的用户中《钢铁侠》最有区分度，不知道《变形金刚》的用户中《阿甘正传》最有区分度，不喜欢《变形金刚》的用户中《泰坦尼克号》最有区分度。进一步分析，我们发现不喜欢《变形金刚》但喜欢《泰坦尼克号》的用户中，《人鬼情未了》最有区分度。那么，假设来了一个新用户，系统会首先询问他对《变形金刚》的看法，如果他说不喜欢，我们就会问他对《泰坦尼克》号的看法，如果他说喜欢，我们就会问他对《人鬼情未了》的看法，如果这个时候用户停止了反馈，我们也大概能知道该用户可能对爱情片比较感兴趣，对科幻片兴趣不大。 利用物品的内容信息首先需要指出的是， UserCF算法对物品冷启动问题并不非常敏感。因为， UserCF在给用户进行推荐时，会首先找到和用户兴趣相似的一群用户，然后给用户推荐这一群用户喜欢的物品。在很多网站中，推荐列表并不是给用户展示内容的唯一列表，那么当一个新物品加入时，总会有用户从某些途径看到这些物品，对这些物品产生反馈。因此该物品就能不断地扩散开来，从而逐步展示到对它感兴趣用户的推荐列表中 对于ItemCF算法来说，物品冷启动就是一个严重的问题了。因为ItemCF算法的原理是给用户推荐和他之前喜欢的物品相似的物品。 ItemCF算法会每隔一段时间利用用户行为计算物品相似度表（一般一天计算一次），在线服务时ItemCF算法会将之前计算好的物品相关度矩阵放在内存中。因此，当新物品加入时，内存中的物品相关表中不会存在这个物品，从而ItemCF算法无法推荐新的物品。解决这一问题的办法是频繁更新物品相似度表，但基于用户行为计算物品相似度是非常耗时的事情，主要原因是用户行为日志非常庞大。而且，新物品如果不展示给用户，用户就无法对它产生行为，通过行为日志计算是计算不出包含新物品的相关矩阵的。为此，我们只能利用物品的内容信息计算物品相关表，并且频繁地更新相关表（比如半小时计算一次）。 因为我们需要根据物品的内容和信息对物品打上标签 对物品d，它的内容表示成一个关键词向量如下： 其中， ei 就是关键词， wi 是关键词对应的权重。 在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算： 可以采用第二章的倒排表加速这一计算过程在得道相似度之后可以利用上一章提到的ItemCF算法的思想，给用户推荐和他历史上喜欢的物品内容相似的物品。 专家经验标注首先，它让专家对电影进行标记，每个电影都有大约50个基因，这些基因来自大约1000个基因库。然后，在专家标记一定的样本后， Jinni会使用自然语言理解和机器学习技术，通过分析用户对电影的评论和电影的一些内容属性对电影（特别是新电影）进行自己的标记。同时， Jinni也设计了让用户对基因进行反馈的界面，希望通过用户反馈不断改进电影基因系统。","link":"/2024/05/10/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8/"},{"title":"强化学习","text":"强化学习（reinforcement learning，RL）讨论的问题是智能体（agent）怎么在复杂、不确定的环境（environment）里面去最大化它能获得的奖励。 强化学习概念智能体做出动作，并影响于环境 环境返回作用后的状态，和上一步的奖励 奖励是由环境给可显示智能体在某一步采取某个策略的表现如何？ 延迟奖励与序列生成在一个强化学习环境里面，智能体的目的就是选取一系列的动作来最大化奖励，所以这些选取的动作 必须有长期的影响。 在做出游戏时当前帧对动作进行采样，生成很多局游戏。我们将当前的智能体与环境交互，会得到一系列观测。每一个观测可看成一个轨迹（trajectory）。 轨迹就是当前帧以及它采取的策略。 动作空间离散动作空间（discrete action space） 连续动作空间（continuous action space） 策略随机性策略（stochastic policy）就是 π 函数，即 $\\pi(a|s)=p\\left(a_t=a|s_t=s\\right)$。输入一个状态 s，输出一个概率。这个概率是智能体所有动作的概率，然后对这个概率分布进行采样，可得到智能体将采取的 动作。比如可能是有 0.7 的概率往左，0.3 的概率往右，那么通过采样就可以得到智能体将采取的动作。 确定性策略（deterministic policy）就是智能体直接采取最有可能的动作，即 $a^*=\\arg\\text{max}\\pi(a\\mid s)$​。 价值函数对未来奖励的预测，我们用它来评估状态的好坏。 状态价值函数：反应在当前状态下我们使用策略 π 的时候，未来可以获得的奖励。 $V_\\pi(s)\\doteq\\mathbb{E}\\pi\\left[G_t\\mid s_t=s\\right]=\\mathbb{E}\\pi\\left[\\sum{k=0}^\\infty\\gamma^kr{t+k+1}\\mid s_t=s\\right],\\text{对于所有的}s\\in S$ 动作价值函数：反应在当前状态下我们做出动作a，未来可以获得的奖励。 $Q_\\pi(s,a)\\doteq\\mathbb{E}\\pi\\left[G_t\\mid s_t=s,a_t=a\\right]=\\mathbb{E}\\pi\\left[\\sum{k=0}^\\infty\\gamma^kr{t+k+1}\\mid s_t=s,a_t=a\\right]$ Q：基于价值的智能体和基于策略的智能体有什么区别？A：基于策略的智能体：智能体会制定一套动作策略（确定在给定状态下需要采取何种动作），并根据这个策略进行操作。强化学习算法直接对策略进行优化，使制定的策略能够获得最大的奖励。 基于价值的智能体：智能体维护一个价值表格或价值函数，并通过这个价值表格或价值函数来选取价值最大 的动作。基于价值迭代的方法只能应用在不连续的、离散的环境下。 Q：有模型智能体与无模型只智能体的区别A: 如果这个四元组中所有元素均已知，且状态集合和动作集合在有限步数内是有限集，则智能体都已知这些可以对真实环境进行建模，构建一个虚拟世界来模拟真实环境中的状态和交互反应。具体来说，智能体知道状态是如何转移的和奖励函数是如何产生的，它就能知道在某一状态下执行某一动作后能带来的奖励和环境的下一状态，这样智能体就可以直接在虚拟世界中学习和规划策略（动态规划算法）即可。 无模型强化学习没有对真实环境进行建模，智能体只能在真实环境中通过一定的策略来执行动作，等待奖励和状态迁移，然后根据这些反馈信息来更新动作策略，这样反复迭代直到学习到最优策略。所以无模型强化学习是通过不断地探索来进行学习的。 Q：强化学习与监督学习的区别监督学习： 监督学习的数据时符合一个独立同分布的（相互之间没有关系） 做出预测之后我们直接告诉他预测结果的对错，进而计算损失函数来训练神经网络。 强化学习： 是通过与环境进行交互，每个输入的状态之间有很强的连续性， 当智能体（神经网络）做出动作后不会立刻收到反馈，也不能很清楚的知道对错。学习器需要自己去发现哪些动作可以带来 最多的奖励，只能通过不停地尝试来发现最有利的动作 智能体获得自己能力的过程，其实是不断地试错探索（trial-and-error exploration）的过程。探索 （exploration）和利用（exploitation）是强化学习里面非常核心的问题。 强化学习既不属于监督学习也不属于无监督学习，它是一种独立的机器学习范式。 马尔科夫决策过程智能体交互过程智能体得到环境的状态后，它会采取动作，并 把这个采取的动作返还给环境。环境得到智能体的动作后，它会进入下一个状态，把下一个状态传给智能体。 马尔可夫性质指一个随机过程在给定现在状态及所有过 去状态情况下，其未来状态的条件概率分布仅依赖于当前状态 马尔可夫过程是一组具有马尔可夫性质的随机变量序列 s1, · · · , st，其中下一个时刻的状态 $s_{t+1}$ 只取 决于当前状态 st。我们设状态的历史为 $h_t={s_1,s_2,s_3,\\ldots,s_t}$（ht 包含了之前的所有状态），则马尔可夫 过程满足条件 $p\\left(s_{t+1}\\mid s_t\\right)=p\\left(s_{t+1}\\mid h_t\\right)$ 贝尔曼期望方程是当前状态与未来状态的迭代关系，表示当前状态的价值函数可以通过下个状态的价 值函数来计算。 所以说贝尔曼方程定义了状态之间的迭代关系，即 $V(s)=R(s)+\\gamma\\sum_{s’\\in S}p\\left(s’\\mid s\\right)V\\left(s’\\right)$ 时序差分学习（temporal-difference learning，TD learning）的方法 马尔可夫奖励过程的转移$P_{\\pi}\\left(s’\\mid s\\right)=\\sum_{a\\in A}\\pi(a\\mid s)p\\left(s’\\mid s,a\\right)$ Q 函数也被称为动作价值函数（action-value function）。Q 函数定义的是在某一个状态采取某一个动作，它有可能得到的回报的一个期望，即 $Q_\\pi(s,a)=\\mathbb{E}_\\pi\\left[G_t\\mid s_t=s,a_t=a\\right]$ 推导过程： 贝尔曼期望方程$V_{\\pi}(s)=\\mathbb{E}{\\pi}\\left[r{t+1}+\\gamma V_{\\pi}\\left(s_{t+1}\\right)\\mid s_{t}=s\\right]$ 策略评估 马尔可夫决策过程控制 策略评估是指给定马尔可夫决策过程和策略，我们可以估算出价值函数的值。如果我们只有马尔可夫 决策过程，那么应该如何寻找最佳的策略，从而得到最佳价值函数（optimal value function）呢 $V^*(s)=\\max_{\\pi}V_\\pi(s)$ 我们搜索一种策略 π 让每个状态的价值最大。V ∗ 就是到达每一个状态，它的值的最 大化情况。在这种最大化情况中，我们得到的策略就是最佳策略， $\\pi^*(s)=\\arg\\max_\\pi V_\\pi(s)$ Q:策略迭代与价值迭代的区别 策略迭代分两步。首先进行策略评估，即对当前已经搜索到的策略函数进行估值。得到估值后，我们进行策略改进， 即把 Q 函数算出来，进行进一步改进。不断重复这两步，直到策略收敛。价值迭代直接使用贝尔曼最优方程进行迭代，从而寻找最佳的价值函数。找到最佳价值函数后，我们再提取最佳策略。 面试问题2-1 友善的面试官: 请问马尔可夫过程是什么？马尔可夫决策过程又是什么？其中马尔可夫最重要的 性质是什么呢？ 2-2 友善的面试官: 请问我们一般怎么求解马尔可夫决策过程？ 2-3 友善的面试官: 请问如果数据流不具备马尔可夫性质怎么办？应该如何处理？ 2-4 友善的面试官: 请分别写出基于状态价值函数的贝尔曼方程以及基于动作价值函数的贝尔曼方程。 2-5 友善的面试官: 请问最佳价值函数 V ∗ 和最佳策略 π∗ 为什么等价呢？ 2-6 友善的面试官：能不能手写一下第 n 步的价值函数更新公式呀？另外，当 n 越来越大时，价值函 数的期望和方差是分别变大还是变小呢？ 强化学习方法——表格方法 如图所示，在 t − 1 时刻，我看到熊对我招手，下意识的动作就是逃跑。熊看到有人逃跑，就可能觉得发现了猎物，并开始发动攻击。而在 t 时刻， 我如果选择装死的动作，可能熊咬咬我、摔几下就觉得挺无趣的，可能会走开。这个时候我再逃跑，可能 就成功了，这就是一个序列决策过程。 在多次尝试和熊打交道之后，我们就可以对熊的不同的状态做出判断，用状态动作价值来表达在某个 状态下某个动作的好坏。如图 3.6 所示，如果 Q 表格是一张已经训练好的表格，这张表格就像是一本生 活手册。通过查看这本手册，我们就知道在熊发怒的时候，装死的价值会高一点；在熊离开的时候，我们 偷偷逃跑会比较容易获救。 Q: 为什么我们可以用未来的总奖励来评价当前动作是好是坏? 这是因为在现实世界中奖励往往是延迟的，所以强化学习需要学习远期的奖励。我们一 般会从当前状态开始，把后续有可能会收到的所有奖励加起来计算当前动作的 Q 值，让 Q 值可以真正代 表当前状态下动作的真正价值。 无模型的预测——蒙特卡洛方法蒙特卡洛方法是基于采样的方法，给定策略 π，我们让智能体与环境进行交互，可以得到很多轨迹。 每个轨迹都有对应的回报： $G_t=r_{t+1}+\\gamma r_{t+2}+\\gamma^2r_{t+3}+\\ldots $ 我们求出所有轨迹的回报的平均值，就可以知道某一个策略对应状态的价值，即 $V_\\pi(s)=\\mathbb{E}_{\\tau\\sim\\pi}\\left[G_t\\mid s_t=s\\right]$ 蒙特卡洛 方法使用经验平均回报（empirical mean return）的方法来估计，它不需要马尔可夫决策过程的状态转移 函数和奖励函数，并且不需要像动态规划那样用自举的方法。 通过采样的办法计算它，从某个状态开始，把小船放到状态转移矩阵里面，让它“随波逐流”，这样就会产生一个轨 迹。产生一个轨迹之后，就会得到一个奖励，那么直接把折扣的奖励即回报 g 算出来。算出来之后将它积 累起来，得到回报 Gt。当积累了一定数量的轨迹之后，我们直接用 Gt 除以轨迹数量，就会得到某个状态 的价值。 我们使用蒙特卡洛方法得到的轨迹对应树上蓝色的轨迹，轨迹上的状态已经是决定 的，采取的动作也是已经决定的。我们现在只更新这条轨迹上的所有状态，与这条轨迹没有关系的状态都 不进行更新。 蒙特卡洛相比动态规划 蒙特卡洛方法相比动态规划方法是有一些优势的。首先，蒙特卡洛方法适用于环境未知的情况，而动 态规划是有模型的方法。蒙特卡洛方法只需要更新一条轨迹的状态，而动态规划方法需要更新所有的状态。 状态数量很多的时候（比如 100 万个、200 万个），我们使用动态规划方法进行迭代，速度是非常慢的。这 也是基于采样的蒙特卡洛方法相对于动态规划方法的优势。 无模型的预测——时序差分方法时序差分方法的目的是对于某个给定的策略 π，在线地算出它的价值函数，即一步一步地（step-by-step）算。最简单的算法是一步时序差分（one-step TD）， 即 TD(0)。每往前走一步，就做一步自举，用得到的估计回报$r_{t+1}+\\gamma V(s_{t+1})$​来更 新上一时刻的值 V (st)： $V\\left(s_t\\right)\\leftarrow V\\left(s_t\\right)+\\alpha\\left(r_{t+1}+\\gamma V\\left(s_{t+1}\\right)-V\\left(s_t\\right)\\right)$ 它相比动态规划不在记录所有的概率的回报了而是只计算自身概率的回报，相比蒙特卡洛他只需要一步时序差分 时序差分误差（TD error）$\\delta=r_{t+1}+\\gamma V(s_{t+1})-V(s_t)$。类比增量式蒙特卡洛方法，给定一个回合 i，我们可以更新 V (st) 来逼近真实的回报 Gt，具体更新公式为 $V\\left(s_t\\right)\\leftarrow V\\left(s_t\\right)+\\alpha\\left(G_{i,t}-V\\left(s_t\\right)\\right)$ 比较时序差分方法和蒙特卡洛方法。 （1）时序差分方法可以在线学习（online learning），每走一步就可以更新，效率高。蒙特卡洛方法必 须等游戏结束时才可以学习。 （2）时序差分方法可以从不完整序列上进行学习。蒙特卡洛方法只能从完整的序列上进行学习。 （3）时序差分方法可以在连续的环境下（没有终止）进行学习。蒙特卡洛方法只能在有终止的情况下 学习。 （4）时序差分方法利用了马尔可夫性质，在马尔可夫环境下有更高的学习效率。蒙特卡洛方法没有假设环境具有马尔可夫性质，利用采样的价值来估计某个状态的价值，在不是马尔可夫的环境下更加有效。 通过调整TD的步数，可以进行蒙特卡洛方法和时序差分方法之间的权衡。如果 n = ∞，即 整个游戏结束后，再进行更新，时序差分方法就变成了蒙特卡洛方法。如果时序差分方法需要更广度的更新，就变成了动态规划方法（因为动态规划方法 是把所有状态都考虑进去来进行更新）。如果时序差分方法需要更深度的更新，就变成了蒙特卡洛方法。 n 步时序差分可写为 无模型的控制——策略迭代策略迭代由两个步骤组成。第一，我们根据给定的当前策略 π 来估计价值函数；第二，得到估计的价值函数后，我们通过贪心的方法来改进策略，即 为了保证足够和有方向的探索，ε-贪心（ε-greedy）探索。ε-贪心是指我们有 1 − ε 的概率会按照 Q 函数来决定动作，通常 ε 就设一个很小的值，1 − ε 可能是 0.9，也就是 0.9 的概 率会按照 Q 函数来决定动作，但是我们有 0.1 的概率是随机的。通常在实现上，ε 的值会随着时间递减。 Sarsa：同策略时序差分控制Sarsa 将原本时序差分方法更新 V 的过程，变成了更新 Q，Sarsa 属于单步更新算法，每执行一个动 作，就会更新一次价值和策略。 $Q\\left(s_t,a_t\\right)\\leftarrow Q\\left(s_t,a_t\\right)+\\alpha\\left[r_{t+1}+\\gamma Q\\left(s_{t+1},a_{t+1}\\right)-Q\\left(s_t,a_t\\right)\\right]$ Q 学习：异策略时序差分控制Q 学习是一种异策略（off-policy）算法。异策略在学习的过程中，有两种不同的策 略：目标策略（target policy）和行为策略（behavior policy）。目标策略是我们需要去学习的策略，一 般用 π 来表示。行为策略是探索环境的策略，一般用 μ 来表示。行为策略可以大胆地去探索到所有 可能的轨迹，采集轨迹，采集数据，然后把采集到的数据“喂”给目标策略学习。 在异策略学习的过程中，轨迹都是行为策略与环境交互产生的，产生这些轨迹后，我们使用这些轨迹 来更新目标策略 π。异策略学习有很多好处。首先，我们可以利用探索策略来学到最佳的策略，学习效率高；其次，异策略学习可以让我们学习其他智能体的动作，进行模仿学习，学习人或者其他智能体产生的 轨迹；最后，异策略学习可以让我们重用旧的策略产生的轨迹，探索过程需要很多计算资源，这样可以节 省资源。 $Q\\left(s_t,a_t\\right)\\leftarrow Q\\left(s_t,a_t\\right)+\\alpha\\left[r_{t+1}+\\gamma\\max_aQ\\left(s_{t+1},a\\right)-Q\\left(s_t,a_t\\right)\\right]$ 同策略与异策略的区别 在强化学习中，同策略（on-policy）和异策略（off-policy）是两种不同的学习方法，它们之间的主要区别在于它们如何处理采样的轨迹或经验。 同策略（On-policy）： 在同策略方法中，学习算法使用与当前策略相同的策略来生成经验，并且使用这些经验来更新当前的策略。 具体来说，同策略方法通常使用蒙特卡洛方法或时序差分学习（如TD-learning），在每次迭代中直接利用当前策略生成的轨迹来更新策略。 由于同策略方法直接依赖于当前策略生成的经验，因此它们更容易收敛到局部最优解，但在处理探索和利用之间的权衡时可能会有一定的限制。 异策略（Off-policy）： 在异策略方法中，学习算法使用与当前策略不同的策略生成经验，并且使用这些经验来更新一个或多个不同的目标策略。 具体来说，异策略方法通常利用重要性采样等技术来估计不同策略之间的期望值，然后使用这些估计来更新目标策略。 异策略方法具有更大的灵活性，因为它们可以利用已有数据来更新目标策略，而无需依赖于当前策略生成的轨迹。这使得异策略方法在探索和利用之间的权衡方面更加灵活。 面试3-1 友善的面试官：同学，你能否简述同策略和异策略的区别呢？ 3-2 友善的面试官：能否细致地讲一下 Q 学习算法，最好可以写出其 Q(s, a) 的更新公式。另外，它 是同策略还是异策略，原因是什么呢？ 3-3 友善的面试官：好的，看来你对于 Q 学习算法很了解，那么能否讲一下与 Q 学习算法类似的 Sarsa 算法呢，最好也可以写出其对应的 Q(s, a) 更新公式。另外，它是同策略还是异策略，为什么？ 3-4 友善的面试官：请问基于价值的方法和基于策略的方法的区别是什么？ 3-5 友善的面试官：请简述一下时序差分方法。 3-6 友善的面试官：请问蒙特卡洛方法和时序差分方法是无偏估计吗？另外谁的方差更大呢？为什么？ 3-7 友善的面试官：能否简单说一下动态规划方法、蒙特卡洛方法和时序差分方法的异同点？ 策略梯度Actor的策略决定了演员的动作，即给定一个输入，它会输 出演员现在应该要执行的动作。策略一般记作 π。假设我们使用深度学习来做强化学习，策略就是一个网络。网络里面有一些参数， 我们用 θ 来代表 π 的参数。一场游戏称为一个回合。将这场游戏里面得到的所有奖励都加起来，就是总奖励（total reward），也就是回报，我们用 R 来表示它。 在一场游戏里面，我们把环境输出的 s 与演员输出的动作 a 全部组合起来，就是一个轨迹，即 给定演员的参数 θ，我们可以计算某个轨迹 τ 发生的概率为 总奖励使用 τ 策略出现的概率进行加权，对所有的 τ 进行求和，就是期望值。给定一个参数，我们可以计算期望值为 $\\bar{R}\\theta=\\sum_\\tau R(\\tau)p_\\theta(\\tau)=\\mathbb{E}{\\tau\\sim p_\\theta(\\tau)}[R(\\tau)]$ 我们要最大化期望奖励。因为我们要让奖励越大越好，所以可以使用梯度上升（gradient ascent）来最大化期望奖励。 我们对 ̄ Rθ 做梯度运算 由公式$\\nabla f(x)=f(x)\\nabla\\log f(x)$得$\\nabla p_\\theta(\\tau)=p_\\theta(\\tau)\\nabla\\log p_\\theta(\\tau)$ 我们对 τ 进行求和，把 R(τ ) 和 log pθ(τ ) 这两项使用 pθ(τ ) 进行加权，既然使用 pθ(τ ) 进行加权，它们就可以被写成期望的形式。也就是我们从 pθ(τ ) 这个分布里面采样 τ ，去计算 R(τ ) 乘 ∇ log pθ(τ )，对所有可能的 τ 进行求和，就是期望的值（expected value） 可以看到最后的结果和奖励的正负成完全相关，我们用梯度上升来更新参数 更新完模型以后，我们要重新采样数据再更新模型。注意，一般策略梯度（policy gradient，PG） 采样的数据只会用一次。我们采样这些数据，然后用这些数据更新参数，再丢掉这些数据。接着重新采样 数据，才能去更新参数。 策略梯度实现技巧增加基线 但在很多游 戏里面，奖励总是正的，最低都是 0。假设我们在某一个状态有 3 个动作 a、b、c 可以执行。根据式 (4.16)，我们要把这 3 个动作的概率，对数概率都提高。但是它们前面的权重 R(τ ) 是不一样的。权重是有大有小的，权重小 的，该动作的概率提高的就少；权重大的，该动作的概率提高的就多。因为对数概率是一个概率，所以动 作 a、b、c 的对数概率的和是 0。所以提高少的，在做完归一化（normalize）以后，动作 b 的概率就是下 降的；提高多的，该动作的概率才会上升。 但是但我们真正在学习的时候，只是采样了少量的 s 与 a 的对。因为我们做 的是采样，所以有一些动作可能从来都没有被采样到。但我们可能只采样到动作 b 或者只采样到动作 c，没有采样到动作 a。但现在所有动作的 奖励都是正的，所以根据式 (4.16)，在这个状态采取 a、b、c 的概率都应该要提高。我们会遇到的问题是， 因为 a 没有被采样到，所以其他动作的概率如果都要提高，a 的概率就要下降。所以 a 不一定是一个不好 的动作，它只是没有被采样到。 为了解决奖励总是正的的问题，我们可以把奖励减 b，即 分配合适的分数一个做法是计算某个状态-动作对的奖励的时候，不把整场游戏得到的奖励全部加起来，只计算从这 个动作执行以后得到的奖励。因为这场游戏在执行这个动作之前发生的事情是与执行这个动作是没有关系 的，所以在执行这个动作之前得到的奖励都不能算是这个动作的贡献。我们把执行这个动作以后发生的所 有奖励加起来，才是这个动作真正的贡献。 REINFORCE：蒙特卡洛策略梯度我们介绍一下策略梯度中最简单的也是最经典的一个算法 REINFORCE。REINFORCE 用的是回合更新的方式REINFORCE 用的是回 合更新的方式，它在代码上的处理上是先获取每个步骤的奖励，然后计算每个步骤优化每一个动作的输出。所以我们在编写代码时会设计一个函数，这个函数的输入是每个步骤获取的 奖励，输出是每一个步骤的未来总奖励。因为未来总奖励可写为即上一个步骤和下一个步骤的未来总奖励的关系如式 (4.22) 所示，所以在代码的计算上，我们是从后往前 推，一步一步地往前推，先算 GT ，然后往前推，一直算到 G1。在代码上计算时，我们要获取神经网络的输出。神经网络会 输出每个动作对应的概率值（比如 0.2、0.5、0.3），然后我们还可以获取实际的动作 at，把动作转成独热 （one-hot）向量（比如 [0,1,0]）与 log[0.2, 0.5, 0.3] 相乘就可以得到 log π(at|st, θ) 。 如图 4.18 所示，策略梯度预测每一个状态下应该要输出的动作的概率，即输入状态 st，输出 动作 at 的概率，比如 0.02、0.08、0.9。实际上输出给环境的动作是随机选择一个动作，比如我们选择向右 这个动作，它的独热向量就是（0,0,1）。我们把神经网络的输出和实际动作代入交叉熵的公式就可以求出 输出动作的概率和实际动作的概率之间的差距。但实际的动作 at 只是我们输出的真实的动作，它不一定 是正确的动作，它不能像手写数字识别一样作为一个正确的标签来指导神经网络朝着正确的方向更新，所 以我们需要乘一个奖励回报 Gt。Gt 相当于对真实动作的评价。如果 Gt 越大，未来总奖励越大，那就说 明当前输出的真实的动作就越好，损失就越需要重视。如果 Gt 越小，那就说明动作 at 不是很好，损失的 权重就要小一点儿，优化力度也要小一点儿。通过与手写数字识别的一个对比，我们就知道为什么策略梯 度损失会构造成这样。 面试题 4-1 友善的面试官：同学来吧，给我手动推导一下策略梯度公式的计算过程。 4-2 友善的面试官：可以说一下你所了解的基于策略梯度优化的技巧吗？ 近端策略优化策略梯度是同策略的算法，因为在策略梯度中，我们需要一个智能体、一个策略和一个演员。演员去与环境交互搜集数据，搜集很多的轨迹 τ ，根据搜集到的数据按照策略梯度的公式更新策略的参数，所以策略梯度是一个同策略的算法。同策略算法采集的数据只能用一次。 πθ 采样的轨迹 τ 求期望。一旦更新了参数，从 θ 变成 θ′ ，概 率 pθ(τ ) 就不对了，之前采样的数据也不能用了 重要度采样 假设我们有一个函数 f (x)，要计算从分布 p 采样 x，再把 x 代入 f ，得到 f (x)。我们该怎么计算 f (x) 的期望值呢？假设我们不能对分布 p 做积分，但可以从分布 p 采样一些数据 xi。把 xi 代入 f (x)，取 它的平均值，就可以近似 f (x) 的期望值 假设我们不能从分布 p 采样数据，只能从另外一个分布 q 采样数据 x，q 可以 是任何分布。如果我们从 q 采样 xi，就不能使用式 (5.2)。因为式 (5.2) 是假设 x 都是从 p 采样出来的。所以我们做一个修正，期望值 Ex∼p[f (x)] 就是 f (x)p(x)dx。所以我们从 q 里面采样 x，再计算 f (x) p(x) q(x) ，再取期望 值。所以就算我们不能从 p 里面采样数据，但只要能从 q 里面采样数据，就可以计算从 p 采样 x 代入 f 以后的期望值 因为是从 q 采样数据，所以我们从 q 采样出来的每一笔数据，都需要乘一个重要性权重（importance weight） p(x) q(x) 来修正这两个分布的差异。 但是在实现上，p 和 q 的差距不能太大。差 距太大，会有一些问题。如果 p(x) q(x) 差距很大，f (x) p(x) q(x) 的方差就会很大。所以理论上它们的期望值一样，也就是，我们只要对分布 p 采样足够多次，对分布 q 采样足够多次，得到的结果会是一样的。但是如果我们采样的次数不够多，因 为它们的方差差距是很大的，所以我们就有可能得到差别非常大的结果。 Q：现在的数据是从 θ′ 采样出来的，从 θ 换成 θ′ 有什么好处呢？ A：因为现在与环境交互的是 θ′ 而不是 θ，所以采样的数据与 θ 本身是没有关系的。因此我们就可以 让 θ′ 与环境交互采样大量的数据，θ 可以多次更新参数，一直到 θ 训练到一定的程度。更新多次以后，θ′ 再重新做采样，这就是同策略换成异策略的妙处。 现在要做的就是把重要性采样用在异策略的情况中，把同策略训练的算法改成异策略训练的算法。怎 么改呢？ 实际在做策略梯度的时候，我们并不是给整个轨迹 τ 一样的分数，而是将每一个状态-动作对分开计 算。实际更新梯度的过程可写为 所以现在 st、at 是 θ′ 与环境交互以后 所采样到的数据。但是训练时，要调整的参数是模型 θ。所以我们要有一个修 正的项。 DQN传统的强化学习算法会使用表格的形式存储状态价值函数${V_{π}(s)}$或动作价值函数${Q_{π}(s,a)}$，但是这样的 方法存在很大的局限性。例如，现实中的强化学习任务所面临的状态空间往往是连续的，存在无穷多个状态，在这种情况下，使用价值函数近似利用函数直接拟合状态价值函 数或动作价值函数，降低了对存储空间的要求，有效地解决了这个问题。 DQN就是使用神经网络来近似价值函数。 状态价值函数${V_{π}(s)}$可以评估当前环境的好坏 动作价值函数${Q_{π}(s,a)}$可以评估在当前状态做出某一个动作的好坏 有两种不同的方法可以衡量状态价值函数${V_{π}(s)}$ ：基于蒙特卡洛的方法和基于时序差分的方法。 蒙特卡洛的方法 是训练完整的一轮再进行的训练，在训练的时候，它就是一个回归问题（regression problem）。网络的输出就是一个值， 我们希望在输入 sa 的时候，输出的值与之后的累计奖励 ${G_{a}}$越接近越好。 时序差分的方法，基于时序差分的方法不需要等到一整轮结束，只需要在某一个状态 st 的时候，采取动作 at 得到奖励 rt ，接下来进入状态 st+1，就可 以使用时序差分的方法。我们可以通过式 (6.2) 来使用时序差分的方法。 我们希望${V_{π}(S_t)}$与${V_{π}(S_{t+1})}$相减的损失与 rt 接 近，训练下去，更新${V_{π}}$的参数，我们就可以把函数学习出来。 时序差分方法的更新值函数时只依赖于单个时间步的奖励和后续状态的估计值，因此通常具有较低的方差。它不需要等待整个序列的结束，因此可以更频繁地进行更新，从而减少了方差。 ${Q_{π}(s,a)}$代表在s状态下采取a动作后后边的策略仍然由策略 π决定会获得的奖励。 我们学习出一个 Q 函数以后，就可以找到一个新的策略 π′ ，策 略 π′ 会比原来的策略 π 要好（稍后会定义什么是好）。 再去学习它的 Q 函数，得到新的 Q 函数以后，再去寻找一个更好的策略。这样一直循环下去，策略就会 越来越好。 证明改成策略后价值函数会变好证明改进一个策略的一部分之后$\\max_aQ_\\pi(s,a)=Q_\\pi\\left(s,\\pi’(s)\\right)$​之后那么新的价值函数一定会比之前的价值函数要好 $V_\\pi(s)=Q_\\pi(s,\\pi(s))$ $Q_\\pi(s,\\pi(s))\\leqslant\\max_aQ_\\pi(s,a)$​ $Q_\\pi\\left(s,\\pi’(s)\\right)=\\max_aQ_\\pi(s,a)$ DQN的技巧目标网络 ε-贪心 回放缓冲区 减少与环境交互的次数： 通过回放缓冲区，可以减少与环境的交互次数，因为训练时不必依赖于实时的策略。过去的经验可以被重复利用，从而有效地增加了样本的利用率。 增加数据样本的多样性： 如果批量数据都具有相似性质，训练结果可能会受到影响。通过回放缓冲区，可以收集来自不同策略的经验，因此采样到的批量数据将更加多样化。这有助于提高网络的泛化能力和训练的稳定性。 提高训练效率和性能： 通过减少与环境的交互次数和增加数据样本的多样性，回放缓冲区可以提高训练的效率和性能。 为什么DQN的训练不需要依赖于实时的策略 DQN的训练过程与策略的收集是解耦的。策略的收集可以是通过任何一种实现。 DQN伪代码 面试6-1 友善的面试官：请问深度 Q 网络是什么？其两个关键性的技巧分别是什么？ 6-2 友善的面试官：那我们继续分析！你刚才提到的深度 Q 网络中的两个技巧————目标网络和经 验回放，其具体作用是什么呢？ 6-3 友善的面试官：深度 Q 网络和 Q 学习有什么异同点？ 6-4 友善的面试官：请问，随机性策略和确定性策略有什么区别吗？ 6-5 友善的面试官：请问不打破数据相关性，神经网络的训练效果为什么就不好 演员评论家算法演员-评论员算法是一种结合策略梯度和时序差分学习的强化学习方法 策略梯度算法回顾在更新策略参数 θ 的时候，我们可以通过下边公式来计算梯度 $\\nabla\\bar{R_\\theta}\\approx\\frac{1}{N}\\sum_{n=1}^{N}\\sum_{t=1}^{T_n}\\left(\\sum_{t^{\\prime}=t}^{T_n}\\gamma^{t^{\\prime}-t}r_{t^{\\prime}}^n-b\\right)\\nabla\\log p_\\theta\\left(a_t^n\\mid s_t^n\\right)$ 在这个描述中，首先智能体与环境进行交互，根据当前状态 s 采取动作 a 的概率可以由策略网络（参数为 θ）给出，即 pθ(at|st)。接下来，智能体在采取动作 a 后直到一轮结束的累积奖励，其中： $\\sum_{t^{\\prime}=t}^{T_n}\\gamma^{t^{\\prime}-t}r_{t}^n$ 表示从时间步 t 到游戏结束 T 的累积奖励的总和。 γ 是折扣因子，通常取值为 0.9 或 0.99，用来衡量未来奖励的重要性，影响着长期奖励的权重。 b 是基线值，用于减少累积奖励的方差，以帮助更稳定地估计动作的价值。减去基线值的目的是使得累积奖励的项在正负间波动，从而引导策略的调整方向。 综合起来，根据当前策略网络输出的动作概率和累积奖励，可以通过更新参数 θ 来调整策略，使得在给定状态 s 下采取动作 a 的概率适应奖励的变化，以达到优化智能体的目标。 这要求我们统计累积奖励但由于交互过程本身的随机性和我们采样的数量不够的原因，导致累积奖励的方差可能会非常大。 深度 Q 网络回顾$Q(s,a)=\\mathbb{E}{s’}[r+\\gamma\\max{a’}Q(s’,a’)|s,a]$ $L(\\theta)=\\frac{1}{N}\\sum_i(Q(s_i,a_i;\\theta)-y_i)^2$ y 是目标值 算法细节 随机变量 G 的期望值正好就是 Q 值，假设用$\\mathbb{E}\\left[G_t^n\\right]$来代表 $\\sum_{t^{\\prime}=t}^{T_n}\\gamma^{t^{\\prime}-t}r_{t}^n$ 这一项，把 Q 函数套在这里就结束了，我们就可以把演员与评论员这两个方法结合 起来。 我们就可以把 Q 函数的值用V取代，这样两个网络的估计就会变为一个网络进而减少了误差 最后优势演员评论家算法的更新 算法流程 面试问题 9-1 友善的面试官：请简述一下异步优势演员-评论员算法（A3C），另外 A3C 是同策略还是异策略的模型呀？ 9-2 友善的面试官：请问演员-评论员算法有何优点呢？ 9-3 友善的面试官：请问异步优势演员-评论员算法具体是如何异步更新的？ 9-4 友善的面试官：演员-评论员算法中，演员和评论员两者的区别是什么？ 9-5 友善的面试官：演员-评论员算法框架中的评论员起了什么作用？ 9-6 友善的面试官：简述异步优势演员-评论员算法的优势函数。 深度确定性策略梯度Q 学习、深度 Q 网络等算法是没有办法处理连续的动作。 随机性策略与确定性策略进行解释。对随机性策略来说，输入某一个状态 s，采取某一个动 作的可能性并不是百分之百的，而是有一个概率的（就好像抽奖一样），根据概率随机抽取一个动作。而 对于确定性策略来说，它不受概率的影响。当神经网络的参数固定之后，输入同样的状态，必然输出同样 的动作，这就是确定性策略。 要输出离散动作，我们就加一个 softmax 层来确保所有的输出是动作概率，并且所 有的动作概率和为 1。要输出连续动作，我们一般可以在输出层加一层 tanh 函数，把输出限制到 [−1,1] 。 DDPG 是深度 Q 网络的一个扩展版本，可以扩展到连续动作空间。 深度 Q 网络与 DDPG 的联系如图 12.7 所示。深度 Q 网络的最佳策略是想要学出一个很好的 Q 网 络，学出这个网络之后，我们希望选取的那个动作使 Q 值最大。DDPG 的目的也是求解让 Q 值最大的那 个动作。演员只是为了迎合评委的打分而已，所以优化策略网络的梯度就是要最大化这个 Q 值，所以构 造的损失函数就是让 Q 取一个负号 最开始训练的时候，这两个神经网络的参数是随机的。所以评论员最开始是随机打分的，演员也随机 输出动作。但是由于有环境反馈的奖励存在，因此评论员的评分会越来越准确，所评判的演员的表现也会 越来越好。既然演员是一个神经网络，是我们希望训练好的策略网络，我们就需要计算梯度来更新优化它 里面的参数 θ 。 DDPG和A2C的actor网络在实现上的主要区别归结于它们各自策略的输出方式，这导致了确定性和随机性策略的不同。我们来具体看看这两种策略是如何实现的，以及为什么会产生这样的差异。 DDPG的Actor网络（确定性策略）在DDPG中，actor网络直接输出给定状态下的动作值。这意味着网络的输出层直接对应于动作空间的维度，并且每个输出节点的值表示相应动作的具体数值。例如，如果动作空间是一个连续的二维空间，那么actor网络将有两个输出，每个输出直接对应一个动作的数值。 实现：使用全连接层构建网络，输出层的激活函数（如tanh或sigmoid）通常被用来确保输出动作的值在合理的范围内。网络直接从输入状态映射到动作值，没有任何概率分布的介入。 为什么是确定性：因为对于给定的输入状态，网络总是产生同一组动作值，没有随机性介入。策略是确定性的，因为它不依赖于随机过程来选择动作。 A2C的Actor网络（随机策略）A2C中的actor网络输出的是动作的概率分布，而不是具体的动作值。对于离散动作空间，这通常意味着输出层有一个节点对应每个可能的动作，使用softmax函数来确保输出值形成一个概率分布。对于连续动作空间，actor可能输出参数来定义动作概率分布（例如，高斯分布的均值和标准差）。 实现：对于离散动作，网络通过softmax输出层产生每个动作的概率。对于连续动作，网络可能输出一组参数，这些参数定义了动作值的概率分布（例如，输出均值和方差来定义高斯分布）。 为什么是随机性：因为动作的选择依赖于输出概率分布，即使对于同一个输入状态，每次推断都可能根据概率分布随机选择不同的动作。这种随机性有助于探索，确保策略不会过早地陷入局部最优解。 产生确定性和随机性的原因 设计哲学：DDPG致力于在连续动作空间中找到精确控制的最优解，因此采用确定性策略直接输出动作值。而A2C采用随机策略来促进探索，适用于既有连续也有离散动作空间的环境。 网络输出：DDPG的网络输出是直接动作值，因此是确定性的；A2C的网络输出是动作的概率分布，因此是随机性的。 探索机制：DDPG通常依靠外部策略（如噪声添加）来引入探索，而A2C利用其随机策略本身的特性来探索。","link":"/2024/03/10/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"推荐系统-用户数据分析","text":"它基于用户之间的相似性或项目之间的相似性来进行推荐，基于用户行为分析的推荐算法是个性化推荐系统的重要算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。 用户行为数据简介很多的用户行为数据都会以日志的形式 ，但是一般使用的都是会话日志（ session log） 其中每个会话表示一次用户行为和对应的服务。比如，在搜索引擎和搜索广告系统中，服务会为每次查询生成一个展示日志（ impression log），其中记录了查询和返回结果。如果用户点击了某个结果，这个点击信息会被服务器截获并存储在点击日志（ click log）中 。得到的会话日志中每个消息是一个用户提交的查询、得到的结果以及点击。 分类用户行为一般分为显性反馈行为（ explicit feedback）和隐性反馈行为（ implicit feedback）。 比如喜欢/不喜欢，购买差评都是显性反馈行为 。 用户浏览一个物品 ，用户点击界面。显性反馈行为和隐性反馈行为的比较如下。 用户行为分析长尾效应指那些原来不受到重视的销量小但种类多的产品或服务由于总量巨大，累积起来的总收益超过主流产品的现象。 维基 下图是Delicious和CiteULike数据集中物品流行度的分布曲线。横坐标是物品的流行度K，纵坐标是流行度为K的物品的总数。这里，物品的流行度指对物品产生过行为的用户总数。 完美的展现了展示了长尾效应。 用户活跃度和物品流行度的关系一般认为，新用户倾向于浏览热门的物品，因为他们对网站还不熟悉，只能点击首页的热门物品，而老用户会逐渐开始浏览冷门的物品。图2-5展示了MovieLens数据集中用户活跃度和物品流行度之间的关系，其中横坐标是用户活跃度，纵坐标是具有某个活跃度的所有用户评过分的物品的平均流行度。这表明用户越活跃，越倾向于浏览冷门的物品。 所以为了留住用户，我们就需要进行个性化的推荐。 实验准备本章采用GroupLens提供的MovieLens数据集介绍和评测各种算法。 MovieLens数据集有3个不同的版本，本章选用中等大小的数据集，着重研究隐反馈数据集中的TopN推荐问题 。 测评指标： 精度：通过准确率/召回率评测推荐算法的精度 覆盖率：反映了推荐算法发掘长尾的能力 新颖度 ：如果推荐出的物品都很热门，说明推荐的新颖度较低，否则说明推荐结果比较新颖。 基于邻域的算法基于邻域的算法分为两大类，一类是基于用户的协同过滤算法，另一类是基于物品的协同过滤算法。 基于用户的协同过滤算法在一个在线个性化推荐系统中，当一个用户A需要个性化推荐时，可以先找到和他有相似兴趣的其他用户，然后把那些用户喜欢的、而用户A没有听说过的物品推荐给A。这种方法称为基于用户的协同过滤算法。 主要包括如下两个步骤 找到和目标用户兴趣相似的用户集合。 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户 步骤1：兴趣相似度： $w_{uv}=\\frac{\\left|N(u)\\cap N(v)\\right|}{\\left|N(u)\\cup N(v)\\right|}$ 余弦兴趣相似度： $w_{uv}=\\frac{\\left|N(u)\\cap N(v)\\right|}{\\sqrt{\\left|N(u)\\right|\\left|N(v)\\right|}}$ 举例 一个小技巧：在计算相似度时当用每个用户与每个用户计算相似度时间复杂度是O(|U|*|U|) U是用户个数，但是很多的用户并没有相似的交集所以 我们可以进行物品到用户的倒排表，对于每个物品都保存对该物品产生过行为的用户列表 。从而，可以扫描倒排表中每个物品对应的用户列表，将用户列表中的两两用户对应的C[u][v]加1，最终就可以得到所有用户之间不为0的。 步骤2：得到用户之间的兴趣相似度后， 可以通过UserCF算法中用户u对物品i的感兴趣程度 ： $p(u,i)=\\sum_{v\\in S(u,K)\\cap N(i)}w_{u\\nu}r_{vi}$ S(u, K)包含和用户u兴趣最接近的K个用户， N(i)是对物品i有过行为的用户集合，所以v是即对物品i感兴趣又与用户u有一定相似度的用户。${w_{uv}}$是用户u和用户v的兴趣相似度，${r_{vi}}$代表用户v对物品i的兴趣 结果分析UserCF的准确率和召回率相对MostPopular算法提高了将近1倍。同时， UserCF的覆盖率远远高于MostPopular，推荐结果相对MostPopular不太热门。 并且K值影响着流行度可以看到，随着额K越大则UserCF推荐结果就越热门。这是因为K决定了UserCF在给你做推荐时参考多少和你兴趣相似的其他用户的兴趣，那么如果K越大，参考的人越多，结果就越来越趋近于全局热门的物品。 K越大则UserCF推荐结果的覆盖率越低。覆盖率的降低是因为流行度的增加，随着流行度增加， UserCF越来越倾向于推荐热门的物品， 从而对长尾物品的推荐越来越少，因此造成了覆盖率的降低 。 改进User-IIF两个用户对冷门物品采取过同样的行为更能说明他们兴趣的相似度。 对于热门商品（比如新华字典）两人都购买但是并不能显示他们的相似度 所以改进相似度计算公式： $w_{uv}=\\frac{\\sum_{i\\in N(u)\\cap N(v)}\\frac{1}{\\log1+\\left|N(i)\\right|}}{\\sqrt{\\left|N(u)\\right|\\left|N(v)\\right|}}$ 对于物品i如果他的交互用户很多，那么分子部分就很很小，这样就是对热门商品的惩罚。 效果：经过对热门商品的惩罚，可以看到覆盖率的提升和流行度的下降证明推荐系统在变好。 基于物品的协同过滤算法基于物品的协同过滤算法（简称ItemCF）给用户推荐那些和他们之前喜欢的物品相似的物品 。不过， ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。 主要包括如下两个步骤 计算物品之间的相似度。 根据物品的相似度和用户的历史行为给用户生成推荐列表。 步骤1：$w_{ij}=\\frac{\\left|N(i)\\cap N(j)\\right|}{\\left|N(i)\\right|}$ 这里，分母|N(i)|是喜欢物品i的用户数，而分子 N i N j ( ) ( )  是同时喜欢物品i和物品j的用户数。因此，上述公式可以理解为喜欢物品i的用户中有多少比例的用户也喜欢物品j。 为了避免推荐出热门的物品，可以用下面的公式： $w_{ij}=\\frac{\\left|N(i)\\cap N(j)\\right|}{\\sqrt{\\left|N(i)\\right|\\left|N(j)\\right|}}$ 如果物品j是人们物品那么会增大分母进而对权重进行惩罚。 Q：为什么计算谁喜欢这个物品可以代表物品之间的相似度。 A:在协同过滤中两个物品产生相似度是因为它们共同被很多用户喜欢，也就是说每个用户都可以通过他们的历史兴趣列表给物品“贡献”相似度。这里面蕴涵着一个假设，就是每个用户的兴趣都局限在某几个方面，因此如果两个物品属于一个用户的兴趣列表，那么这两个物品可能就属于有限的几个领域，而如果两个物品属于很多用户的兴趣列表，那么它们就可能属于同一个领域，因而有很大的相似度。 步骤2：在得到物品之间的相似度后， ItemCF通过如下公式计算用户u对一个物品j的兴趣： $p_{uj}=\\sum_{i\\in N(u)\\cap S(j,K)}w_{ji}r_{ui}$ 这里N(u)是用户喜欢的物品的集合， S(j,K)是和物品j最相似的K个物品的集合， 所以i属于用户u喜欢的物品并且还和i有相关性的物品。${w_{ij}}$是物品j和i的相似度，${r_{ui}}$​是用户u对物品i的兴趣。 该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。 例子：用户喜欢《 C++ Primer中文版》和《编程之美》两本书。然后ItemCF会为这两本书分别找出和它们最相似的3本书，然后根据公式的定义计算用户对每本书的感兴趣程度。比如， ItemCF给用户推荐《算法导论》，是因为这本书和《 C++ Primer中文版》相似，相似度为0.4，而且这本书也和《编程之美》相似，相似度是0.5。考虑到用户对《 C++ Primer中文版》的兴趣度是1.3，对《编程之美》的兴趣度是0.9，那么用户对《算法导论》的兴趣度就是1.3 （${r_{ui}}$）× 0.4 ${w_{ij}}$+ 0.9× 0.5 = 0.97 结果： 改进ItemCF-IUF用户活跃度对数的倒数的参数，他也认为活跃用户对物品相似度的贡献应该小于不活跃的用户。 $w_{ij}=\\frac{\\sum_{u\\in N(i)\\cap N(j)}\\frac{1}{\\log1+\\left|N(u)\\right|}}{\\sqrt{\\left|N(i)\\right|\\left|N(j)\\right|}}$ N(i)N(j)是同时喜欢物品i和物品j的用户 ，N(u)是代表用户u喜欢的物品数目，这样可以减少异常活跃用户对于相关性的影响 ItemCF-IUF在准确率和召回率两个指标上和ItemCF相近，但ItemCF-IUF明显提高了推荐结果的覆盖率，降低了推荐结果的流行度 改进ItemCF-Norm假设物品分为两类——A和B， A类物品之间的相似度为0.5， B类物品之间的相似度为0.6，而A类物品和B类物品之间的相似度是0.2。在这种情况下，如果一个用户喜欢了5个A类物品和5个B类物品，用ItemCF给他进行推荐，推荐的就都是B类物品，因为B类物品之间的相似度大。但如果归一化之后， A类物品之间的相似度变成了1， B类物品之间的相似度也是1，那么这种情况下，用户如果喜欢5个A类物品和5个B类物品，那么他的推荐列表中A类物品和B类物品的数目也应该是大致相等的。 $w_{ij}^{‘}=\\frac{w_{ij}}{\\max_{j}w_{ij}}$ UserCF和ItemCF的综合比较 为什么原始ItemCF算法的覆盖率和新颖度都不高 如果j非常热门，那么上面公式的分子$\\begin{vmatrix}N(i)\\cap N(j)\\end{vmatrix}$就会越来越接近 $\\begin{vmatrix}N(i)\\end{vmatrix}$。尽管上面的公式分母已经考虑到了j的流行度，但在实际应用中，热门的j仍然会获得比较大的相似度。 解决方案我们可以在分母上加大对热门物品的惩罚， 通过提高α，就可以惩罚热门的j。 $w_{ij}=\\frac{\\left|N(i)\\cap N(j)\\right|}{\\left|N(i)\\right|^{1-\\alpha}\\left|N(j)\\right|^\\alpha}$ 隐语义模型LFM（ latent factor model）隐语义模型 用于找到文本的隐含语义 如果要推荐一本书处理上述的user-CF和item-CF还有一种方法，可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。 LFM通过如下公式计算用户u对物品i的兴趣： 这个公式中${p_{u,k}}$, 和${q_{i,k}}$ 是模型的参数，其中${p_{u,k}}$,度量了用户u的兴趣和第k个隐类的关系，而${q_{i,k}}$ , 度量了第k个隐类和物品i之间的关系。 LFM在隐性反馈数据 如何生成负样本 对于一个用户，从他没有过行为的物品中均匀采样出一些物品作为负样本。 采样原则 对每个用户，要保证正负样本的平衡（数目相似）。 对每个用户采样负样本时，要选取那些很热门，而用户却没有行为的物品。 损失函数是均方误差，优化方法随机梯度下降法 来对训练集进行训练。 结果 表中展示了4个隐类中排名最高（ qik最大）的一些电影。结果表明，每一类的电影都是合理的，都代表了一类用户喜欢看的电影。从而说明LFM确实可以实现通过用户行为将物品聚类的功能。 LFM和基于邻域的方法的比较 理论基础 LFM具有比较好的理论基础，它是一种学习方法，通过优化一个设定的指标建立最优的模型。基于邻域的方法更多的是一种基于统计的方法，并没有学习过程。 离线计算的空间复杂度 基于邻域的方法需要维护一张离线的相关表。在离线计算相关表的过程中，如果用户/物品数很多，将会占据很大的内存。假设有M个用户和N个物品，在计算相关表的过程中，我们可能会获得一张比较稠密的临时相关表（尽管最终我们对每个物品只保留K个最相关的物品，但在中间计算过程中稠密的相关表是不可避免的），那么假设是用户相关表，则需要O(MM)的空间，而对于物品相关表，则需要O(NN)的空间。而LFM在建模过程中，如果是F个隐类，那么它需要的存储空间是O(F*(M+N))，这在M和N很大时可以很好地节省离线计算的内存。在Netflix Prize中，因为用户数很庞大（ 40多万），很少有人使用UserCF算法（据说需要30 GB左右的内存），而LFM由于大量节省了训练过程中的内存（只需要4 GB），从而成为Netflix Prize中最流行的算法。 在线实时推荐 UserCF和ItemCF在线服务算法需要将相关表缓存在内存中，然后可以在线进行实时的预测。以ItemCF算法为例，一旦用户喜欢了新的物品，就可以通过查询内存中的相关表将和该物品相似的其他物品推荐给用户。因此，一旦用户有了新的行为，而且该行为被实时地记录到后台的数据库系统中，他的推荐列表就会发生变化。 而从LFM的预测公式可以看到， LFM在给用户生成推荐列表时，需要计算用户对所有物品的兴趣权重，然后排名，返回权重最大的N个物品。那么，在物品数很多时，这一过程的时间复杂度非常高，可达O(MNF)。因此， LFM不太适合用于物品数非常庞大的系统，如果要用，我们也需要一个比较快的算法给用户先计算一个比较小的候选列表，然后再用LFM重新排名。另一方面， LFM在生成一个用户推荐列表时速度太慢，因此不能在线实时计算，而需要离线将所有用户的推荐结果事先计算好存储在数据库中。因此， LFM不能进行在线实时推荐，也就是说，当用户有了新的行为后，他的推荐列表不会发生变化。 推荐解释 ItemCF算法支持很好的推荐解释，它可以利用用户的历史行为解释推荐结果。但LFM无法提供这样的解释，它计算出的隐类虽然在语义上确实代表了一类兴趣和物品，却很难用自然语言描述并生成解释展现给用户。 基于图的模型将用户行为表示为二分图模型后， 下面的任务就是在二分图上给用户进行个性化推荐。如果将个性化推荐算法放到二分图模型上，那么给用户u推荐物品的任务就可以转化为度量用户顶点vu和与vu没有边直接相连的物品节点在图上的相关性 度量图中两个顶点之间相关性的方法很多，但一般来说图中顶点的相关性主要取决于下面： 两个顶点之间的路径数； 两个顶点之间路径的长度； 两个顶点之间的路径经过的顶点 而相关性高的一对顶点一般具有如下特征： 两个顶点之间有很多路径相连； 连接两个顶点之间的路径长度都比较短； 连接两个顶点之间的路径不会经过出度比较大的顶点。 举例 举一个简单的例子，如图2-19所示，用户A和物品c、 e没有边相连，但是用户A和物品c有两条长度为3的路径相连，用户A和物品e有两条长度为3的路径相连。那么，顶点A与e之间的相关性要高于顶点A与c，因而物品e在用户A的推荐列表中应该排在物品c之前，因为顶点A与e之间有两条路径——（ A, b, C, e）和（ A, d, D, e）。其中， （ A, b, C, e）路径经过的顶点的出度为（ 3, 2, 2, 2），而（ A, d, D, e）路径经过的顶点的出度为（ 3, 2, 3, 2）。因此， （ A, d, D, e）经过了一个出度比较大的顶点D，所以（ A, d, D, e）对顶点A与e之间相关性的贡献要小于（ A, b, C, e） 假设要给用户u进行个性化推荐，可以从用户u对应的节点vu开始在用户物品二分图上进行随机游走。游走到任何一个节点时，首先按照概率α 决定是继续游走，还是停止这次游走并从vu节点开始重新游走。如果决定继续游走，那么就从当前节点指向的节点中按照均匀分布随机选择一个节点作为游走下次经过的节点。 虽然PersonalRank算法可以通过随机游走进行比较好的理论解释，但该算法在时间复杂度上有明显的缺点。因为在为每个用户进行推荐时，都需要在整个用户物品二分图上进行迭代，直到整个图上的每个顶点的PR值收敛。这一过程的时间复杂度非常高，不仅无法在线提供实时推荐，甚至离线生成推荐结果也很耗时。","link":"/2024/04/29/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE/"},{"title":"推荐系统-时间上下文需求","text":"物品的推荐要注意和上下文，比如用户肯定不会在冬天挑一件短袖， 当用户伤心的时候也不会听喜庆的歌。 时间信息对用户兴趣的影响表现在如下几个方面： 用户兴趣是变化的 物品也是有生命周期的 季节效应 推荐算法的实时性前边说了用户的兴趣是在不断地变化的，所以推荐系统要做到实时性的推荐。 实现推荐系统的实时性除了对用户行为的存取有实时性要求，还要求推荐算法本身具有实时性，而推荐算法本身的实时性意味着： 实时推荐系统不能每天都给所有用户离线计算推荐结果，然后在线展示昨天计算出来的结果。所以，要求在每个用户访问推荐系统时，都根据用户这个时间点前的行为实时计算推荐列表 推荐算法需要平衡考虑用户的近期行为和长期行为，即要让推荐列表反应出用户近期行为所体现的兴趣变化，又不能让推荐列表完全受用户近期行为的影响，要保证推荐列表对用户兴趣预测的延续性。 时间上下文推荐算法最近最热门算法给定时间T，物品i最近的流行度 ${n_i(T)}$可以定义为 a代表时间衰减 时间上下文相关的ItemCF算法基于物品（ item-based）的个性化推荐算法 主要有两个核心部分 利用用户行为离线计算物品之间的相似度； 根据用户的历史行为和物品相似度矩阵，给用户做在线个性化推荐。 这正对应着两种时间效应 用户在相隔很短的时间内喜欢的物品具有更高相似度。 用户近期行为相比用户很久之前的行为，更能体现用户现在的兴趣。 经典的相似度计算，上边是是喜欢物品i的用户也喜欢物品j的交集 用户u对物品i的兴趣p(u,i)通过如下公式计算： 为了体现时间效应 引入一个衰减项f其中 ${t_{ui}}$ 是用户u对物品i产生行为的时间。 f函数的含义是，用户对物品i和物品j产生行为的时间越远，则 f越小。我们可以找到很多数学衰减函数，本节使用如下衰减函数 然后用户对物品的兴趣也应该收到时间的影响，用户现在的行为应该和用户最近的行为关系更大 所以修正的用户对于物品i的兴趣如下公式 时间上下文的UserItem经典的用户相关性 用户对物品的兴趣， 其中， S(u,K)包含了和用户u兴趣最接近的K个用户。如果用户v对物品i产生过行为，那么r=1 ，否则r=0。 考虑时间信息用户相关性变为 考虑和用户u兴趣相似用户的最近兴趣，我们可以设计如下公式 距离用户v喜欢的这个物品目前越远那么权重就越小 离线实验 对比了如下方法 本节的离线实验将同时对比如下算法，将它们的召回率和准确率曲线画在一张图上。 Pop 给用户推荐当天最热门的物品。 TItemCF 融合时间信息的ItemCF算法。 TUserCF 融合时间信息的UserCF算法。 ItemCF 不考虑时间信息的ItemCF算法。 UserCF 不考虑时间信息的UserCF算法。 SGM 时间段图模型。 USGM 物品时间节点权重为0的时间段图模型。 ISGM 用户时间节点权重为0的时间段图模型。 在第一类数据集中，有4个算法（ SGM、 ISGM、 TUserCF、 Pop）明显好于另外4个算法 。 地点上下文信息考虑位置信息主要分为三种 它使用的数据集有3种不同的形式。 （ 用户， 用户位置， 物品， 评分），每一条记录代表了某一个地点的用户对物品的评分。它们使用的是MovieLens数据集。该数据集给出了用户的邮编，从而可以知道用户的大致地址。 （ 用户， 物品， 物品位置， 评分），每一条记录代表了用户对某个地方的物品的评分。 LARS使用了FourSquare的数据集，该数据集包含用户对不同地方的餐馆、景点、商店的评分。 （ 用户， 用户位置， 物品， 物品位置， 评分），每一条记录代表了某个位置的用户对某个位置的物品的评分。 对于第一种数据集， LARS的基本思想是将数据集根据用户的位置划分成很多子集。因为位置信息是一个树状结构，比如国家、省、市、县的结构。因此，数据集也会划分成一个树状结构。然后，给定每一个用户的位置，我们可以将他分配到某一个叶子节点中，而该叶子节点包含了所有和他同一个位置的用户的行为数据集。然后， LARS就利用这个叶子节点上的用户行为数据，通过ItemCF 给用户进行推荐。 不过这样做的缺点是，每个叶子节点上的用户数量可能很少，因此他们的行为数据可能过于稀疏，从而无法训练出一个好的推荐算法。为此，我们可以从根节点出发，在到叶子节点的过程中，利用每个中间节点上的数据训练出一个推荐模型，然后给用户生成推荐列表。而最终的推荐结果是这一系列推荐列表的加权。文章的作者将这种算法成为金字塔模型，而金字塔的深度影响了推荐系统的性能，因而深度是这个算法的一个重要指标。下文用LARS-U代表该算法。 举一个简单的例子，如图5-16所示，假设有一个来自中国江苏南京的用户。我们会首先根据所有用户的行为利用某种推荐算法（假设是ItemCF）给他生成推荐列表，然后利用中国用户的行为给他生成第二个推荐列表，以此类推，我们用中国江苏的用户行为给该用户生成第三个推荐列表，并利用中国江苏南京的用户行为给该用户生成第四个推荐列表。然后，我们按照一定的权重将这4个推荐列表线性相加，从而得到给该用户的最终推荐列表。 对于第二种数据集，每条用户行为表示为四元组（用户、物品、物品位置、评分），表示了用户对某个位置的物品给了某种评分。对于这种数据集， LARS会首先忽略物品的位置信息，利用ItemCF算法计算用户u对物品i的兴趣P(u,i)，但最终物品i在用户u的推荐列表中的权重定义为： 在该公式中， TravelPenalty(u,i)表示了物品i的位置对用户u的代价。计算TravelPenalty(u,i)的基本思想是对于物品i与用户u之前评分的所有物品的位置计算距离的平均值（或者最小值）。关于如何度量地图上两点的距离，最简单的是基于欧式距离①。当然，欧式距离有明显的缺点，因为人们是不可能沿着地图上的直线距离从一点走到另一点的。比较好的度量方 式是利用交通网络数据，将人们实际需要走的最短距离作为距离度量。","link":"/2024/05/10/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%A9%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF/"},{"title":"推荐系统-利用用户标签","text":"目前推荐算法主要分为三种：第一种方式是利用用户喜欢过的物品，给用户推荐与他喜欢过的物品相似的物品，这就是前面提到的基于物品的算法。第二种方式是利用和用户兴趣相似的其他用户，给用户推荐那些和他们兴趣爱好相似的其他用户喜欢的物品，这是前面提到的基于用户的算法。除了这两种方法，第三种重要的方式是通过一些特征（ feature）联系用户和物品，给用户推荐那些具有用户喜欢的特征的物品。 UCG标签系统通常指的是用户生成内容（User Generated Content）标签系统。这是一种用于组织和管理用户生成的内容的分类系统，旨在帮助用户更容易地浏览和发现感兴趣的内容。UCG标签系统可以应用于各种在线平台，如社交媒体、论坛、博客等，以帮助用户过滤和搜索内容。 标签应用一般分为两种：一种是让作者或者专家给物品打标签；另一种是让普通用户给物品打标签，也就是UGC（ User Generated Content，用户生成的内容）的标签应用。 举例： Delicious 给网站打标签，CiteULike 给论文打标签， 标签系统中的推荐问题主要有以下两个。 如何利用用户打标签的行为为其推荐物品（基于标签的推荐）？ 如何在用户给物品打标签时为其推荐适合该物品的标签（标签推荐）？ 为了研究上面的两个问题，我们首先需要解答下面问题。 用户为什么要打标签？ ​ 首先是社会维度，有些用户标注是给内容上传者使用的（便于上传者组织自己的信息），而有些用户标注是给广大用户使用的（便于帮助其他用户找到信 息）。另一个维度是功能维度，有些标注用于更好地组织内容，方便用户将来的查找，而另一些标注用于传达某种信息，比如照片的拍摄时间和地点等。 基于标签的推荐系统实验，预测用户会给什么物品打标签 评价指标 对于用户u，令R(u)为给用户u的长度为N的推荐列表，里面包含我们认为用户会打标签的物品。令T(u)是测试集中用户u实际上打过标签的物品集合。然后，我们利用准确率（ precision）和召回率（ recall）评测个性化推荐算法的精度。 覆盖率的计算公式如下 通过余弦计算出的相似度之后计算多样性。多样性计算公式如下 定义它的流行度item_pop(i)为给这个物品打过标签的用户数。而对推荐系统，我们定义它的平均热门度如下： 方法1： 统计每个用户最常用的标签。 对于每个标签，统计被打过这个标签次数最多的物品。 所以就可以对于一个用户先找到他最常用的标签然后找到具有这些标签的热门物品推荐给他 B(u)是用户u打过的标签集合， B(i)是物品i被打过的标签集合，${n_{u,b}}$ 是用户u打过标签b的次数，${n_{b,i}}$是物品i被打过标签b的次数 。那么用户对一个物品的兴趣程度就可以通过如下的式子表示。 在Python中，我们遵循如下约定： 用 records 存储标签数据的三元组，其中records[i] = [user, item, tag]  用 user_tags 存储${n_{u,b}}$ ，其中user_tags[u][b] = ${n_{u,b}}$  用 tag_items存储${n_{b,i}}$ ，其中tag_items[b][i] = ${n_{b,i}}$。 改进1：增加热门标签惩罚 方法1对于热门标签的推荐比重很大不能代表用户的思想。所以可以借鉴TF-IDF的形式${n_b^{(u)}}$ 记录了标签b被多少个不同的用户使用过 ,这样的话虽然用户打了很多的热门标签但是会除以一个热门的系数进而减少他的权重。可以看到各个指标都有提升 改进2增加热门物品惩罚 对于热门物品${n_{b,i}}$是物品i被打过标签b的次数，我们也应该给予一定的惩罚，这样用户就可以获得更多的这个标签的物品。可以看到覆盖率有大幅提升 改进3新物品和新用户推荐 对于用户兴趣和物品的联系是通过 ${B(u)∩B(i)}$中的标签建立的(用户u打过标签和物品被打的标签一致时)。 但是，对于新用户或者新物品，这个集合 ${B(u)∩B(i)}$中的标签数量会很少。 为了提高准确率，我们需要进行标签的拓展。标签拓展也就是要计算标签的相似度。相似度的计算公式余弦相似度 改进4标签清理 清理掉用户标记为负面的标签 一般来说有如下标签清理方法： 去除词频很高的停止词； 去除因词根不同造成的同义词，比如 recommender system和recommendation system 去除因分隔符造成的同义词，比如 collaborative_filtering和collaborative-filtering。 基于图的推荐算法可以使用personrank的随机游走算法计算，每次选择重新开始还是继续游走，然后就可以因为边的长度边的数量以及边的两顶点之间经过的路径计算出一个相关性。然后按照相关性的排序进行推荐。 方法2 构建用户标签物品的三元组，然后这样每个物品被用户打上标签，标签和物品的之间连线的权重就加一，用户每打一次相同标签用户和标签之间连线的权重就加1那么就可以像最开始推荐的算法一样，给用户推荐最喜欢标签的热门物品。 给用户推荐标签给用户推荐标签的原因： 方便用户输入标签 提高标签质量 推荐标签的算法： 给用户推荐网站最热门的标签 给用户推荐正要打标签物品的热门标签 给用户推荐 常用的标签 23方法进行线性的加权 结果最好的是方法2但是当加权为2 0.8时效果超过方法2因为仍然还会有用户一些需要的常用标签。","link":"/2024/05/10/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE/"},{"title":"量子强化学习","text":"背景目前的研究主要集中在变分量子算法，之前的研究提出了利用变分量子算法来增强有监督、无监督和强化学习(RL)算法的建议。在这项工作中，我们采用一种基于深度q -学习算法的**参数化量子电路(PQC)**训练方法，该方法可用于解决离散和连续状态空间的RL任务。实验结果表明体系结构选择和超参数比模型中使用的参数数量对智能体的成功贡献更大。 经典强化学习Q-learning关注的不是状态值函数，而是对密切相关的动作值函数Q(s, a)。 然后通过充分探索状态和动作空间。这为智能体提供了足够的信息来区分给定特定状态下的好行为和坏行为。来学习Q函数学习方法 在Q-learning中，目标是近似实值最优q函数。在实际训练的过程中，模型不用知道每一个动作精确的Q，只用知道对于每一个状态动作，Q值的排序。也就是在当前状态做出哪个动作最好。 为了应对模型的复杂性，摒弃Q表的更新方式，提出了使用神经网络作为q函数逼近器，神经网络返回所有动作的Q值，然后通过上一次和这一次的q值估计的均方误差作为损失函数。 量子强化学习——量子Q学习量子强化学习我们只将神经网络替换为量子强化学习网络。q-learning的其他方面比如greedy策略来确定代理的下一个动作，并通过重放来抽取样本以训练q 网络我们仍然采用。 量子比特（qubit）的理论基础通常通过布洛赫球（Bloch sphere）来说明。该模型封装了量子比特的状态及其所含信息[Gamel, 2016]。与经典计算机只能使用二进制 “0 “和 “1 “进行运算的情况不同，量子比特既可以存在于纯粹的 |0⟩ 或 |1⟩ 的纯态，也可以处于二者的叠加态，从而增加了成倍计算的可能性。 量子比特的旋转过程过程可以表示为 $|\\psi\\rangle=R_{z}(\\theta_{z})R_{y}(\\theta_{y})R_{x}(\\theta_{x})|0\\rangle,$ 我们可以通过量子门电路Rx(θx)， Ry(θy)和Rz(θz)分别代表围绕Bloch球的x, y和z轴的 Pauli rotation泡利旋转操作。图中的θ就可以确认的参数。 输入转换将获取的每个状态分别进行数值转换用一个qubit表示， 对于离散的状态我们可以使用纯态的0和1表示 对于连续的状态我们可以将它进行转换新的x代表量子比特 $x^{\\prime}=\\arctan(x)\\in[-\\pi/2,\\pi/2]$ 这些门对量子比特旋转角度和方向的影响是由它们的内部参数和唯一的操作规则决定的，所以我们可以将量子的旋转角度设置为参数，进行学习。 CZ门的连接，通过量子计算的CZ门可以让两个量子之间产生纠缠，增加量子之间的联系，增强信息交换的能力。 γ, α, β, δ 就是可以调整的参数。与神经网络的参数相对应。 具体流程1、信息编码我们使用参数量子电路架构构建我们的QNN网络。针对特定的问题设置特定的QNN（量子神经网络）被特别设计以匹配系统环境。每个不同状态都分配了一个专用的量子比特用于信息编码。为了编码这些状态，QNN采用了在每个量子比特上使用Pauli-X门的旋转方法。 2、参数化旋转每一层由每个量子位上沿Y和Z轴的参数化旋转和CZ门的组成。绿框对应于数据编码门，将数据编码为X旋转的参数。CZ门负责增加量子比特之间的联系的联系。在Pauli-X门处理完状态之后，每个量子比特然后通过变分层中的不同门进行调整。这些调整对量子比特的影响可以用前述方程1中提到的|ψ⟩表示。 3、多层结构为了进一步提高电路的表现力，数据编码可以以两种方式重复:通过增加量子位的数量并在其上复制数据编码来并行地重复，或者以交替的方式与电路的变分层顺序重复（数据重上传）。使用数据重新加载，每层重复绘制整个电路图，只重复没有初始X旋转的变分部分。 4、模型输出通过不断地增加多层结构，最后设置相应的CZ门设置输出输出控制动作。 $|\\Phi_{\\mathrm{out}}\\rangle=\\mathrm{CZ}(|\\phi_{1}^{\\prime\\prime}\\rangle,\\mathrm{CZ}(|\\phi_{2}^{\\prime\\prime}\\rangle,\\mathrm{CZ}(\\ldots\\mathrm{CZ}(|\\phi_{6}^{\\prime\\prime}\\rangle,|\\phi_{7}^{\\prime\\prime}\\rangle)\\ldots)))$","link":"/2024/03/10/%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"计算机必备","slug":"计算机必备","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"深度学习","slug":"深度学习","link":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"强化学习","slug":"强化学习","link":"/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"推荐系统","slug":"推荐系统","link":"/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"name":"量子学习","slug":"量子学习","link":"/tags/%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"基础工具","slug":"基础工具","link":"/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"基础工具/Git","link":"/categories/%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/Git/"},{"name":"贪心","slug":"算法/贪心","link":"/categories/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/"},{"name":"二叉树","slug":"算法/二叉树","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"算法/动态规划","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"哈希表","slug":"算法/哈希表","link":"/categories/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"单调栈","slug":"算法/单调栈","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"链表","slug":"算法/链表","link":"/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"算法/数组","link":"/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"},{"name":"回溯","slug":"算法/回溯","link":"/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"},{"name":"字符串","slug":"算法/字符串","link":"/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"栈与队列","slug":"算法/栈与队列","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"科研","slug":"科研","link":"/categories/%E7%A7%91%E7%A0%94/"},{"name":"推荐系统","slug":"推荐系统","link":"/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"name":"强化学习","slug":"科研/强化学习","link":"/categories/%E7%A7%91%E7%A0%94/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"pages":[]}
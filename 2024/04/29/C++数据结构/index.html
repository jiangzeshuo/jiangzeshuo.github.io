<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++数据结构 - JzsBlog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="JiangZeshuo"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JiangZeshuo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="库函数：提供标准输入输出流对象，例如cin和cout。：提供字符串操作函数，例如连接、比较、查找等。：提供向量容器类模板，用于动态数组操作。  &amp;#x2F;&amp;#x2F; For srand() and rand()    &amp;#x2F;&amp;#x2F; For time()"><meta property="og:type" content="blog"><meta property="og:title" content="C++数据结构"><meta property="og:url" content="https://jiangzeshuo.github.io/2024/04/29/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="JzsBlog"><meta property="og:description" content="库函数：提供标准输入输出流对象，例如cin和cout。：提供字符串操作函数，例如连接、比较、查找等。：提供向量容器类模板，用于动态数组操作。  &amp;#x2F;&amp;#x2F; For srand() and rand()    &amp;#x2F;&amp;#x2F; For time()"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://jiangzeshuo.github.io/img/og_image.png"><meta property="article:published_time" content="2024-04-29T01:26:02.401Z"><meta property="article:modified_time" content="2024-04-29T02:07:33.432Z"><meta property="article:author" content="jzs"><meta property="article:tag" content="数据结构"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jiangzeshuo.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jiangzeshuo.github.io/2024/04/29/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"headline":"C++数据结构","image":["https://jiangzeshuo.github.io/img/og_image.png"],"datePublished":"2024-04-29T01:26:02.401Z","dateModified":"2024-04-29T02:07:33.432Z","author":{"@type":"Person","name":"jzs"},"publisher":{"@type":"Organization","name":"JzsBlog","logo":{"@type":"ImageObject","url":"https://jiangzeshuo.github.io/img/avatar.png"}},"description":"库函数：提供标准输入输出流对象，例如cin和cout。：提供字符串操作函数，例如连接、比较、查找等。：提供向量容器类模板，用于动态数组操作。  &#x2F;&#x2F; For srand() and rand()    &#x2F;&#x2F; For time()"}</script><link rel="canonical" href="https://jiangzeshuo.github.io/2024/04/29/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="JzsBlog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jiangzeshuo"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-29T01:26:02.401Z" title="2024/4/29 09:26:02">2024-04-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-29T02:07:33.432Z" title="2024/4/29 10:07:33">2024-04-29</time></span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span><span class="level-item">19 minutes read (About 2784 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">C++数据结构</h1><div class="content"><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p><iostream>：提供标准输入输出流对象，例如cin和cout。<br><string>：提供字符串操作函数，例如连接、比较、查找等。<br><vector>：提供向量容器类模板，用于动态数组操作。<br><cstdlib>  &#x2F;&#x2F; For srand() and rand()<br><ctime>    &#x2F;&#x2F; For time()</p>
<span id="more"></span>
<p>MAP的生成和遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  <span class="keyword">if</span> (it-&gt;second &gt; max) &#123;</span><br><span class="line">     max = it-&gt;second;</span><br><span class="line">     majorityElement = it-&gt;first;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>构造函数（与结构体同名，冒号后边用于初始化成员变量，大括号用于完成初始化操作如果没有操作可以为空）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;  </span><br><span class="line">private:  </span><br><span class="line">    std::string name;  </span><br><span class="line">    int age;  </span><br><span class="line">  </span><br><span class="line">public:  </span><br><span class="line">    // 构造函数，接受名字和年龄作为参数  </span><br><span class="line">    Person(std::string n, int a) : name(n), age(a) &#123;  </span><br><span class="line">        // 构造函数体可以留空，因为初始化列表已经完成了初始化工作  </span><br><span class="line">        // 如果需要执行额外的操作，可以在这里添加代码  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="STL：vector"><a href="#STL：vector" class="headerlink" title="STL：vector"></a>STL：vector</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;                    <span class="comment">// 创建一个空的vector  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;                <span class="comment">// 创建一个含有10个元素的vector，默认初始化为0  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;            <span class="comment">// 创建一个含有10个元素的vector，每个元素值为42  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v)</span></span>;                <span class="comment">// 复制构造函数，创建一个v的副本v2  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// 使用迭代器创建v的一个副本v3</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">//int数组初始化int a[3]= &#123;1, 2, 3&#125;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;  </span><br><span class="line">v2 = v1;                          <span class="comment">// 使用赋值运算符复制v1到v2  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1)</span></span>;               <span class="comment">// 直接在构造时复制v1到v3（复制构造函数）</span></span><br></pre></td></tr></table></figure>

<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;  </span><br><span class="line"><span class="type">int</span> first = v[<span class="number">0</span>];                 <span class="comment">// 访问第一个元素，值为10  </span></span><br><span class="line"><span class="type">int</span> last = v.<span class="built_in">back</span>();              <span class="comment">// 访问最后一个元素，值为50  </span></span><br><span class="line"><span class="type">int</span> at_pos_2 = v.<span class="built_in">at</span>(<span class="number">2</span>);           <span class="comment">// 访问位置为2的元素，并进行边界检查，值为30</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it) &#123;  </span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;           <span class="comment">// 输出1 2 3 4 5   </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C++11及之后的版本可以使用范围for循环  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : v) &#123;  </span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;           <span class="comment">// 输出1 2 3 4 5   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;  </span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);  </span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;         <span class="comment">// 输出元素数量，值为1  </span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;     <span class="comment">// 输出当前已分配的内存可以容纳的元素数量，至少为1  </span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">10</span>);                    <span class="comment">// 预留至少10个元素的空间（不改变size，但可能影响capacity）  </span></span><br><span class="line">cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;     <span class="comment">// 输出可能增加，但至少为10</span></span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  </span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);                   <span class="comment">// 在末尾添加元素4，现在v为&#123;1, 2, 3, 4&#125;  </span></span><br><span class="line">v.<span class="built_in">pop_back</span>();                     <span class="comment">// 移除末尾元素，现在v为&#123;1, 2, 3&#125;  </span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">99</span>);      <span class="comment">// 在位置1插入元素99，现在v为&#123;1, 99, 2, 3&#125;  </span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>()); <span class="comment">// 在v1的末尾插入v2的所有元素  </span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>);           <span class="comment">// 删除位置1的元素，现在v为&#123;1, 2, 3&#125;  </span></span><br><span class="line">v.<span class="built_in">clear</span>();                        <span class="comment">// 清空vector，现在v为空&#123;&#125;</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);                      <span class="comment">// 将vector的大小改为3，删除或者添加末尾的元素</span></span><br></pre></td></tr></table></figure>

<p>在C++中，”reverse”通常指的是将容器（如数组、向量、列表等）中的元素反转顺序，它可以用来反转任何支持双向迭代器的容器。</p>
<p>​    std::reverse(numbers.begin(), numbers.end());  </p>
<p>if (rightNode) 判断一个指针式否为空，为空返回false，不为空返回true。</p>
<p><code>deque</code>（双端队列）经常作为<code>stack</code>和<code>queue</code>的底层容器使用。</p>
<h3 id="1-stack（栈）"><a href="#1-stack（栈）" class="headerlink" title="1. stack（栈）"></a>1. stack（栈）</h3><p><code>stack</code>是一个后进先出（LIFO）的数据结构。在STL中，你可以通过以下方式使用它：</p>
<h4 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>&gt; s; <span class="comment">// 默认使用deque作为底层容器  </span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; s_vec; <span class="comment">// 使用vector作为底层容器  </span></span><br><span class="line">std::stack&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;&gt; s_deq; <span class="comment">// 使用deque作为底层容器（实际上与默认情况相同）</span></span><br></pre></td></tr></table></figure>

<h4 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h4><ul>
<li><code>push(const value_type&amp; val)</code>: 将元素压入栈顶。没有返回值。</li>
<li><code>pop()</code>: 删除栈顶元素。没有返回值</li>
<li><code>top()</code>: 返回栈顶元素的引用。如果栈不为空，则返回栈顶元素的引用；如果栈为空，则行为是未定义的（通常会导致程序崩溃）。</li>
<li><code>empty()</code>: 检查栈是否为空。返回一个布尔值，如果栈为空则返回<code>true</code>，否则返回<code>false</code>。</li>
<li><code>size()</code>: 返回栈中元素的数量。返回一个整数</li>
</ul>
<h3 id="2-queue（队列）"><a href="#2-queue（队列）" class="headerlink" title="2. queue（队列）"></a>2. queue（队列）</h3><p><code>queue</code>是一个先进先出（FIFO）的数据结构。在STL中，你可以通过以下方式使用它：</p>
<h4 id="声明和初始化-1"><a href="#声明和初始化-1" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 默认使用deque作为底层容器  </span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; q_list; <span class="comment">// 使用list作为底层容器  </span></span><br><span class="line">std::queue&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;&gt; q_deq; <span class="comment">// 使用deque作为底层容器（实际上与默认情况相同）</span></span><br></pre></td></tr></table></figure>

<h4 id="主要成员函数-1"><a href="#主要成员函数-1" class="headerlink" title="主要成员函数"></a>主要成员函数</h4><ul>
<li><p><code>push(const value_type&amp; val)</code>: 将元素添加到队列末尾。</p>
</li>
<li><p><code>pop()</code>: 删除队列的第一个元素。</p>
<ul>
<li><code>front()</code>: 返回队列的第一个元素的引用。</li>
</ul>
</li>
<li><p><code>back()</code>: 返回队列的最后一个元素的引用（注意：这不是标准队列操作，但在STL的<code>queue</code>中提供）。</p>
</li>
<li><p><code>empty()</code>: 检查队列是否为空。</p>
</li>
<li><p><code>size()</code>: 返回队列中元素的数量。</p>
</li>
</ul>
<h3 id="3-deque（双端队列）"><a href="#3-deque（双端队列）" class="headerlink" title="3. deque（双端队列）"></a>3. deque（双端队列）</h3><p>虽然你提到的是<code>stack</code>和<code>queue</code>，但<code>deque</code>是一个独立的容器，它支持在两端进行插入和删除操作。它可以用作<code>stack</code>和<code>queue</code>的底层容器。</p>
<h4 id="声明和初始化-2"><a href="#声明和初始化-2" class="headerlink" title="声明和初始化"></a>声明和初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpp复制代码</span><br><span class="line"></span><br><span class="line">std::deque&lt;<span class="type">int</span>&gt; d;</span><br></pre></td></tr></table></figure>

<h4 id="主要成员函数-2"><a href="#主要成员函数-2" class="headerlink" title="主要成员函数"></a>主要成员函数</h4><ul>
<li><code>push_front(const value_type&amp; val)</code>: 在双端队列的前端插入元素。</li>
<li><code>push_back(const value_type&amp; val)</code>: 在双端队列的末尾插入元素。</li>
<li><code>pop_front()</code>: 删除双端队列的第一个元素。</li>
<li><code>pop_back()</code>: 删除双端队列的最后一个元素。</li>
<li><code>front()</code>: 返回双端队列的第一个元素的引用。</li>
<li><code>back()</code>: 返回双端队列的最后一个元素的引用。</li>
<li><code>empty()</code>: 检查双端队列是否为空。</li>
<li><code>size()</code>: 返回双端队列中元素的数量。</li>
</ul>
<h2 id="哈希数据"><a href="#哈希数据" class="headerlink" title="哈希数据"></a>哈希数据</h2><ul>
<li>set（集合）</li>
<li>map(映射)</li>
</ul>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td><strong>红黑树</strong></td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td><strong>O(log n)</strong></td>
<td><strong>O(log n)</strong></td>
</tr>
<tr>
<td>std::multiset</td>
<td><strong>红黑树</strong></td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td><strong>O(logn)</strong></td>
<td><strong>O(logn)</strong></td>
</tr>
<tr>
<td>std::unordered_set</td>
<td><strong>哈希表</strong></td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td><strong>O(1)</strong></td>
<td><strong>O(1)</strong></td>
</tr>
</tbody></table>
<p>重点关注实现方式以及查询效率，所以一般情况下我们都使用unordered_set和unordered_map可以提升效率。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td><strong>红黑树</strong></td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td><strong>O(logn)</strong></td>
<td><strong>O(logn)</strong></td>
</tr>
<tr>
<td>std::multimap</td>
<td><strong>红黑树</strong></td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td><strong>O(log n)</strong></td>
<td><strong>O(log n)</strong></td>
</tr>
<tr>
<td>std::unordered_map</td>
<td><strong>哈希表</strong></td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td><strong>O(1)</strong></td>
<td><strong>O(1)</strong></td>
</tr>
</tbody></table>
<p>构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; ageMap; <span class="comment">// 创建一个unordered_map，键为string类型，值为int类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.insert(make_pair(&quot;Alice&quot;, 30))</span><br></pre></td></tr></table></figure>

<p>或者使用<code>map[j] = i;</code> 的语法来插入或更新元素，这里的 <code>map</code> 是一个 <code>unordered_map</code> 的变量名，<code>j</code> 是键（key），<code>i</code> 是值（value）。</p>
<p><strong>插入与更新</strong>：如果该键 <code>j</code> 已经存在于 <code>unordered_map</code> 中，则 <code>map[j] = i;</code> 会更新该键对应的值为 <code>i</code>。如果该键 <code>j</code> 不存在，它会在 <code>unordered_map</code> 中插入一个新元素，键为 <code>j</code>，值为 <code>i</code>。</p>
<p>查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = ageMap.<span class="built_in">find</span>(<span class="string">&quot;Charlie&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span> (it != ageMap.<span class="built_in">end</span>()) &#123;  </span><br><span class="line">  <span class="comment">// 找到了  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Charlie&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  <span class="comment">// 没找到  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Charlie not found&quot;</span> &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你有一个指向<code>map</code>或<code>unordered_map</code>中元素的迭代器<code>it</code>时：</p>
<ul>
<li><code>it-&gt;first</code> 表示当前元素（键值对）的键。</li>
<li><code>it-&gt;second</code> 表示当前元素（键值对）的值。</li>
</ul>
<h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><p>在C++中，<code>std::string</code>是一个非常有用的类，它表示可变长度的字符串。这个类提供了许多方法来操作字符串。以下是一些常用的<code>std::string</code>成员函数：</p>
<ol>
<li><p><strong>构造函数和析构函数</strong></p>
<ul>
<li><code>string()</code>: 构造一个空的字符串</li>
<li><code>string(const string&amp; str)</code>: 拷贝构造函数</li>
</ul>
</li>
<li><p><strong>访问和修改</strong></p>
<ul>
<li><code>at(size_t pos)</code>: 通过索引访问字符，同时进行范围检查</li>
<li><code>front()</code>: 返回字符串的第一个字符</li>
<li><code>back()</code>: 返回字符串的最后一个字符</li>
<li><code>+=</code>: 连接字符串或字符</li>
<li><code>append()</code>: 在字符串末尾添加字符或字符串</li>
<li><code>push_back(char c)</code>: 在字符串末尾添加一个字符</li>
<li><code>insert()</code>: 在指定位置插入字符或字符串</li>
<li><code>erase()</code>: 删除从指定位置开始的特定数量的字符</li>
<li><code>replace()</code>: 替换字符串中的一部分</li>
<li><code>swap()</code>: 交换两个字符串的内容</li>
<li><code>clear()</code>: 清空字符串内容</li>
</ul>
</li>
<li><p><strong>字符串信息</strong></p>
<ul>
<li><code>size() / length()</code>: 返回字符串的长度</li>
<li><code>empty()</code>: 检查字符串是否为空</li>
<li><code>capacity()</code>: 返回当前分配的存储空间的大小</li>
<li><code>reserve()</code>: 预留一定的存储空间</li>
<li><code>resize()</code>: 改变字符串的大小</li>
</ul>
</li>
<li><p><strong>查找和比较</strong></p>
<ul>
<li><code>find()</code>: 查找子字符串或字符的位置</li>
</ul>
</li>
<li><p><strong>其他实用函数</strong></p>
<ul>
<li><code>substr()</code>: 返回一个新的字符串，它是此字符串的一个子字符串</li>
<li><code>c_str()</code>: 返回一个指向正规C字符串的指针, 内容与本字符串相同</li>
<li><code>get_allocator()</code>: 返回配置器</li>
</ul>
</li>
</ol>
<p><strong>添加字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 方法2: 使用 + 运算符</span><br><span class="line">str1 += str2.substr(0, 3); // 添加 str2 的前三个字符到 str1</span><br></pre></td></tr></table></figure>

<p><code>reserve()</code>: 函数确实遵循左闭右开原则。这是 C++ 标准库中许多函数共有的范围</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode &#123;</span><br><span class="line">    int val; // 节点存储的数据</span><br><span class="line">    ListNode *next; // 指向下一个节点的指针</span><br><span class="line">    ListNode(int x) : val(x), next(nullptr) &#123;&#125; // 构造函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整行字符串输入"><a href="#整行字符串输入" class="headerlink" title="整行字符串输入"></a>整行字符串输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">    <span class="comment">// 接受⼀整⾏字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getchar</span>(); </span><br></pre></td></tr></table></figure>

<h2 id="一行不确定输入"><a href="#一行不确定输入" class="headerlink" title="一行不确定输入"></a>一行不确定输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Enter line &quot;</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">       std::string line;</span><br><span class="line">       std::<span class="built_in">getline</span>(std::cin, line);</span><br><span class="line"></span><br><span class="line">       <span class="function">std::istringstream <span class="title">iss</span><span class="params">(line)</span></span>;</span><br><span class="line">       std::vector&lt;<span class="type">int</span>&gt; lineData;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> num;</span><br><span class="line">       <span class="keyword">while</span> (iss &gt;&gt; num) &#123;</span><br><span class="line">           lineData.<span class="built_in">push_back</span>(num);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）输入数字：</span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;i)&#123;</span><br><span class="line"> </span><br><span class="line">     cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）输入字符串：</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,s))&#123;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</span><br></pre></td></tr></table></figure>

<p>第一个是放入的类型，第二个是存储的方式，第三个是从小到大，less是从大到小</p>
<p>没有遍历只有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">pq.<span class="built_in">push</span>()</span><br><span class="line">pq.<span class="built_in">top</span>()    </span><br><span class="line">pq.<span class="built_in">pop</span>() </span><br></pre></td></tr></table></figure>

<p>自定义比较函数</p>
<ul>
<li>大顶堆：在大顶堆中，父节点的值大于或等于其每个子节点的值。因此，堆的根节点（顶部节点）是堆中的最大值。</li>
<li>小顶堆：在小顶堆中，父节点的值小于或等于其每个子节点的值。因此，堆的根节点（顶部节点）是堆中的最小值。</li>
</ul>
<p>小顶堆的意思是优先队列的头部元素（即队首元素）是最小的。priority_queue默认使用的是大顶堆，也就是说队首元素是最大的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从头到尾是从小到大</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规的从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b; <span class="comment">// 按照升序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++数据结构</p><p><a href="https://jiangzeshuo.github.io/2024/04/29/C++数据结构/">https://jiangzeshuo.github.io/2024/04/29/C++数据结构/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>jzs</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-29</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-29</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/04/29/%E6%89%8B%E5%86%99DQN/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">手写DQN</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/10/%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0/"><span class="level-item">量子强化学习</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="SOHUCS" sid="2024/04/29/C++数据结构/"></div><script charset="utf-8" src="https://changyan.sohu.com/upload/changyan.js"></script><script>window.changyan.api.config({appid: 'cyxaAhbb6',conf: 'prod_6145588b29d62a9031690cf009c197f4'});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Jiang Zeshuo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Jiang Zeshuo</p><p class="is-size-6 is-block">记录我不断拓展学识边界的征程。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">28</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/jiangzeshuo" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/jiangzeshuo"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:972653466@qq.com"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">推荐系统</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A7%91%E7%A0%94/"><span class="level-start"><span class="level-item">科研</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%A7%91%E7%A0%94/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">强化学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%A7%91%E7%A0%94-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">科研 - 强化学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">计算机基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-29T01:35:19.844Z">2024-04-29</time></p><p class="title"><a href="/2024/04/29/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%88%A9%E7%94%A8%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE/">推荐系统-用户数据分析</a></p><p class="categories"><a href="/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">推荐系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-29T01:35:19.836Z">2024-04-29</time></p><p class="title"><a href="/2024/04/29/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/">推荐系统-推荐系统简介</a></p><p class="categories"><a href="/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">推荐系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-29T01:31:44.948Z">2024-04-29</time></p><p class="title"><a href="/2024/04/29/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-29T01:28:44.507Z">2024-04-29</time></p><p class="title"><a href="/2024/04/29/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Python数据结构</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-29T01:27:22.129Z">2024-04-29</time></p><p class="title"><a href="/2024/04/29/%E6%89%8B%E5%86%99DQN/">手写DQN</a></p><p class="categories"><a href="/categories/%E7%A7%91%E7%A0%94/">科研</a> / <a href="/categories/%E7%A7%91%E7%A0%94/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">强化学习</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"><span class="tag">强化学习</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"><span class="tag">推荐系统</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%8F%E5%AD%90%E5%AD%A6%E4%B9%A0/"><span class="tag">量子学习</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="JzsBlog" height="28"></a><p class="is-size-7"><span>&copy; 2024 jzs</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jiangzeshuo"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>